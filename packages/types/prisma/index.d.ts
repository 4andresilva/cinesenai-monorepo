
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Genero
 * 
 */
export type Genero = $Result.DefaultSelection<Prisma.$GeneroPayload>
/**
 * Model FilmeGenero
 * 
 */
export type FilmeGenero = $Result.DefaultSelection<Prisma.$FilmeGeneroPayload>
/**
 * Model Filme
 * 
 */
export type Filme = $Result.DefaultSelection<Prisma.$FilmePayload>
/**
 * Model FilmeIntegrante
 * 
 */
export type FilmeIntegrante = $Result.DefaultSelection<Prisma.$FilmeIntegrantePayload>
/**
 * Model Integrante
 * 
 */
export type Integrante = $Result.DefaultSelection<Prisma.$IntegrantePayload>
/**
 * Model TipoIntegrante
 * 
 */
export type TipoIntegrante = $Result.DefaultSelection<Prisma.$TipoIntegrantePayload>
/**
 * Model ClassificacaoIndicativa
 * 
 */
export type ClassificacaoIndicativa = $Result.DefaultSelection<Prisma.$ClassificacaoIndicativaPayload>
/**
 * Model TipoIdioma
 * 
 */
export type TipoIdioma = $Result.DefaultSelection<Prisma.$TipoIdiomaPayload>
/**
 * Model TipoSessao
 * 
 */
export type TipoSessao = $Result.DefaultSelection<Prisma.$TipoSessaoPayload>
/**
 * Model Sessao
 * 
 */
export type Sessao = $Result.DefaultSelection<Prisma.$SessaoPayload>
/**
 * Model TipoSala
 * 
 */
export type TipoSala = $Result.DefaultSelection<Prisma.$TipoSalaPayload>
/**
 * Model Sala
 * 
 */
export type Sala = $Result.DefaultSelection<Prisma.$SalaPayload>
/**
 * Model TipoAssento
 * 
 */
export type TipoAssento = $Result.DefaultSelection<Prisma.$TipoAssentoPayload>
/**
 * Model Assento
 * 
 */
export type Assento = $Result.DefaultSelection<Prisma.$AssentoPayload>
/**
 * Model SessaoAssentoStatus
 * 
 */
export type SessaoAssentoStatus = $Result.DefaultSelection<Prisma.$SessaoAssentoStatusPayload>
/**
 * Model SessaoAssento
 * 
 */
export type SessaoAssento = $Result.DefaultSelection<Prisma.$SessaoAssentoPayload>
/**
 * Model TipoEntrada
 * 
 */
export type TipoEntrada = $Result.DefaultSelection<Prisma.$TipoEntradaPayload>
/**
 * Model Ingresso
 * 
 */
export type Ingresso = $Result.DefaultSelection<Prisma.$IngressoPayload>
/**
 * Model FormaPagamento
 * 
 */
export type FormaPagamento = $Result.DefaultSelection<Prisma.$FormaPagamentoPayload>
/**
 * Model Pagamento
 * 
 */
export type Pagamento = $Result.DefaultSelection<Prisma.$PagamentoPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TipoIntegranteEnum: {
  Diretor: 'Diretor',
  Ator: 'Ator'
};

export type TipoIntegranteEnum = (typeof TipoIntegranteEnum)[keyof typeof TipoIntegranteEnum]


export const ClassificacaoIndicativaEnum: {
  Livre: 'Livre',
  A10: 'A10',
  A12: 'A12',
  A14: 'A14',
  A16: 'A16',
  A18: 'A18'
};

export type ClassificacaoIndicativaEnum = (typeof ClassificacaoIndicativaEnum)[keyof typeof ClassificacaoIndicativaEnum]


export const TipoIdiomaEnum: {
  Dublado: 'Dublado',
  Legendado: 'Legendado',
  Original: 'Original'
};

export type TipoIdiomaEnum = (typeof TipoIdiomaEnum)[keyof typeof TipoIdiomaEnum]


export const TipoSessaoEnum: {
  TresD: 'TresD',
  Normal: 'Normal',
  Autismo: 'Autismo'
};

export type TipoSessaoEnum = (typeof TipoSessaoEnum)[keyof typeof TipoSessaoEnum]


export const TipoSalaEnum: {
  SalaNormal: 'SalaNormal',
  SalaVip: 'SalaVip',
  Sala4D: 'Sala4D'
};

export type TipoSalaEnum = (typeof TipoSalaEnum)[keyof typeof TipoSalaEnum]


export const TipoAssentoEnum: {
  Normal: 'Normal',
  Preferencial: 'Preferencial',
  Acompanhante: 'Acompanhante',
  NamoradeiraEsquerda: 'NamoradeiraEsquerda',
  NamoradeiraDireita: 'NamoradeiraDireita'
};

export type TipoAssentoEnum = (typeof TipoAssentoEnum)[keyof typeof TipoAssentoEnum]


export const SessaoAssentoStatusEnum: {
  Reservado: 'Reservado',
  Confirmado: 'Confirmado'
};

export type SessaoAssentoStatusEnum = (typeof SessaoAssentoStatusEnum)[keyof typeof SessaoAssentoStatusEnum]


export const TipoEntradaEnum: {
  Inteira: 'Inteira',
  MeiaEstudante: 'MeiaEstudante',
  MeiaBradesco: 'MeiaBradesco'
};

export type TipoEntradaEnum = (typeof TipoEntradaEnum)[keyof typeof TipoEntradaEnum]


export const FormaPagamentoEnum: {
  CartaoCredito: 'CartaoCredito',
  CartaoDebito: 'CartaoDebito',
  Pix: 'Pix'
};

export type FormaPagamentoEnum = (typeof FormaPagamentoEnum)[keyof typeof FormaPagamentoEnum]

}

export type TipoIntegranteEnum = $Enums.TipoIntegranteEnum

export const TipoIntegranteEnum: typeof $Enums.TipoIntegranteEnum

export type ClassificacaoIndicativaEnum = $Enums.ClassificacaoIndicativaEnum

export const ClassificacaoIndicativaEnum: typeof $Enums.ClassificacaoIndicativaEnum

export type TipoIdiomaEnum = $Enums.TipoIdiomaEnum

export const TipoIdiomaEnum: typeof $Enums.TipoIdiomaEnum

export type TipoSessaoEnum = $Enums.TipoSessaoEnum

export const TipoSessaoEnum: typeof $Enums.TipoSessaoEnum

export type TipoSalaEnum = $Enums.TipoSalaEnum

export const TipoSalaEnum: typeof $Enums.TipoSalaEnum

export type TipoAssentoEnum = $Enums.TipoAssentoEnum

export const TipoAssentoEnum: typeof $Enums.TipoAssentoEnum

export type SessaoAssentoStatusEnum = $Enums.SessaoAssentoStatusEnum

export const SessaoAssentoStatusEnum: typeof $Enums.SessaoAssentoStatusEnum

export type TipoEntradaEnum = $Enums.TipoEntradaEnum

export const TipoEntradaEnum: typeof $Enums.TipoEntradaEnum

export type FormaPagamentoEnum = $Enums.FormaPagamentoEnum

export const FormaPagamentoEnum: typeof $Enums.FormaPagamentoEnum

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Generos
 * const generos = await prisma.genero.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Generos
   * const generos = await prisma.genero.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.genero`: Exposes CRUD operations for the **Genero** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Generos
    * const generos = await prisma.genero.findMany()
    * ```
    */
  get genero(): Prisma.GeneroDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.filmeGenero`: Exposes CRUD operations for the **FilmeGenero** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FilmeGeneros
    * const filmeGeneros = await prisma.filmeGenero.findMany()
    * ```
    */
  get filmeGenero(): Prisma.FilmeGeneroDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.filme`: Exposes CRUD operations for the **Filme** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Filmes
    * const filmes = await prisma.filme.findMany()
    * ```
    */
  get filme(): Prisma.FilmeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.filmeIntegrante`: Exposes CRUD operations for the **FilmeIntegrante** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FilmeIntegrantes
    * const filmeIntegrantes = await prisma.filmeIntegrante.findMany()
    * ```
    */
  get filmeIntegrante(): Prisma.FilmeIntegranteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.integrante`: Exposes CRUD operations for the **Integrante** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Integrantes
    * const integrantes = await prisma.integrante.findMany()
    * ```
    */
  get integrante(): Prisma.IntegranteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tipoIntegrante`: Exposes CRUD operations for the **TipoIntegrante** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoIntegrantes
    * const tipoIntegrantes = await prisma.tipoIntegrante.findMany()
    * ```
    */
  get tipoIntegrante(): Prisma.TipoIntegranteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.classificacaoIndicativa`: Exposes CRUD operations for the **ClassificacaoIndicativa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClassificacaoIndicativas
    * const classificacaoIndicativas = await prisma.classificacaoIndicativa.findMany()
    * ```
    */
  get classificacaoIndicativa(): Prisma.ClassificacaoIndicativaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tipoIdioma`: Exposes CRUD operations for the **TipoIdioma** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoIdiomas
    * const tipoIdiomas = await prisma.tipoIdioma.findMany()
    * ```
    */
  get tipoIdioma(): Prisma.TipoIdiomaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tipoSessao`: Exposes CRUD operations for the **TipoSessao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoSessaos
    * const tipoSessaos = await prisma.tipoSessao.findMany()
    * ```
    */
  get tipoSessao(): Prisma.TipoSessaoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessao`: Exposes CRUD operations for the **Sessao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessaos
    * const sessaos = await prisma.sessao.findMany()
    * ```
    */
  get sessao(): Prisma.SessaoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tipoSala`: Exposes CRUD operations for the **TipoSala** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoSalas
    * const tipoSalas = await prisma.tipoSala.findMany()
    * ```
    */
  get tipoSala(): Prisma.TipoSalaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sala`: Exposes CRUD operations for the **Sala** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Salas
    * const salas = await prisma.sala.findMany()
    * ```
    */
  get sala(): Prisma.SalaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tipoAssento`: Exposes CRUD operations for the **TipoAssento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoAssentos
    * const tipoAssentos = await prisma.tipoAssento.findMany()
    * ```
    */
  get tipoAssento(): Prisma.TipoAssentoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.assento`: Exposes CRUD operations for the **Assento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Assentos
    * const assentos = await prisma.assento.findMany()
    * ```
    */
  get assento(): Prisma.AssentoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessaoAssentoStatus`: Exposes CRUD operations for the **SessaoAssentoStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessaoAssentoStatuses
    * const sessaoAssentoStatuses = await prisma.sessaoAssentoStatus.findMany()
    * ```
    */
  get sessaoAssentoStatus(): Prisma.SessaoAssentoStatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessaoAssento`: Exposes CRUD operations for the **SessaoAssento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SessaoAssentos
    * const sessaoAssentos = await prisma.sessaoAssento.findMany()
    * ```
    */
  get sessaoAssento(): Prisma.SessaoAssentoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tipoEntrada`: Exposes CRUD operations for the **TipoEntrada** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TipoEntradas
    * const tipoEntradas = await prisma.tipoEntrada.findMany()
    * ```
    */
  get tipoEntrada(): Prisma.TipoEntradaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ingresso`: Exposes CRUD operations for the **Ingresso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ingressos
    * const ingressos = await prisma.ingresso.findMany()
    * ```
    */
  get ingresso(): Prisma.IngressoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.formaPagamento`: Exposes CRUD operations for the **FormaPagamento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FormaPagamentos
    * const formaPagamentos = await prisma.formaPagamento.findMany()
    * ```
    */
  get formaPagamento(): Prisma.FormaPagamentoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pagamento`: Exposes CRUD operations for the **Pagamento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pagamentos
    * const pagamentos = await prisma.pagamento.findMany()
    * ```
    */
  get pagamento(): Prisma.PagamentoDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.9.0
   * Query Engine version: 81e4af48011447c3cc503a190e86995b66d2a28e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Genero: 'Genero',
    FilmeGenero: 'FilmeGenero',
    Filme: 'Filme',
    FilmeIntegrante: 'FilmeIntegrante',
    Integrante: 'Integrante',
    TipoIntegrante: 'TipoIntegrante',
    ClassificacaoIndicativa: 'ClassificacaoIndicativa',
    TipoIdioma: 'TipoIdioma',
    TipoSessao: 'TipoSessao',
    Sessao: 'Sessao',
    TipoSala: 'TipoSala',
    Sala: 'Sala',
    TipoAssento: 'TipoAssento',
    Assento: 'Assento',
    SessaoAssentoStatus: 'SessaoAssentoStatus',
    SessaoAssento: 'SessaoAssento',
    TipoEntrada: 'TipoEntrada',
    Ingresso: 'Ingresso',
    FormaPagamento: 'FormaPagamento',
    Pagamento: 'Pagamento'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "genero" | "filmeGenero" | "filme" | "filmeIntegrante" | "integrante" | "tipoIntegrante" | "classificacaoIndicativa" | "tipoIdioma" | "tipoSessao" | "sessao" | "tipoSala" | "sala" | "tipoAssento" | "assento" | "sessaoAssentoStatus" | "sessaoAssento" | "tipoEntrada" | "ingresso" | "formaPagamento" | "pagamento"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Genero: {
        payload: Prisma.$GeneroPayload<ExtArgs>
        fields: Prisma.GeneroFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GeneroFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneroPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GeneroFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneroPayload>
          }
          findFirst: {
            args: Prisma.GeneroFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneroPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GeneroFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneroPayload>
          }
          findMany: {
            args: Prisma.GeneroFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneroPayload>[]
          }
          create: {
            args: Prisma.GeneroCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneroPayload>
          }
          createMany: {
            args: Prisma.GeneroCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GeneroCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneroPayload>[]
          }
          delete: {
            args: Prisma.GeneroDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneroPayload>
          }
          update: {
            args: Prisma.GeneroUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneroPayload>
          }
          deleteMany: {
            args: Prisma.GeneroDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GeneroUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GeneroUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneroPayload>[]
          }
          upsert: {
            args: Prisma.GeneroUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GeneroPayload>
          }
          aggregate: {
            args: Prisma.GeneroAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGenero>
          }
          groupBy: {
            args: Prisma.GeneroGroupByArgs<ExtArgs>
            result: $Utils.Optional<GeneroGroupByOutputType>[]
          }
          count: {
            args: Prisma.GeneroCountArgs<ExtArgs>
            result: $Utils.Optional<GeneroCountAggregateOutputType> | number
          }
        }
      }
      FilmeGenero: {
        payload: Prisma.$FilmeGeneroPayload<ExtArgs>
        fields: Prisma.FilmeGeneroFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FilmeGeneroFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmeGeneroPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FilmeGeneroFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmeGeneroPayload>
          }
          findFirst: {
            args: Prisma.FilmeGeneroFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmeGeneroPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FilmeGeneroFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmeGeneroPayload>
          }
          findMany: {
            args: Prisma.FilmeGeneroFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmeGeneroPayload>[]
          }
          create: {
            args: Prisma.FilmeGeneroCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmeGeneroPayload>
          }
          createMany: {
            args: Prisma.FilmeGeneroCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FilmeGeneroCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmeGeneroPayload>[]
          }
          delete: {
            args: Prisma.FilmeGeneroDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmeGeneroPayload>
          }
          update: {
            args: Prisma.FilmeGeneroUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmeGeneroPayload>
          }
          deleteMany: {
            args: Prisma.FilmeGeneroDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FilmeGeneroUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FilmeGeneroUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmeGeneroPayload>[]
          }
          upsert: {
            args: Prisma.FilmeGeneroUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmeGeneroPayload>
          }
          aggregate: {
            args: Prisma.FilmeGeneroAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFilmeGenero>
          }
          groupBy: {
            args: Prisma.FilmeGeneroGroupByArgs<ExtArgs>
            result: $Utils.Optional<FilmeGeneroGroupByOutputType>[]
          }
          count: {
            args: Prisma.FilmeGeneroCountArgs<ExtArgs>
            result: $Utils.Optional<FilmeGeneroCountAggregateOutputType> | number
          }
        }
      }
      Filme: {
        payload: Prisma.$FilmePayload<ExtArgs>
        fields: Prisma.FilmeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FilmeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FilmeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmePayload>
          }
          findFirst: {
            args: Prisma.FilmeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FilmeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmePayload>
          }
          findMany: {
            args: Prisma.FilmeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmePayload>[]
          }
          create: {
            args: Prisma.FilmeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmePayload>
          }
          createMany: {
            args: Prisma.FilmeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FilmeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmePayload>[]
          }
          delete: {
            args: Prisma.FilmeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmePayload>
          }
          update: {
            args: Prisma.FilmeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmePayload>
          }
          deleteMany: {
            args: Prisma.FilmeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FilmeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FilmeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmePayload>[]
          }
          upsert: {
            args: Prisma.FilmeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmePayload>
          }
          aggregate: {
            args: Prisma.FilmeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFilme>
          }
          groupBy: {
            args: Prisma.FilmeGroupByArgs<ExtArgs>
            result: $Utils.Optional<FilmeGroupByOutputType>[]
          }
          count: {
            args: Prisma.FilmeCountArgs<ExtArgs>
            result: $Utils.Optional<FilmeCountAggregateOutputType> | number
          }
        }
      }
      FilmeIntegrante: {
        payload: Prisma.$FilmeIntegrantePayload<ExtArgs>
        fields: Prisma.FilmeIntegranteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FilmeIntegranteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmeIntegrantePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FilmeIntegranteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmeIntegrantePayload>
          }
          findFirst: {
            args: Prisma.FilmeIntegranteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmeIntegrantePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FilmeIntegranteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmeIntegrantePayload>
          }
          findMany: {
            args: Prisma.FilmeIntegranteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmeIntegrantePayload>[]
          }
          create: {
            args: Prisma.FilmeIntegranteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmeIntegrantePayload>
          }
          createMany: {
            args: Prisma.FilmeIntegranteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FilmeIntegranteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmeIntegrantePayload>[]
          }
          delete: {
            args: Prisma.FilmeIntegranteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmeIntegrantePayload>
          }
          update: {
            args: Prisma.FilmeIntegranteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmeIntegrantePayload>
          }
          deleteMany: {
            args: Prisma.FilmeIntegranteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FilmeIntegranteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FilmeIntegranteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmeIntegrantePayload>[]
          }
          upsert: {
            args: Prisma.FilmeIntegranteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilmeIntegrantePayload>
          }
          aggregate: {
            args: Prisma.FilmeIntegranteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFilmeIntegrante>
          }
          groupBy: {
            args: Prisma.FilmeIntegranteGroupByArgs<ExtArgs>
            result: $Utils.Optional<FilmeIntegranteGroupByOutputType>[]
          }
          count: {
            args: Prisma.FilmeIntegranteCountArgs<ExtArgs>
            result: $Utils.Optional<FilmeIntegranteCountAggregateOutputType> | number
          }
        }
      }
      Integrante: {
        payload: Prisma.$IntegrantePayload<ExtArgs>
        fields: Prisma.IntegranteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntegranteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrantePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntegranteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrantePayload>
          }
          findFirst: {
            args: Prisma.IntegranteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrantePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntegranteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrantePayload>
          }
          findMany: {
            args: Prisma.IntegranteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrantePayload>[]
          }
          create: {
            args: Prisma.IntegranteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrantePayload>
          }
          createMany: {
            args: Prisma.IntegranteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IntegranteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrantePayload>[]
          }
          delete: {
            args: Prisma.IntegranteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrantePayload>
          }
          update: {
            args: Prisma.IntegranteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrantePayload>
          }
          deleteMany: {
            args: Prisma.IntegranteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntegranteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IntegranteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrantePayload>[]
          }
          upsert: {
            args: Prisma.IntegranteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrantePayload>
          }
          aggregate: {
            args: Prisma.IntegranteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntegrante>
          }
          groupBy: {
            args: Prisma.IntegranteGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntegranteGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntegranteCountArgs<ExtArgs>
            result: $Utils.Optional<IntegranteCountAggregateOutputType> | number
          }
        }
      }
      TipoIntegrante: {
        payload: Prisma.$TipoIntegrantePayload<ExtArgs>
        fields: Prisma.TipoIntegranteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TipoIntegranteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoIntegrantePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TipoIntegranteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoIntegrantePayload>
          }
          findFirst: {
            args: Prisma.TipoIntegranteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoIntegrantePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TipoIntegranteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoIntegrantePayload>
          }
          findMany: {
            args: Prisma.TipoIntegranteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoIntegrantePayload>[]
          }
          create: {
            args: Prisma.TipoIntegranteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoIntegrantePayload>
          }
          createMany: {
            args: Prisma.TipoIntegranteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TipoIntegranteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoIntegrantePayload>[]
          }
          delete: {
            args: Prisma.TipoIntegranteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoIntegrantePayload>
          }
          update: {
            args: Prisma.TipoIntegranteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoIntegrantePayload>
          }
          deleteMany: {
            args: Prisma.TipoIntegranteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TipoIntegranteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TipoIntegranteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoIntegrantePayload>[]
          }
          upsert: {
            args: Prisma.TipoIntegranteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoIntegrantePayload>
          }
          aggregate: {
            args: Prisma.TipoIntegranteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipoIntegrante>
          }
          groupBy: {
            args: Prisma.TipoIntegranteGroupByArgs<ExtArgs>
            result: $Utils.Optional<TipoIntegranteGroupByOutputType>[]
          }
          count: {
            args: Prisma.TipoIntegranteCountArgs<ExtArgs>
            result: $Utils.Optional<TipoIntegranteCountAggregateOutputType> | number
          }
        }
      }
      ClassificacaoIndicativa: {
        payload: Prisma.$ClassificacaoIndicativaPayload<ExtArgs>
        fields: Prisma.ClassificacaoIndicativaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassificacaoIndicativaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificacaoIndicativaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassificacaoIndicativaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificacaoIndicativaPayload>
          }
          findFirst: {
            args: Prisma.ClassificacaoIndicativaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificacaoIndicativaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassificacaoIndicativaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificacaoIndicativaPayload>
          }
          findMany: {
            args: Prisma.ClassificacaoIndicativaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificacaoIndicativaPayload>[]
          }
          create: {
            args: Prisma.ClassificacaoIndicativaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificacaoIndicativaPayload>
          }
          createMany: {
            args: Prisma.ClassificacaoIndicativaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassificacaoIndicativaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificacaoIndicativaPayload>[]
          }
          delete: {
            args: Prisma.ClassificacaoIndicativaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificacaoIndicativaPayload>
          }
          update: {
            args: Prisma.ClassificacaoIndicativaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificacaoIndicativaPayload>
          }
          deleteMany: {
            args: Prisma.ClassificacaoIndicativaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassificacaoIndicativaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassificacaoIndicativaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificacaoIndicativaPayload>[]
          }
          upsert: {
            args: Prisma.ClassificacaoIndicativaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassificacaoIndicativaPayload>
          }
          aggregate: {
            args: Prisma.ClassificacaoIndicativaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassificacaoIndicativa>
          }
          groupBy: {
            args: Prisma.ClassificacaoIndicativaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassificacaoIndicativaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassificacaoIndicativaCountArgs<ExtArgs>
            result: $Utils.Optional<ClassificacaoIndicativaCountAggregateOutputType> | number
          }
        }
      }
      TipoIdioma: {
        payload: Prisma.$TipoIdiomaPayload<ExtArgs>
        fields: Prisma.TipoIdiomaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TipoIdiomaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoIdiomaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TipoIdiomaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoIdiomaPayload>
          }
          findFirst: {
            args: Prisma.TipoIdiomaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoIdiomaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TipoIdiomaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoIdiomaPayload>
          }
          findMany: {
            args: Prisma.TipoIdiomaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoIdiomaPayload>[]
          }
          create: {
            args: Prisma.TipoIdiomaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoIdiomaPayload>
          }
          createMany: {
            args: Prisma.TipoIdiomaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TipoIdiomaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoIdiomaPayload>[]
          }
          delete: {
            args: Prisma.TipoIdiomaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoIdiomaPayload>
          }
          update: {
            args: Prisma.TipoIdiomaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoIdiomaPayload>
          }
          deleteMany: {
            args: Prisma.TipoIdiomaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TipoIdiomaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TipoIdiomaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoIdiomaPayload>[]
          }
          upsert: {
            args: Prisma.TipoIdiomaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoIdiomaPayload>
          }
          aggregate: {
            args: Prisma.TipoIdiomaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipoIdioma>
          }
          groupBy: {
            args: Prisma.TipoIdiomaGroupByArgs<ExtArgs>
            result: $Utils.Optional<TipoIdiomaGroupByOutputType>[]
          }
          count: {
            args: Prisma.TipoIdiomaCountArgs<ExtArgs>
            result: $Utils.Optional<TipoIdiomaCountAggregateOutputType> | number
          }
        }
      }
      TipoSessao: {
        payload: Prisma.$TipoSessaoPayload<ExtArgs>
        fields: Prisma.TipoSessaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TipoSessaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSessaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TipoSessaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSessaoPayload>
          }
          findFirst: {
            args: Prisma.TipoSessaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSessaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TipoSessaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSessaoPayload>
          }
          findMany: {
            args: Prisma.TipoSessaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSessaoPayload>[]
          }
          create: {
            args: Prisma.TipoSessaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSessaoPayload>
          }
          createMany: {
            args: Prisma.TipoSessaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TipoSessaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSessaoPayload>[]
          }
          delete: {
            args: Prisma.TipoSessaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSessaoPayload>
          }
          update: {
            args: Prisma.TipoSessaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSessaoPayload>
          }
          deleteMany: {
            args: Prisma.TipoSessaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TipoSessaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TipoSessaoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSessaoPayload>[]
          }
          upsert: {
            args: Prisma.TipoSessaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSessaoPayload>
          }
          aggregate: {
            args: Prisma.TipoSessaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipoSessao>
          }
          groupBy: {
            args: Prisma.TipoSessaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<TipoSessaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.TipoSessaoCountArgs<ExtArgs>
            result: $Utils.Optional<TipoSessaoCountAggregateOutputType> | number
          }
        }
      }
      Sessao: {
        payload: Prisma.$SessaoPayload<ExtArgs>
        fields: Prisma.SessaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoPayload>
          }
          findFirst: {
            args: Prisma.SessaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoPayload>
          }
          findMany: {
            args: Prisma.SessaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoPayload>[]
          }
          create: {
            args: Prisma.SessaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoPayload>
          }
          createMany: {
            args: Prisma.SessaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessaoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoPayload>[]
          }
          delete: {
            args: Prisma.SessaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoPayload>
          }
          update: {
            args: Prisma.SessaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoPayload>
          }
          deleteMany: {
            args: Prisma.SessaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessaoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoPayload>[]
          }
          upsert: {
            args: Prisma.SessaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoPayload>
          }
          aggregate: {
            args: Prisma.SessaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessao>
          }
          groupBy: {
            args: Prisma.SessaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessaoCountArgs<ExtArgs>
            result: $Utils.Optional<SessaoCountAggregateOutputType> | number
          }
        }
      }
      TipoSala: {
        payload: Prisma.$TipoSalaPayload<ExtArgs>
        fields: Prisma.TipoSalaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TipoSalaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSalaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TipoSalaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSalaPayload>
          }
          findFirst: {
            args: Prisma.TipoSalaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSalaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TipoSalaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSalaPayload>
          }
          findMany: {
            args: Prisma.TipoSalaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSalaPayload>[]
          }
          create: {
            args: Prisma.TipoSalaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSalaPayload>
          }
          createMany: {
            args: Prisma.TipoSalaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TipoSalaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSalaPayload>[]
          }
          delete: {
            args: Prisma.TipoSalaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSalaPayload>
          }
          update: {
            args: Prisma.TipoSalaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSalaPayload>
          }
          deleteMany: {
            args: Prisma.TipoSalaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TipoSalaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TipoSalaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSalaPayload>[]
          }
          upsert: {
            args: Prisma.TipoSalaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoSalaPayload>
          }
          aggregate: {
            args: Prisma.TipoSalaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipoSala>
          }
          groupBy: {
            args: Prisma.TipoSalaGroupByArgs<ExtArgs>
            result: $Utils.Optional<TipoSalaGroupByOutputType>[]
          }
          count: {
            args: Prisma.TipoSalaCountArgs<ExtArgs>
            result: $Utils.Optional<TipoSalaCountAggregateOutputType> | number
          }
        }
      }
      Sala: {
        payload: Prisma.$SalaPayload<ExtArgs>
        fields: Prisma.SalaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaPayload>
          }
          findFirst: {
            args: Prisma.SalaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaPayload>
          }
          findMany: {
            args: Prisma.SalaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaPayload>[]
          }
          create: {
            args: Prisma.SalaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaPayload>
          }
          createMany: {
            args: Prisma.SalaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaPayload>[]
          }
          delete: {
            args: Prisma.SalaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaPayload>
          }
          update: {
            args: Prisma.SalaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaPayload>
          }
          deleteMany: {
            args: Prisma.SalaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaPayload>[]
          }
          upsert: {
            args: Prisma.SalaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaPayload>
          }
          aggregate: {
            args: Prisma.SalaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSala>
          }
          groupBy: {
            args: Prisma.SalaGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalaGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalaCountArgs<ExtArgs>
            result: $Utils.Optional<SalaCountAggregateOutputType> | number
          }
        }
      }
      TipoAssento: {
        payload: Prisma.$TipoAssentoPayload<ExtArgs>
        fields: Prisma.TipoAssentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TipoAssentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAssentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TipoAssentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAssentoPayload>
          }
          findFirst: {
            args: Prisma.TipoAssentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAssentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TipoAssentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAssentoPayload>
          }
          findMany: {
            args: Prisma.TipoAssentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAssentoPayload>[]
          }
          create: {
            args: Prisma.TipoAssentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAssentoPayload>
          }
          createMany: {
            args: Prisma.TipoAssentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TipoAssentoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAssentoPayload>[]
          }
          delete: {
            args: Prisma.TipoAssentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAssentoPayload>
          }
          update: {
            args: Prisma.TipoAssentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAssentoPayload>
          }
          deleteMany: {
            args: Prisma.TipoAssentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TipoAssentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TipoAssentoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAssentoPayload>[]
          }
          upsert: {
            args: Prisma.TipoAssentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoAssentoPayload>
          }
          aggregate: {
            args: Prisma.TipoAssentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipoAssento>
          }
          groupBy: {
            args: Prisma.TipoAssentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<TipoAssentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.TipoAssentoCountArgs<ExtArgs>
            result: $Utils.Optional<TipoAssentoCountAggregateOutputType> | number
          }
        }
      }
      Assento: {
        payload: Prisma.$AssentoPayload<ExtArgs>
        fields: Prisma.AssentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AssentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AssentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssentoPayload>
          }
          findFirst: {
            args: Prisma.AssentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AssentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssentoPayload>
          }
          findMany: {
            args: Prisma.AssentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssentoPayload>[]
          }
          create: {
            args: Prisma.AssentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssentoPayload>
          }
          createMany: {
            args: Prisma.AssentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AssentoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssentoPayload>[]
          }
          delete: {
            args: Prisma.AssentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssentoPayload>
          }
          update: {
            args: Prisma.AssentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssentoPayload>
          }
          deleteMany: {
            args: Prisma.AssentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AssentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AssentoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssentoPayload>[]
          }
          upsert: {
            args: Prisma.AssentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AssentoPayload>
          }
          aggregate: {
            args: Prisma.AssentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAssento>
          }
          groupBy: {
            args: Prisma.AssentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<AssentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.AssentoCountArgs<ExtArgs>
            result: $Utils.Optional<AssentoCountAggregateOutputType> | number
          }
        }
      }
      SessaoAssentoStatus: {
        payload: Prisma.$SessaoAssentoStatusPayload<ExtArgs>
        fields: Prisma.SessaoAssentoStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessaoAssentoStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoAssentoStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessaoAssentoStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoAssentoStatusPayload>
          }
          findFirst: {
            args: Prisma.SessaoAssentoStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoAssentoStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessaoAssentoStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoAssentoStatusPayload>
          }
          findMany: {
            args: Prisma.SessaoAssentoStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoAssentoStatusPayload>[]
          }
          create: {
            args: Prisma.SessaoAssentoStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoAssentoStatusPayload>
          }
          createMany: {
            args: Prisma.SessaoAssentoStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessaoAssentoStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoAssentoStatusPayload>[]
          }
          delete: {
            args: Prisma.SessaoAssentoStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoAssentoStatusPayload>
          }
          update: {
            args: Prisma.SessaoAssentoStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoAssentoStatusPayload>
          }
          deleteMany: {
            args: Prisma.SessaoAssentoStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessaoAssentoStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessaoAssentoStatusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoAssentoStatusPayload>[]
          }
          upsert: {
            args: Prisma.SessaoAssentoStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoAssentoStatusPayload>
          }
          aggregate: {
            args: Prisma.SessaoAssentoStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessaoAssentoStatus>
          }
          groupBy: {
            args: Prisma.SessaoAssentoStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessaoAssentoStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessaoAssentoStatusCountArgs<ExtArgs>
            result: $Utils.Optional<SessaoAssentoStatusCountAggregateOutputType> | number
          }
        }
      }
      SessaoAssento: {
        payload: Prisma.$SessaoAssentoPayload<ExtArgs>
        fields: Prisma.SessaoAssentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessaoAssentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoAssentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessaoAssentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoAssentoPayload>
          }
          findFirst: {
            args: Prisma.SessaoAssentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoAssentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessaoAssentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoAssentoPayload>
          }
          findMany: {
            args: Prisma.SessaoAssentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoAssentoPayload>[]
          }
          create: {
            args: Prisma.SessaoAssentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoAssentoPayload>
          }
          createMany: {
            args: Prisma.SessaoAssentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessaoAssentoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoAssentoPayload>[]
          }
          delete: {
            args: Prisma.SessaoAssentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoAssentoPayload>
          }
          update: {
            args: Prisma.SessaoAssentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoAssentoPayload>
          }
          deleteMany: {
            args: Prisma.SessaoAssentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessaoAssentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessaoAssentoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoAssentoPayload>[]
          }
          upsert: {
            args: Prisma.SessaoAssentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessaoAssentoPayload>
          }
          aggregate: {
            args: Prisma.SessaoAssentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessaoAssento>
          }
          groupBy: {
            args: Prisma.SessaoAssentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessaoAssentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessaoAssentoCountArgs<ExtArgs>
            result: $Utils.Optional<SessaoAssentoCountAggregateOutputType> | number
          }
        }
      }
      TipoEntrada: {
        payload: Prisma.$TipoEntradaPayload<ExtArgs>
        fields: Prisma.TipoEntradaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TipoEntradaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEntradaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TipoEntradaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEntradaPayload>
          }
          findFirst: {
            args: Prisma.TipoEntradaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEntradaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TipoEntradaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEntradaPayload>
          }
          findMany: {
            args: Prisma.TipoEntradaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEntradaPayload>[]
          }
          create: {
            args: Prisma.TipoEntradaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEntradaPayload>
          }
          createMany: {
            args: Prisma.TipoEntradaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TipoEntradaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEntradaPayload>[]
          }
          delete: {
            args: Prisma.TipoEntradaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEntradaPayload>
          }
          update: {
            args: Prisma.TipoEntradaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEntradaPayload>
          }
          deleteMany: {
            args: Prisma.TipoEntradaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TipoEntradaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TipoEntradaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEntradaPayload>[]
          }
          upsert: {
            args: Prisma.TipoEntradaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TipoEntradaPayload>
          }
          aggregate: {
            args: Prisma.TipoEntradaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTipoEntrada>
          }
          groupBy: {
            args: Prisma.TipoEntradaGroupByArgs<ExtArgs>
            result: $Utils.Optional<TipoEntradaGroupByOutputType>[]
          }
          count: {
            args: Prisma.TipoEntradaCountArgs<ExtArgs>
            result: $Utils.Optional<TipoEntradaCountAggregateOutputType> | number
          }
        }
      }
      Ingresso: {
        payload: Prisma.$IngressoPayload<ExtArgs>
        fields: Prisma.IngressoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IngressoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngressoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IngressoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngressoPayload>
          }
          findFirst: {
            args: Prisma.IngressoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngressoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IngressoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngressoPayload>
          }
          findMany: {
            args: Prisma.IngressoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngressoPayload>[]
          }
          create: {
            args: Prisma.IngressoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngressoPayload>
          }
          createMany: {
            args: Prisma.IngressoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IngressoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngressoPayload>[]
          }
          delete: {
            args: Prisma.IngressoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngressoPayload>
          }
          update: {
            args: Prisma.IngressoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngressoPayload>
          }
          deleteMany: {
            args: Prisma.IngressoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IngressoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IngressoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngressoPayload>[]
          }
          upsert: {
            args: Prisma.IngressoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IngressoPayload>
          }
          aggregate: {
            args: Prisma.IngressoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIngresso>
          }
          groupBy: {
            args: Prisma.IngressoGroupByArgs<ExtArgs>
            result: $Utils.Optional<IngressoGroupByOutputType>[]
          }
          count: {
            args: Prisma.IngressoCountArgs<ExtArgs>
            result: $Utils.Optional<IngressoCountAggregateOutputType> | number
          }
        }
      }
      FormaPagamento: {
        payload: Prisma.$FormaPagamentoPayload<ExtArgs>
        fields: Prisma.FormaPagamentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FormaPagamentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormaPagamentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FormaPagamentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormaPagamentoPayload>
          }
          findFirst: {
            args: Prisma.FormaPagamentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormaPagamentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FormaPagamentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormaPagamentoPayload>
          }
          findMany: {
            args: Prisma.FormaPagamentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormaPagamentoPayload>[]
          }
          create: {
            args: Prisma.FormaPagamentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormaPagamentoPayload>
          }
          createMany: {
            args: Prisma.FormaPagamentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FormaPagamentoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormaPagamentoPayload>[]
          }
          delete: {
            args: Prisma.FormaPagamentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormaPagamentoPayload>
          }
          update: {
            args: Prisma.FormaPagamentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormaPagamentoPayload>
          }
          deleteMany: {
            args: Prisma.FormaPagamentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FormaPagamentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FormaPagamentoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormaPagamentoPayload>[]
          }
          upsert: {
            args: Prisma.FormaPagamentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FormaPagamentoPayload>
          }
          aggregate: {
            args: Prisma.FormaPagamentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormaPagamento>
          }
          groupBy: {
            args: Prisma.FormaPagamentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormaPagamentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.FormaPagamentoCountArgs<ExtArgs>
            result: $Utils.Optional<FormaPagamentoCountAggregateOutputType> | number
          }
        }
      }
      Pagamento: {
        payload: Prisma.$PagamentoPayload<ExtArgs>
        fields: Prisma.PagamentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PagamentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PagamentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          findFirst: {
            args: Prisma.PagamentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PagamentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          findMany: {
            args: Prisma.PagamentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>[]
          }
          create: {
            args: Prisma.PagamentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          createMany: {
            args: Prisma.PagamentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PagamentoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>[]
          }
          delete: {
            args: Prisma.PagamentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          update: {
            args: Prisma.PagamentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          deleteMany: {
            args: Prisma.PagamentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PagamentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PagamentoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>[]
          }
          upsert: {
            args: Prisma.PagamentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagamentoPayload>
          }
          aggregate: {
            args: Prisma.PagamentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePagamento>
          }
          groupBy: {
            args: Prisma.PagamentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PagamentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PagamentoCountArgs<ExtArgs>
            result: $Utils.Optional<PagamentoCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    genero?: GeneroOmit
    filmeGenero?: FilmeGeneroOmit
    filme?: FilmeOmit
    filmeIntegrante?: FilmeIntegranteOmit
    integrante?: IntegranteOmit
    tipoIntegrante?: TipoIntegranteOmit
    classificacaoIndicativa?: ClassificacaoIndicativaOmit
    tipoIdioma?: TipoIdiomaOmit
    tipoSessao?: TipoSessaoOmit
    sessao?: SessaoOmit
    tipoSala?: TipoSalaOmit
    sala?: SalaOmit
    tipoAssento?: TipoAssentoOmit
    assento?: AssentoOmit
    sessaoAssentoStatus?: SessaoAssentoStatusOmit
    sessaoAssento?: SessaoAssentoOmit
    tipoEntrada?: TipoEntradaOmit
    ingresso?: IngressoOmit
    formaPagamento?: FormaPagamentoOmit
    pagamento?: PagamentoOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type GeneroCountOutputType
   */

  export type GeneroCountOutputType = {
    filmes: number
  }

  export type GeneroCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filmes?: boolean | GeneroCountOutputTypeCountFilmesArgs
  }

  // Custom InputTypes
  /**
   * GeneroCountOutputType without action
   */
  export type GeneroCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GeneroCountOutputType
     */
    select?: GeneroCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GeneroCountOutputType without action
   */
  export type GeneroCountOutputTypeCountFilmesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilmeGeneroWhereInput
  }


  /**
   * Count Type FilmeCountOutputType
   */

  export type FilmeCountOutputType = {
    generos: number
    integrantes: number
    sessoes: number
  }

  export type FilmeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generos?: boolean | FilmeCountOutputTypeCountGenerosArgs
    integrantes?: boolean | FilmeCountOutputTypeCountIntegrantesArgs
    sessoes?: boolean | FilmeCountOutputTypeCountSessoesArgs
  }

  // Custom InputTypes
  /**
   * FilmeCountOutputType without action
   */
  export type FilmeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilmeCountOutputType
     */
    select?: FilmeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FilmeCountOutputType without action
   */
  export type FilmeCountOutputTypeCountGenerosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilmeGeneroWhereInput
  }

  /**
   * FilmeCountOutputType without action
   */
  export type FilmeCountOutputTypeCountIntegrantesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilmeIntegranteWhereInput
  }

  /**
   * FilmeCountOutputType without action
   */
  export type FilmeCountOutputTypeCountSessoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessaoWhereInput
  }


  /**
   * Count Type IntegranteCountOutputType
   */

  export type IntegranteCountOutputType = {
    filmes: number
  }

  export type IntegranteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filmes?: boolean | IntegranteCountOutputTypeCountFilmesArgs
  }

  // Custom InputTypes
  /**
   * IntegranteCountOutputType without action
   */
  export type IntegranteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IntegranteCountOutputType
     */
    select?: IntegranteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IntegranteCountOutputType without action
   */
  export type IntegranteCountOutputTypeCountFilmesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilmeIntegranteWhereInput
  }


  /**
   * Count Type TipoIntegranteCountOutputType
   */

  export type TipoIntegranteCountOutputType = {
    integrantes: number
  }

  export type TipoIntegranteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    integrantes?: boolean | TipoIntegranteCountOutputTypeCountIntegrantesArgs
  }

  // Custom InputTypes
  /**
   * TipoIntegranteCountOutputType without action
   */
  export type TipoIntegranteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoIntegranteCountOutputType
     */
    select?: TipoIntegranteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TipoIntegranteCountOutputType without action
   */
  export type TipoIntegranteCountOutputTypeCountIntegrantesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegranteWhereInput
  }


  /**
   * Count Type ClassificacaoIndicativaCountOutputType
   */

  export type ClassificacaoIndicativaCountOutputType = {
    filmes: number
  }

  export type ClassificacaoIndicativaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filmes?: boolean | ClassificacaoIndicativaCountOutputTypeCountFilmesArgs
  }

  // Custom InputTypes
  /**
   * ClassificacaoIndicativaCountOutputType without action
   */
  export type ClassificacaoIndicativaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassificacaoIndicativaCountOutputType
     */
    select?: ClassificacaoIndicativaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassificacaoIndicativaCountOutputType without action
   */
  export type ClassificacaoIndicativaCountOutputTypeCountFilmesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilmeWhereInput
  }


  /**
   * Count Type TipoIdiomaCountOutputType
   */

  export type TipoIdiomaCountOutputType = {
    sessoes: number
  }

  export type TipoIdiomaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessoes?: boolean | TipoIdiomaCountOutputTypeCountSessoesArgs
  }

  // Custom InputTypes
  /**
   * TipoIdiomaCountOutputType without action
   */
  export type TipoIdiomaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoIdiomaCountOutputType
     */
    select?: TipoIdiomaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TipoIdiomaCountOutputType without action
   */
  export type TipoIdiomaCountOutputTypeCountSessoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessaoWhereInput
  }


  /**
   * Count Type TipoSessaoCountOutputType
   */

  export type TipoSessaoCountOutputType = {
    sessoes: number
  }

  export type TipoSessaoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessoes?: boolean | TipoSessaoCountOutputTypeCountSessoesArgs
  }

  // Custom InputTypes
  /**
   * TipoSessaoCountOutputType without action
   */
  export type TipoSessaoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSessaoCountOutputType
     */
    select?: TipoSessaoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TipoSessaoCountOutputType without action
   */
  export type TipoSessaoCountOutputTypeCountSessoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessaoWhereInput
  }


  /**
   * Count Type SessaoCountOutputType
   */

  export type SessaoCountOutputType = {
    sessoesAssentos: number
  }

  export type SessaoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessoesAssentos?: boolean | SessaoCountOutputTypeCountSessoesAssentosArgs
  }

  // Custom InputTypes
  /**
   * SessaoCountOutputType without action
   */
  export type SessaoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessaoCountOutputType
     */
    select?: SessaoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SessaoCountOutputType without action
   */
  export type SessaoCountOutputTypeCountSessoesAssentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessaoAssentoWhereInput
  }


  /**
   * Count Type TipoSalaCountOutputType
   */

  export type TipoSalaCountOutputType = {
    salas: number
  }

  export type TipoSalaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salas?: boolean | TipoSalaCountOutputTypeCountSalasArgs
  }

  // Custom InputTypes
  /**
   * TipoSalaCountOutputType without action
   */
  export type TipoSalaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSalaCountOutputType
     */
    select?: TipoSalaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TipoSalaCountOutputType without action
   */
  export type TipoSalaCountOutputTypeCountSalasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaWhereInput
  }


  /**
   * Count Type SalaCountOutputType
   */

  export type SalaCountOutputType = {
    sessoes: number
    assentos: number
  }

  export type SalaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessoes?: boolean | SalaCountOutputTypeCountSessoesArgs
    assentos?: boolean | SalaCountOutputTypeCountAssentosArgs
  }

  // Custom InputTypes
  /**
   * SalaCountOutputType without action
   */
  export type SalaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaCountOutputType
     */
    select?: SalaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SalaCountOutputType without action
   */
  export type SalaCountOutputTypeCountSessoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessaoWhereInput
  }

  /**
   * SalaCountOutputType without action
   */
  export type SalaCountOutputTypeCountAssentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssentoWhereInput
  }


  /**
   * Count Type TipoAssentoCountOutputType
   */

  export type TipoAssentoCountOutputType = {
    assentos: number
  }

  export type TipoAssentoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assentos?: boolean | TipoAssentoCountOutputTypeCountAssentosArgs
  }

  // Custom InputTypes
  /**
   * TipoAssentoCountOutputType without action
   */
  export type TipoAssentoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAssentoCountOutputType
     */
    select?: TipoAssentoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TipoAssentoCountOutputType without action
   */
  export type TipoAssentoCountOutputTypeCountAssentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssentoWhereInput
  }


  /**
   * Count Type AssentoCountOutputType
   */

  export type AssentoCountOutputType = {
    sessoesAssentos: number
  }

  export type AssentoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessoesAssentos?: boolean | AssentoCountOutputTypeCountSessoesAssentosArgs
  }

  // Custom InputTypes
  /**
   * AssentoCountOutputType without action
   */
  export type AssentoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AssentoCountOutputType
     */
    select?: AssentoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AssentoCountOutputType without action
   */
  export type AssentoCountOutputTypeCountSessoesAssentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessaoAssentoWhereInput
  }


  /**
   * Count Type SessaoAssentoStatusCountOutputType
   */

  export type SessaoAssentoStatusCountOutputType = {
    sessoesAssentos: number
  }

  export type SessaoAssentoStatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessoesAssentos?: boolean | SessaoAssentoStatusCountOutputTypeCountSessoesAssentosArgs
  }

  // Custom InputTypes
  /**
   * SessaoAssentoStatusCountOutputType without action
   */
  export type SessaoAssentoStatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessaoAssentoStatusCountOutputType
     */
    select?: SessaoAssentoStatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SessaoAssentoStatusCountOutputType without action
   */
  export type SessaoAssentoStatusCountOutputTypeCountSessoesAssentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessaoAssentoWhereInput
  }


  /**
   * Count Type TipoEntradaCountOutputType
   */

  export type TipoEntradaCountOutputType = {
    sessoesAssentos: number
  }

  export type TipoEntradaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessoesAssentos?: boolean | TipoEntradaCountOutputTypeCountSessoesAssentosArgs
  }

  // Custom InputTypes
  /**
   * TipoEntradaCountOutputType without action
   */
  export type TipoEntradaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEntradaCountOutputType
     */
    select?: TipoEntradaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TipoEntradaCountOutputType without action
   */
  export type TipoEntradaCountOutputTypeCountSessoesAssentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessaoAssentoWhereInput
  }


  /**
   * Count Type IngressoCountOutputType
   */

  export type IngressoCountOutputType = {
    sessoesAssentos: number
  }

  export type IngressoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessoesAssentos?: boolean | IngressoCountOutputTypeCountSessoesAssentosArgs
  }

  // Custom InputTypes
  /**
   * IngressoCountOutputType without action
   */
  export type IngressoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the IngressoCountOutputType
     */
    select?: IngressoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * IngressoCountOutputType without action
   */
  export type IngressoCountOutputTypeCountSessoesAssentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessaoAssentoWhereInput
  }


  /**
   * Count Type FormaPagamentoCountOutputType
   */

  export type FormaPagamentoCountOutputType = {
    pagamentos: number
  }

  export type FormaPagamentoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pagamentos?: boolean | FormaPagamentoCountOutputTypeCountPagamentosArgs
  }

  // Custom InputTypes
  /**
   * FormaPagamentoCountOutputType without action
   */
  export type FormaPagamentoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormaPagamentoCountOutputType
     */
    select?: FormaPagamentoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FormaPagamentoCountOutputType without action
   */
  export type FormaPagamentoCountOutputTypeCountPagamentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagamentoWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Genero
   */

  export type AggregateGenero = {
    _count: GeneroCountAggregateOutputType | null
    _avg: GeneroAvgAggregateOutputType | null
    _sum: GeneroSumAggregateOutputType | null
    _min: GeneroMinAggregateOutputType | null
    _max: GeneroMaxAggregateOutputType | null
  }

  export type GeneroAvgAggregateOutputType = {
    id: number | null
  }

  export type GeneroSumAggregateOutputType = {
    id: number | null
  }

  export type GeneroMinAggregateOutputType = {
    id: number | null
    nome: string | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type GeneroMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type GeneroCountAggregateOutputType = {
    id: number
    nome: number
    ativo: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type GeneroAvgAggregateInputType = {
    id?: true
  }

  export type GeneroSumAggregateInputType = {
    id?: true
  }

  export type GeneroMinAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type GeneroMaxAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type GeneroCountAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type GeneroAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Genero to aggregate.
     */
    where?: GeneroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Generos to fetch.
     */
    orderBy?: GeneroOrderByWithRelationInput | GeneroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GeneroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Generos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Generos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Generos
    **/
    _count?: true | GeneroCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GeneroAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GeneroSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GeneroMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GeneroMaxAggregateInputType
  }

  export type GetGeneroAggregateType<T extends GeneroAggregateArgs> = {
        [P in keyof T & keyof AggregateGenero]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGenero[P]>
      : GetScalarType<T[P], AggregateGenero[P]>
  }




  export type GeneroGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GeneroWhereInput
    orderBy?: GeneroOrderByWithAggregationInput | GeneroOrderByWithAggregationInput[]
    by: GeneroScalarFieldEnum[] | GeneroScalarFieldEnum
    having?: GeneroScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GeneroCountAggregateInputType | true
    _avg?: GeneroAvgAggregateInputType
    _sum?: GeneroSumAggregateInputType
    _min?: GeneroMinAggregateInputType
    _max?: GeneroMaxAggregateInputType
  }

  export type GeneroGroupByOutputType = {
    id: number
    nome: string
    ativo: boolean
    criadoEm: Date
    atualizadoEm: Date
    _count: GeneroCountAggregateOutputType | null
    _avg: GeneroAvgAggregateOutputType | null
    _sum: GeneroSumAggregateOutputType | null
    _min: GeneroMinAggregateOutputType | null
    _max: GeneroMaxAggregateOutputType | null
  }

  type GetGeneroGroupByPayload<T extends GeneroGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GeneroGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GeneroGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GeneroGroupByOutputType[P]>
            : GetScalarType<T[P], GeneroGroupByOutputType[P]>
        }
      >
    >


  export type GeneroSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    filmes?: boolean | Genero$filmesArgs<ExtArgs>
    _count?: boolean | GeneroCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["genero"]>

  export type GeneroSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }, ExtArgs["result"]["genero"]>

  export type GeneroSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }, ExtArgs["result"]["genero"]>

  export type GeneroSelectScalar = {
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type GeneroOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "ativo" | "criadoEm" | "atualizadoEm", ExtArgs["result"]["genero"]>
  export type GeneroInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filmes?: boolean | Genero$filmesArgs<ExtArgs>
    _count?: boolean | GeneroCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GeneroIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type GeneroIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $GeneroPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Genero"
    objects: {
      filmes: Prisma.$FilmeGeneroPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      ativo: boolean
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["genero"]>
    composites: {}
  }

  type GeneroGetPayload<S extends boolean | null | undefined | GeneroDefaultArgs> = $Result.GetResult<Prisma.$GeneroPayload, S>

  type GeneroCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GeneroFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GeneroCountAggregateInputType | true
    }

  export interface GeneroDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Genero'], meta: { name: 'Genero' } }
    /**
     * Find zero or one Genero that matches the filter.
     * @param {GeneroFindUniqueArgs} args - Arguments to find a Genero
     * @example
     * // Get one Genero
     * const genero = await prisma.genero.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GeneroFindUniqueArgs>(args: SelectSubset<T, GeneroFindUniqueArgs<ExtArgs>>): Prisma__GeneroClient<$Result.GetResult<Prisma.$GeneroPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Genero that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GeneroFindUniqueOrThrowArgs} args - Arguments to find a Genero
     * @example
     * // Get one Genero
     * const genero = await prisma.genero.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GeneroFindUniqueOrThrowArgs>(args: SelectSubset<T, GeneroFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GeneroClient<$Result.GetResult<Prisma.$GeneroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Genero that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneroFindFirstArgs} args - Arguments to find a Genero
     * @example
     * // Get one Genero
     * const genero = await prisma.genero.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GeneroFindFirstArgs>(args?: SelectSubset<T, GeneroFindFirstArgs<ExtArgs>>): Prisma__GeneroClient<$Result.GetResult<Prisma.$GeneroPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Genero that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneroFindFirstOrThrowArgs} args - Arguments to find a Genero
     * @example
     * // Get one Genero
     * const genero = await prisma.genero.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GeneroFindFirstOrThrowArgs>(args?: SelectSubset<T, GeneroFindFirstOrThrowArgs<ExtArgs>>): Prisma__GeneroClient<$Result.GetResult<Prisma.$GeneroPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Generos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneroFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Generos
     * const generos = await prisma.genero.findMany()
     * 
     * // Get first 10 Generos
     * const generos = await prisma.genero.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const generoWithIdOnly = await prisma.genero.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GeneroFindManyArgs>(args?: SelectSubset<T, GeneroFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Genero.
     * @param {GeneroCreateArgs} args - Arguments to create a Genero.
     * @example
     * // Create one Genero
     * const Genero = await prisma.genero.create({
     *   data: {
     *     // ... data to create a Genero
     *   }
     * })
     * 
     */
    create<T extends GeneroCreateArgs>(args: SelectSubset<T, GeneroCreateArgs<ExtArgs>>): Prisma__GeneroClient<$Result.GetResult<Prisma.$GeneroPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Generos.
     * @param {GeneroCreateManyArgs} args - Arguments to create many Generos.
     * @example
     * // Create many Generos
     * const genero = await prisma.genero.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GeneroCreateManyArgs>(args?: SelectSubset<T, GeneroCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Generos and returns the data saved in the database.
     * @param {GeneroCreateManyAndReturnArgs} args - Arguments to create many Generos.
     * @example
     * // Create many Generos
     * const genero = await prisma.genero.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Generos and only return the `id`
     * const generoWithIdOnly = await prisma.genero.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GeneroCreateManyAndReturnArgs>(args?: SelectSubset<T, GeneroCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneroPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Genero.
     * @param {GeneroDeleteArgs} args - Arguments to delete one Genero.
     * @example
     * // Delete one Genero
     * const Genero = await prisma.genero.delete({
     *   where: {
     *     // ... filter to delete one Genero
     *   }
     * })
     * 
     */
    delete<T extends GeneroDeleteArgs>(args: SelectSubset<T, GeneroDeleteArgs<ExtArgs>>): Prisma__GeneroClient<$Result.GetResult<Prisma.$GeneroPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Genero.
     * @param {GeneroUpdateArgs} args - Arguments to update one Genero.
     * @example
     * // Update one Genero
     * const genero = await prisma.genero.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GeneroUpdateArgs>(args: SelectSubset<T, GeneroUpdateArgs<ExtArgs>>): Prisma__GeneroClient<$Result.GetResult<Prisma.$GeneroPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Generos.
     * @param {GeneroDeleteManyArgs} args - Arguments to filter Generos to delete.
     * @example
     * // Delete a few Generos
     * const { count } = await prisma.genero.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GeneroDeleteManyArgs>(args?: SelectSubset<T, GeneroDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Generos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneroUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Generos
     * const genero = await prisma.genero.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GeneroUpdateManyArgs>(args: SelectSubset<T, GeneroUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Generos and returns the data updated in the database.
     * @param {GeneroUpdateManyAndReturnArgs} args - Arguments to update many Generos.
     * @example
     * // Update many Generos
     * const genero = await prisma.genero.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Generos and only return the `id`
     * const generoWithIdOnly = await prisma.genero.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GeneroUpdateManyAndReturnArgs>(args: SelectSubset<T, GeneroUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GeneroPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Genero.
     * @param {GeneroUpsertArgs} args - Arguments to update or create a Genero.
     * @example
     * // Update or create a Genero
     * const genero = await prisma.genero.upsert({
     *   create: {
     *     // ... data to create a Genero
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Genero we want to update
     *   }
     * })
     */
    upsert<T extends GeneroUpsertArgs>(args: SelectSubset<T, GeneroUpsertArgs<ExtArgs>>): Prisma__GeneroClient<$Result.GetResult<Prisma.$GeneroPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Generos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneroCountArgs} args - Arguments to filter Generos to count.
     * @example
     * // Count the number of Generos
     * const count = await prisma.genero.count({
     *   where: {
     *     // ... the filter for the Generos we want to count
     *   }
     * })
    **/
    count<T extends GeneroCountArgs>(
      args?: Subset<T, GeneroCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GeneroCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Genero.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneroAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GeneroAggregateArgs>(args: Subset<T, GeneroAggregateArgs>): Prisma.PrismaPromise<GetGeneroAggregateType<T>>

    /**
     * Group by Genero.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GeneroGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GeneroGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GeneroGroupByArgs['orderBy'] }
        : { orderBy?: GeneroGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GeneroGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGeneroGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Genero model
   */
  readonly fields: GeneroFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Genero.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GeneroClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    filmes<T extends Genero$filmesArgs<ExtArgs> = {}>(args?: Subset<T, Genero$filmesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilmeGeneroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Genero model
   */
  interface GeneroFieldRefs {
    readonly id: FieldRef<"Genero", 'Int'>
    readonly nome: FieldRef<"Genero", 'String'>
    readonly ativo: FieldRef<"Genero", 'Boolean'>
    readonly criadoEm: FieldRef<"Genero", 'DateTime'>
    readonly atualizadoEm: FieldRef<"Genero", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Genero findUnique
   */
  export type GeneroFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genero
     */
    select?: GeneroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genero
     */
    omit?: GeneroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneroInclude<ExtArgs> | null
    /**
     * Filter, which Genero to fetch.
     */
    where: GeneroWhereUniqueInput
  }

  /**
   * Genero findUniqueOrThrow
   */
  export type GeneroFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genero
     */
    select?: GeneroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genero
     */
    omit?: GeneroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneroInclude<ExtArgs> | null
    /**
     * Filter, which Genero to fetch.
     */
    where: GeneroWhereUniqueInput
  }

  /**
   * Genero findFirst
   */
  export type GeneroFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genero
     */
    select?: GeneroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genero
     */
    omit?: GeneroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneroInclude<ExtArgs> | null
    /**
     * Filter, which Genero to fetch.
     */
    where?: GeneroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Generos to fetch.
     */
    orderBy?: GeneroOrderByWithRelationInput | GeneroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Generos.
     */
    cursor?: GeneroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Generos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Generos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Generos.
     */
    distinct?: GeneroScalarFieldEnum | GeneroScalarFieldEnum[]
  }

  /**
   * Genero findFirstOrThrow
   */
  export type GeneroFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genero
     */
    select?: GeneroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genero
     */
    omit?: GeneroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneroInclude<ExtArgs> | null
    /**
     * Filter, which Genero to fetch.
     */
    where?: GeneroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Generos to fetch.
     */
    orderBy?: GeneroOrderByWithRelationInput | GeneroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Generos.
     */
    cursor?: GeneroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Generos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Generos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Generos.
     */
    distinct?: GeneroScalarFieldEnum | GeneroScalarFieldEnum[]
  }

  /**
   * Genero findMany
   */
  export type GeneroFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genero
     */
    select?: GeneroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genero
     */
    omit?: GeneroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneroInclude<ExtArgs> | null
    /**
     * Filter, which Generos to fetch.
     */
    where?: GeneroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Generos to fetch.
     */
    orderBy?: GeneroOrderByWithRelationInput | GeneroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Generos.
     */
    cursor?: GeneroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Generos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Generos.
     */
    skip?: number
    distinct?: GeneroScalarFieldEnum | GeneroScalarFieldEnum[]
  }

  /**
   * Genero create
   */
  export type GeneroCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genero
     */
    select?: GeneroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genero
     */
    omit?: GeneroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneroInclude<ExtArgs> | null
    /**
     * The data needed to create a Genero.
     */
    data: XOR<GeneroCreateInput, GeneroUncheckedCreateInput>
  }

  /**
   * Genero createMany
   */
  export type GeneroCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Generos.
     */
    data: GeneroCreateManyInput | GeneroCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Genero createManyAndReturn
   */
  export type GeneroCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genero
     */
    select?: GeneroSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Genero
     */
    omit?: GeneroOmit<ExtArgs> | null
    /**
     * The data used to create many Generos.
     */
    data: GeneroCreateManyInput | GeneroCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Genero update
   */
  export type GeneroUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genero
     */
    select?: GeneroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genero
     */
    omit?: GeneroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneroInclude<ExtArgs> | null
    /**
     * The data needed to update a Genero.
     */
    data: XOR<GeneroUpdateInput, GeneroUncheckedUpdateInput>
    /**
     * Choose, which Genero to update.
     */
    where: GeneroWhereUniqueInput
  }

  /**
   * Genero updateMany
   */
  export type GeneroUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Generos.
     */
    data: XOR<GeneroUpdateManyMutationInput, GeneroUncheckedUpdateManyInput>
    /**
     * Filter which Generos to update
     */
    where?: GeneroWhereInput
    /**
     * Limit how many Generos to update.
     */
    limit?: number
  }

  /**
   * Genero updateManyAndReturn
   */
  export type GeneroUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genero
     */
    select?: GeneroSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Genero
     */
    omit?: GeneroOmit<ExtArgs> | null
    /**
     * The data used to update Generos.
     */
    data: XOR<GeneroUpdateManyMutationInput, GeneroUncheckedUpdateManyInput>
    /**
     * Filter which Generos to update
     */
    where?: GeneroWhereInput
    /**
     * Limit how many Generos to update.
     */
    limit?: number
  }

  /**
   * Genero upsert
   */
  export type GeneroUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genero
     */
    select?: GeneroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genero
     */
    omit?: GeneroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneroInclude<ExtArgs> | null
    /**
     * The filter to search for the Genero to update in case it exists.
     */
    where: GeneroWhereUniqueInput
    /**
     * In case the Genero found by the `where` argument doesn't exist, create a new Genero with this data.
     */
    create: XOR<GeneroCreateInput, GeneroUncheckedCreateInput>
    /**
     * In case the Genero was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GeneroUpdateInput, GeneroUncheckedUpdateInput>
  }

  /**
   * Genero delete
   */
  export type GeneroDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genero
     */
    select?: GeneroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genero
     */
    omit?: GeneroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneroInclude<ExtArgs> | null
    /**
     * Filter which Genero to delete.
     */
    where: GeneroWhereUniqueInput
  }

  /**
   * Genero deleteMany
   */
  export type GeneroDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Generos to delete
     */
    where?: GeneroWhereInput
    /**
     * Limit how many Generos to delete.
     */
    limit?: number
  }

  /**
   * Genero.filmes
   */
  export type Genero$filmesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilmeGenero
     */
    select?: FilmeGeneroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilmeGenero
     */
    omit?: FilmeGeneroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeGeneroInclude<ExtArgs> | null
    where?: FilmeGeneroWhereInput
    orderBy?: FilmeGeneroOrderByWithRelationInput | FilmeGeneroOrderByWithRelationInput[]
    cursor?: FilmeGeneroWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FilmeGeneroScalarFieldEnum | FilmeGeneroScalarFieldEnum[]
  }

  /**
   * Genero without action
   */
  export type GeneroDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Genero
     */
    select?: GeneroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Genero
     */
    omit?: GeneroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GeneroInclude<ExtArgs> | null
  }


  /**
   * Model FilmeGenero
   */

  export type AggregateFilmeGenero = {
    _count: FilmeGeneroCountAggregateOutputType | null
    _avg: FilmeGeneroAvgAggregateOutputType | null
    _sum: FilmeGeneroSumAggregateOutputType | null
    _min: FilmeGeneroMinAggregateOutputType | null
    _max: FilmeGeneroMaxAggregateOutputType | null
  }

  export type FilmeGeneroAvgAggregateOutputType = {
    id: number | null
    filmeId: number | null
    generoId: number | null
  }

  export type FilmeGeneroSumAggregateOutputType = {
    id: number | null
    filmeId: number | null
    generoId: number | null
  }

  export type FilmeGeneroMinAggregateOutputType = {
    id: number | null
    filmeId: number | null
    generoId: number | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type FilmeGeneroMaxAggregateOutputType = {
    id: number | null
    filmeId: number | null
    generoId: number | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type FilmeGeneroCountAggregateOutputType = {
    id: number
    filmeId: number
    generoId: number
    ativo: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type FilmeGeneroAvgAggregateInputType = {
    id?: true
    filmeId?: true
    generoId?: true
  }

  export type FilmeGeneroSumAggregateInputType = {
    id?: true
    filmeId?: true
    generoId?: true
  }

  export type FilmeGeneroMinAggregateInputType = {
    id?: true
    filmeId?: true
    generoId?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type FilmeGeneroMaxAggregateInputType = {
    id?: true
    filmeId?: true
    generoId?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type FilmeGeneroCountAggregateInputType = {
    id?: true
    filmeId?: true
    generoId?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type FilmeGeneroAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FilmeGenero to aggregate.
     */
    where?: FilmeGeneroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilmeGeneros to fetch.
     */
    orderBy?: FilmeGeneroOrderByWithRelationInput | FilmeGeneroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FilmeGeneroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilmeGeneros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilmeGeneros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FilmeGeneros
    **/
    _count?: true | FilmeGeneroCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FilmeGeneroAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FilmeGeneroSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FilmeGeneroMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FilmeGeneroMaxAggregateInputType
  }

  export type GetFilmeGeneroAggregateType<T extends FilmeGeneroAggregateArgs> = {
        [P in keyof T & keyof AggregateFilmeGenero]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFilmeGenero[P]>
      : GetScalarType<T[P], AggregateFilmeGenero[P]>
  }




  export type FilmeGeneroGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilmeGeneroWhereInput
    orderBy?: FilmeGeneroOrderByWithAggregationInput | FilmeGeneroOrderByWithAggregationInput[]
    by: FilmeGeneroScalarFieldEnum[] | FilmeGeneroScalarFieldEnum
    having?: FilmeGeneroScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FilmeGeneroCountAggregateInputType | true
    _avg?: FilmeGeneroAvgAggregateInputType
    _sum?: FilmeGeneroSumAggregateInputType
    _min?: FilmeGeneroMinAggregateInputType
    _max?: FilmeGeneroMaxAggregateInputType
  }

  export type FilmeGeneroGroupByOutputType = {
    id: number
    filmeId: number
    generoId: number
    ativo: boolean
    criadoEm: Date
    atualizadoEm: Date
    _count: FilmeGeneroCountAggregateOutputType | null
    _avg: FilmeGeneroAvgAggregateOutputType | null
    _sum: FilmeGeneroSumAggregateOutputType | null
    _min: FilmeGeneroMinAggregateOutputType | null
    _max: FilmeGeneroMaxAggregateOutputType | null
  }

  type GetFilmeGeneroGroupByPayload<T extends FilmeGeneroGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FilmeGeneroGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FilmeGeneroGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FilmeGeneroGroupByOutputType[P]>
            : GetScalarType<T[P], FilmeGeneroGroupByOutputType[P]>
        }
      >
    >


  export type FilmeGeneroSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filmeId?: boolean
    generoId?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    filme?: boolean | FilmeDefaultArgs<ExtArgs>
    genero?: boolean | GeneroDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["filmeGenero"]>

  export type FilmeGeneroSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filmeId?: boolean
    generoId?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    filme?: boolean | FilmeDefaultArgs<ExtArgs>
    genero?: boolean | GeneroDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["filmeGenero"]>

  export type FilmeGeneroSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filmeId?: boolean
    generoId?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    filme?: boolean | FilmeDefaultArgs<ExtArgs>
    genero?: boolean | GeneroDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["filmeGenero"]>

  export type FilmeGeneroSelectScalar = {
    id?: boolean
    filmeId?: boolean
    generoId?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type FilmeGeneroOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "filmeId" | "generoId" | "ativo" | "criadoEm" | "atualizadoEm", ExtArgs["result"]["filmeGenero"]>
  export type FilmeGeneroInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filme?: boolean | FilmeDefaultArgs<ExtArgs>
    genero?: boolean | GeneroDefaultArgs<ExtArgs>
  }
  export type FilmeGeneroIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filme?: boolean | FilmeDefaultArgs<ExtArgs>
    genero?: boolean | GeneroDefaultArgs<ExtArgs>
  }
  export type FilmeGeneroIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filme?: boolean | FilmeDefaultArgs<ExtArgs>
    genero?: boolean | GeneroDefaultArgs<ExtArgs>
  }

  export type $FilmeGeneroPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FilmeGenero"
    objects: {
      filme: Prisma.$FilmePayload<ExtArgs>
      genero: Prisma.$GeneroPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      filmeId: number
      generoId: number
      ativo: boolean
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["filmeGenero"]>
    composites: {}
  }

  type FilmeGeneroGetPayload<S extends boolean | null | undefined | FilmeGeneroDefaultArgs> = $Result.GetResult<Prisma.$FilmeGeneroPayload, S>

  type FilmeGeneroCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FilmeGeneroFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FilmeGeneroCountAggregateInputType | true
    }

  export interface FilmeGeneroDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FilmeGenero'], meta: { name: 'FilmeGenero' } }
    /**
     * Find zero or one FilmeGenero that matches the filter.
     * @param {FilmeGeneroFindUniqueArgs} args - Arguments to find a FilmeGenero
     * @example
     * // Get one FilmeGenero
     * const filmeGenero = await prisma.filmeGenero.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FilmeGeneroFindUniqueArgs>(args: SelectSubset<T, FilmeGeneroFindUniqueArgs<ExtArgs>>): Prisma__FilmeGeneroClient<$Result.GetResult<Prisma.$FilmeGeneroPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FilmeGenero that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FilmeGeneroFindUniqueOrThrowArgs} args - Arguments to find a FilmeGenero
     * @example
     * // Get one FilmeGenero
     * const filmeGenero = await prisma.filmeGenero.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FilmeGeneroFindUniqueOrThrowArgs>(args: SelectSubset<T, FilmeGeneroFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FilmeGeneroClient<$Result.GetResult<Prisma.$FilmeGeneroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FilmeGenero that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilmeGeneroFindFirstArgs} args - Arguments to find a FilmeGenero
     * @example
     * // Get one FilmeGenero
     * const filmeGenero = await prisma.filmeGenero.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FilmeGeneroFindFirstArgs>(args?: SelectSubset<T, FilmeGeneroFindFirstArgs<ExtArgs>>): Prisma__FilmeGeneroClient<$Result.GetResult<Prisma.$FilmeGeneroPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FilmeGenero that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilmeGeneroFindFirstOrThrowArgs} args - Arguments to find a FilmeGenero
     * @example
     * // Get one FilmeGenero
     * const filmeGenero = await prisma.filmeGenero.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FilmeGeneroFindFirstOrThrowArgs>(args?: SelectSubset<T, FilmeGeneroFindFirstOrThrowArgs<ExtArgs>>): Prisma__FilmeGeneroClient<$Result.GetResult<Prisma.$FilmeGeneroPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FilmeGeneros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilmeGeneroFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FilmeGeneros
     * const filmeGeneros = await prisma.filmeGenero.findMany()
     * 
     * // Get first 10 FilmeGeneros
     * const filmeGeneros = await prisma.filmeGenero.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const filmeGeneroWithIdOnly = await prisma.filmeGenero.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FilmeGeneroFindManyArgs>(args?: SelectSubset<T, FilmeGeneroFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilmeGeneroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FilmeGenero.
     * @param {FilmeGeneroCreateArgs} args - Arguments to create a FilmeGenero.
     * @example
     * // Create one FilmeGenero
     * const FilmeGenero = await prisma.filmeGenero.create({
     *   data: {
     *     // ... data to create a FilmeGenero
     *   }
     * })
     * 
     */
    create<T extends FilmeGeneroCreateArgs>(args: SelectSubset<T, FilmeGeneroCreateArgs<ExtArgs>>): Prisma__FilmeGeneroClient<$Result.GetResult<Prisma.$FilmeGeneroPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FilmeGeneros.
     * @param {FilmeGeneroCreateManyArgs} args - Arguments to create many FilmeGeneros.
     * @example
     * // Create many FilmeGeneros
     * const filmeGenero = await prisma.filmeGenero.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FilmeGeneroCreateManyArgs>(args?: SelectSubset<T, FilmeGeneroCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FilmeGeneros and returns the data saved in the database.
     * @param {FilmeGeneroCreateManyAndReturnArgs} args - Arguments to create many FilmeGeneros.
     * @example
     * // Create many FilmeGeneros
     * const filmeGenero = await prisma.filmeGenero.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FilmeGeneros and only return the `id`
     * const filmeGeneroWithIdOnly = await prisma.filmeGenero.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FilmeGeneroCreateManyAndReturnArgs>(args?: SelectSubset<T, FilmeGeneroCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilmeGeneroPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FilmeGenero.
     * @param {FilmeGeneroDeleteArgs} args - Arguments to delete one FilmeGenero.
     * @example
     * // Delete one FilmeGenero
     * const FilmeGenero = await prisma.filmeGenero.delete({
     *   where: {
     *     // ... filter to delete one FilmeGenero
     *   }
     * })
     * 
     */
    delete<T extends FilmeGeneroDeleteArgs>(args: SelectSubset<T, FilmeGeneroDeleteArgs<ExtArgs>>): Prisma__FilmeGeneroClient<$Result.GetResult<Prisma.$FilmeGeneroPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FilmeGenero.
     * @param {FilmeGeneroUpdateArgs} args - Arguments to update one FilmeGenero.
     * @example
     * // Update one FilmeGenero
     * const filmeGenero = await prisma.filmeGenero.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FilmeGeneroUpdateArgs>(args: SelectSubset<T, FilmeGeneroUpdateArgs<ExtArgs>>): Prisma__FilmeGeneroClient<$Result.GetResult<Prisma.$FilmeGeneroPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FilmeGeneros.
     * @param {FilmeGeneroDeleteManyArgs} args - Arguments to filter FilmeGeneros to delete.
     * @example
     * // Delete a few FilmeGeneros
     * const { count } = await prisma.filmeGenero.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FilmeGeneroDeleteManyArgs>(args?: SelectSubset<T, FilmeGeneroDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FilmeGeneros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilmeGeneroUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FilmeGeneros
     * const filmeGenero = await prisma.filmeGenero.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FilmeGeneroUpdateManyArgs>(args: SelectSubset<T, FilmeGeneroUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FilmeGeneros and returns the data updated in the database.
     * @param {FilmeGeneroUpdateManyAndReturnArgs} args - Arguments to update many FilmeGeneros.
     * @example
     * // Update many FilmeGeneros
     * const filmeGenero = await prisma.filmeGenero.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FilmeGeneros and only return the `id`
     * const filmeGeneroWithIdOnly = await prisma.filmeGenero.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FilmeGeneroUpdateManyAndReturnArgs>(args: SelectSubset<T, FilmeGeneroUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilmeGeneroPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FilmeGenero.
     * @param {FilmeGeneroUpsertArgs} args - Arguments to update or create a FilmeGenero.
     * @example
     * // Update or create a FilmeGenero
     * const filmeGenero = await prisma.filmeGenero.upsert({
     *   create: {
     *     // ... data to create a FilmeGenero
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FilmeGenero we want to update
     *   }
     * })
     */
    upsert<T extends FilmeGeneroUpsertArgs>(args: SelectSubset<T, FilmeGeneroUpsertArgs<ExtArgs>>): Prisma__FilmeGeneroClient<$Result.GetResult<Prisma.$FilmeGeneroPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FilmeGeneros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilmeGeneroCountArgs} args - Arguments to filter FilmeGeneros to count.
     * @example
     * // Count the number of FilmeGeneros
     * const count = await prisma.filmeGenero.count({
     *   where: {
     *     // ... the filter for the FilmeGeneros we want to count
     *   }
     * })
    **/
    count<T extends FilmeGeneroCountArgs>(
      args?: Subset<T, FilmeGeneroCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FilmeGeneroCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FilmeGenero.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilmeGeneroAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FilmeGeneroAggregateArgs>(args: Subset<T, FilmeGeneroAggregateArgs>): Prisma.PrismaPromise<GetFilmeGeneroAggregateType<T>>

    /**
     * Group by FilmeGenero.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilmeGeneroGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FilmeGeneroGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FilmeGeneroGroupByArgs['orderBy'] }
        : { orderBy?: FilmeGeneroGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FilmeGeneroGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFilmeGeneroGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FilmeGenero model
   */
  readonly fields: FilmeGeneroFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FilmeGenero.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FilmeGeneroClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    filme<T extends FilmeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FilmeDefaultArgs<ExtArgs>>): Prisma__FilmeClient<$Result.GetResult<Prisma.$FilmePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    genero<T extends GeneroDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GeneroDefaultArgs<ExtArgs>>): Prisma__GeneroClient<$Result.GetResult<Prisma.$GeneroPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FilmeGenero model
   */
  interface FilmeGeneroFieldRefs {
    readonly id: FieldRef<"FilmeGenero", 'Int'>
    readonly filmeId: FieldRef<"FilmeGenero", 'Int'>
    readonly generoId: FieldRef<"FilmeGenero", 'Int'>
    readonly ativo: FieldRef<"FilmeGenero", 'Boolean'>
    readonly criadoEm: FieldRef<"FilmeGenero", 'DateTime'>
    readonly atualizadoEm: FieldRef<"FilmeGenero", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FilmeGenero findUnique
   */
  export type FilmeGeneroFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilmeGenero
     */
    select?: FilmeGeneroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilmeGenero
     */
    omit?: FilmeGeneroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeGeneroInclude<ExtArgs> | null
    /**
     * Filter, which FilmeGenero to fetch.
     */
    where: FilmeGeneroWhereUniqueInput
  }

  /**
   * FilmeGenero findUniqueOrThrow
   */
  export type FilmeGeneroFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilmeGenero
     */
    select?: FilmeGeneroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilmeGenero
     */
    omit?: FilmeGeneroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeGeneroInclude<ExtArgs> | null
    /**
     * Filter, which FilmeGenero to fetch.
     */
    where: FilmeGeneroWhereUniqueInput
  }

  /**
   * FilmeGenero findFirst
   */
  export type FilmeGeneroFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilmeGenero
     */
    select?: FilmeGeneroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilmeGenero
     */
    omit?: FilmeGeneroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeGeneroInclude<ExtArgs> | null
    /**
     * Filter, which FilmeGenero to fetch.
     */
    where?: FilmeGeneroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilmeGeneros to fetch.
     */
    orderBy?: FilmeGeneroOrderByWithRelationInput | FilmeGeneroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FilmeGeneros.
     */
    cursor?: FilmeGeneroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilmeGeneros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilmeGeneros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FilmeGeneros.
     */
    distinct?: FilmeGeneroScalarFieldEnum | FilmeGeneroScalarFieldEnum[]
  }

  /**
   * FilmeGenero findFirstOrThrow
   */
  export type FilmeGeneroFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilmeGenero
     */
    select?: FilmeGeneroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilmeGenero
     */
    omit?: FilmeGeneroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeGeneroInclude<ExtArgs> | null
    /**
     * Filter, which FilmeGenero to fetch.
     */
    where?: FilmeGeneroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilmeGeneros to fetch.
     */
    orderBy?: FilmeGeneroOrderByWithRelationInput | FilmeGeneroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FilmeGeneros.
     */
    cursor?: FilmeGeneroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilmeGeneros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilmeGeneros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FilmeGeneros.
     */
    distinct?: FilmeGeneroScalarFieldEnum | FilmeGeneroScalarFieldEnum[]
  }

  /**
   * FilmeGenero findMany
   */
  export type FilmeGeneroFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilmeGenero
     */
    select?: FilmeGeneroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilmeGenero
     */
    omit?: FilmeGeneroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeGeneroInclude<ExtArgs> | null
    /**
     * Filter, which FilmeGeneros to fetch.
     */
    where?: FilmeGeneroWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilmeGeneros to fetch.
     */
    orderBy?: FilmeGeneroOrderByWithRelationInput | FilmeGeneroOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FilmeGeneros.
     */
    cursor?: FilmeGeneroWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilmeGeneros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilmeGeneros.
     */
    skip?: number
    distinct?: FilmeGeneroScalarFieldEnum | FilmeGeneroScalarFieldEnum[]
  }

  /**
   * FilmeGenero create
   */
  export type FilmeGeneroCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilmeGenero
     */
    select?: FilmeGeneroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilmeGenero
     */
    omit?: FilmeGeneroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeGeneroInclude<ExtArgs> | null
    /**
     * The data needed to create a FilmeGenero.
     */
    data: XOR<FilmeGeneroCreateInput, FilmeGeneroUncheckedCreateInput>
  }

  /**
   * FilmeGenero createMany
   */
  export type FilmeGeneroCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FilmeGeneros.
     */
    data: FilmeGeneroCreateManyInput | FilmeGeneroCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FilmeGenero createManyAndReturn
   */
  export type FilmeGeneroCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilmeGenero
     */
    select?: FilmeGeneroSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FilmeGenero
     */
    omit?: FilmeGeneroOmit<ExtArgs> | null
    /**
     * The data used to create many FilmeGeneros.
     */
    data: FilmeGeneroCreateManyInput | FilmeGeneroCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeGeneroIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FilmeGenero update
   */
  export type FilmeGeneroUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilmeGenero
     */
    select?: FilmeGeneroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilmeGenero
     */
    omit?: FilmeGeneroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeGeneroInclude<ExtArgs> | null
    /**
     * The data needed to update a FilmeGenero.
     */
    data: XOR<FilmeGeneroUpdateInput, FilmeGeneroUncheckedUpdateInput>
    /**
     * Choose, which FilmeGenero to update.
     */
    where: FilmeGeneroWhereUniqueInput
  }

  /**
   * FilmeGenero updateMany
   */
  export type FilmeGeneroUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FilmeGeneros.
     */
    data: XOR<FilmeGeneroUpdateManyMutationInput, FilmeGeneroUncheckedUpdateManyInput>
    /**
     * Filter which FilmeGeneros to update
     */
    where?: FilmeGeneroWhereInput
    /**
     * Limit how many FilmeGeneros to update.
     */
    limit?: number
  }

  /**
   * FilmeGenero updateManyAndReturn
   */
  export type FilmeGeneroUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilmeGenero
     */
    select?: FilmeGeneroSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FilmeGenero
     */
    omit?: FilmeGeneroOmit<ExtArgs> | null
    /**
     * The data used to update FilmeGeneros.
     */
    data: XOR<FilmeGeneroUpdateManyMutationInput, FilmeGeneroUncheckedUpdateManyInput>
    /**
     * Filter which FilmeGeneros to update
     */
    where?: FilmeGeneroWhereInput
    /**
     * Limit how many FilmeGeneros to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeGeneroIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FilmeGenero upsert
   */
  export type FilmeGeneroUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilmeGenero
     */
    select?: FilmeGeneroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilmeGenero
     */
    omit?: FilmeGeneroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeGeneroInclude<ExtArgs> | null
    /**
     * The filter to search for the FilmeGenero to update in case it exists.
     */
    where: FilmeGeneroWhereUniqueInput
    /**
     * In case the FilmeGenero found by the `where` argument doesn't exist, create a new FilmeGenero with this data.
     */
    create: XOR<FilmeGeneroCreateInput, FilmeGeneroUncheckedCreateInput>
    /**
     * In case the FilmeGenero was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FilmeGeneroUpdateInput, FilmeGeneroUncheckedUpdateInput>
  }

  /**
   * FilmeGenero delete
   */
  export type FilmeGeneroDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilmeGenero
     */
    select?: FilmeGeneroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilmeGenero
     */
    omit?: FilmeGeneroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeGeneroInclude<ExtArgs> | null
    /**
     * Filter which FilmeGenero to delete.
     */
    where: FilmeGeneroWhereUniqueInput
  }

  /**
   * FilmeGenero deleteMany
   */
  export type FilmeGeneroDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FilmeGeneros to delete
     */
    where?: FilmeGeneroWhereInput
    /**
     * Limit how many FilmeGeneros to delete.
     */
    limit?: number
  }

  /**
   * FilmeGenero without action
   */
  export type FilmeGeneroDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilmeGenero
     */
    select?: FilmeGeneroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilmeGenero
     */
    omit?: FilmeGeneroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeGeneroInclude<ExtArgs> | null
  }


  /**
   * Model Filme
   */

  export type AggregateFilme = {
    _count: FilmeCountAggregateOutputType | null
    _avg: FilmeAvgAggregateOutputType | null
    _sum: FilmeSumAggregateOutputType | null
    _min: FilmeMinAggregateOutputType | null
    _max: FilmeMaxAggregateOutputType | null
  }

  export type FilmeAvgAggregateOutputType = {
    id: number | null
    classificacaoIndicativaId: number | null
    duracaoEmMinutos: number | null
  }

  export type FilmeSumAggregateOutputType = {
    id: number | null
    classificacaoIndicativaId: number | null
    duracaoEmMinutos: number | null
  }

  export type FilmeMinAggregateOutputType = {
    id: number | null
    classificacaoIndicativaId: number | null
    titulo: string | null
    descricao: string | null
    duracaoEmMinutos: number | null
    trailerUrl: string | null
    capaUrl: string | null
    dataLancamento: Date | null
    dataInicioCartaz: Date | null
    dataFimCartaz: Date | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type FilmeMaxAggregateOutputType = {
    id: number | null
    classificacaoIndicativaId: number | null
    titulo: string | null
    descricao: string | null
    duracaoEmMinutos: number | null
    trailerUrl: string | null
    capaUrl: string | null
    dataLancamento: Date | null
    dataInicioCartaz: Date | null
    dataFimCartaz: Date | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type FilmeCountAggregateOutputType = {
    id: number
    classificacaoIndicativaId: number
    titulo: number
    descricao: number
    duracaoEmMinutos: number
    trailerUrl: number
    capaUrl: number
    dataLancamento: number
    dataInicioCartaz: number
    dataFimCartaz: number
    ativo: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type FilmeAvgAggregateInputType = {
    id?: true
    classificacaoIndicativaId?: true
    duracaoEmMinutos?: true
  }

  export type FilmeSumAggregateInputType = {
    id?: true
    classificacaoIndicativaId?: true
    duracaoEmMinutos?: true
  }

  export type FilmeMinAggregateInputType = {
    id?: true
    classificacaoIndicativaId?: true
    titulo?: true
    descricao?: true
    duracaoEmMinutos?: true
    trailerUrl?: true
    capaUrl?: true
    dataLancamento?: true
    dataInicioCartaz?: true
    dataFimCartaz?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type FilmeMaxAggregateInputType = {
    id?: true
    classificacaoIndicativaId?: true
    titulo?: true
    descricao?: true
    duracaoEmMinutos?: true
    trailerUrl?: true
    capaUrl?: true
    dataLancamento?: true
    dataInicioCartaz?: true
    dataFimCartaz?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type FilmeCountAggregateInputType = {
    id?: true
    classificacaoIndicativaId?: true
    titulo?: true
    descricao?: true
    duracaoEmMinutos?: true
    trailerUrl?: true
    capaUrl?: true
    dataLancamento?: true
    dataInicioCartaz?: true
    dataFimCartaz?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type FilmeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Filme to aggregate.
     */
    where?: FilmeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Filmes to fetch.
     */
    orderBy?: FilmeOrderByWithRelationInput | FilmeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FilmeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Filmes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Filmes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Filmes
    **/
    _count?: true | FilmeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FilmeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FilmeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FilmeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FilmeMaxAggregateInputType
  }

  export type GetFilmeAggregateType<T extends FilmeAggregateArgs> = {
        [P in keyof T & keyof AggregateFilme]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFilme[P]>
      : GetScalarType<T[P], AggregateFilme[P]>
  }




  export type FilmeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilmeWhereInput
    orderBy?: FilmeOrderByWithAggregationInput | FilmeOrderByWithAggregationInput[]
    by: FilmeScalarFieldEnum[] | FilmeScalarFieldEnum
    having?: FilmeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FilmeCountAggregateInputType | true
    _avg?: FilmeAvgAggregateInputType
    _sum?: FilmeSumAggregateInputType
    _min?: FilmeMinAggregateInputType
    _max?: FilmeMaxAggregateInputType
  }

  export type FilmeGroupByOutputType = {
    id: number
    classificacaoIndicativaId: number
    titulo: string
    descricao: string
    duracaoEmMinutos: number
    trailerUrl: string
    capaUrl: string
    dataLancamento: Date
    dataInicioCartaz: Date
    dataFimCartaz: Date
    ativo: boolean
    criadoEm: Date
    atualizadoEm: Date
    _count: FilmeCountAggregateOutputType | null
    _avg: FilmeAvgAggregateOutputType | null
    _sum: FilmeSumAggregateOutputType | null
    _min: FilmeMinAggregateOutputType | null
    _max: FilmeMaxAggregateOutputType | null
  }

  type GetFilmeGroupByPayload<T extends FilmeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FilmeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FilmeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FilmeGroupByOutputType[P]>
            : GetScalarType<T[P], FilmeGroupByOutputType[P]>
        }
      >
    >


  export type FilmeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classificacaoIndicativaId?: boolean
    titulo?: boolean
    descricao?: boolean
    duracaoEmMinutos?: boolean
    trailerUrl?: boolean
    capaUrl?: boolean
    dataLancamento?: boolean
    dataInicioCartaz?: boolean
    dataFimCartaz?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    classificacaoIndicativa?: boolean | ClassificacaoIndicativaDefaultArgs<ExtArgs>
    generos?: boolean | Filme$generosArgs<ExtArgs>
    integrantes?: boolean | Filme$integrantesArgs<ExtArgs>
    sessoes?: boolean | Filme$sessoesArgs<ExtArgs>
    _count?: boolean | FilmeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["filme"]>

  export type FilmeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classificacaoIndicativaId?: boolean
    titulo?: boolean
    descricao?: boolean
    duracaoEmMinutos?: boolean
    trailerUrl?: boolean
    capaUrl?: boolean
    dataLancamento?: boolean
    dataInicioCartaz?: boolean
    dataFimCartaz?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    classificacaoIndicativa?: boolean | ClassificacaoIndicativaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["filme"]>

  export type FilmeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    classificacaoIndicativaId?: boolean
    titulo?: boolean
    descricao?: boolean
    duracaoEmMinutos?: boolean
    trailerUrl?: boolean
    capaUrl?: boolean
    dataLancamento?: boolean
    dataInicioCartaz?: boolean
    dataFimCartaz?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    classificacaoIndicativa?: boolean | ClassificacaoIndicativaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["filme"]>

  export type FilmeSelectScalar = {
    id?: boolean
    classificacaoIndicativaId?: boolean
    titulo?: boolean
    descricao?: boolean
    duracaoEmMinutos?: boolean
    trailerUrl?: boolean
    capaUrl?: boolean
    dataLancamento?: boolean
    dataInicioCartaz?: boolean
    dataFimCartaz?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type FilmeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "classificacaoIndicativaId" | "titulo" | "descricao" | "duracaoEmMinutos" | "trailerUrl" | "capaUrl" | "dataLancamento" | "dataInicioCartaz" | "dataFimCartaz" | "ativo" | "criadoEm" | "atualizadoEm", ExtArgs["result"]["filme"]>
  export type FilmeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classificacaoIndicativa?: boolean | ClassificacaoIndicativaDefaultArgs<ExtArgs>
    generos?: boolean | Filme$generosArgs<ExtArgs>
    integrantes?: boolean | Filme$integrantesArgs<ExtArgs>
    sessoes?: boolean | Filme$sessoesArgs<ExtArgs>
    _count?: boolean | FilmeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FilmeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classificacaoIndicativa?: boolean | ClassificacaoIndicativaDefaultArgs<ExtArgs>
  }
  export type FilmeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classificacaoIndicativa?: boolean | ClassificacaoIndicativaDefaultArgs<ExtArgs>
  }

  export type $FilmePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Filme"
    objects: {
      classificacaoIndicativa: Prisma.$ClassificacaoIndicativaPayload<ExtArgs>
      generos: Prisma.$FilmeGeneroPayload<ExtArgs>[]
      integrantes: Prisma.$FilmeIntegrantePayload<ExtArgs>[]
      sessoes: Prisma.$SessaoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      classificacaoIndicativaId: number
      titulo: string
      descricao: string
      duracaoEmMinutos: number
      trailerUrl: string
      capaUrl: string
      dataLancamento: Date
      dataInicioCartaz: Date
      dataFimCartaz: Date
      ativo: boolean
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["filme"]>
    composites: {}
  }

  type FilmeGetPayload<S extends boolean | null | undefined | FilmeDefaultArgs> = $Result.GetResult<Prisma.$FilmePayload, S>

  type FilmeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FilmeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FilmeCountAggregateInputType | true
    }

  export interface FilmeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Filme'], meta: { name: 'Filme' } }
    /**
     * Find zero or one Filme that matches the filter.
     * @param {FilmeFindUniqueArgs} args - Arguments to find a Filme
     * @example
     * // Get one Filme
     * const filme = await prisma.filme.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FilmeFindUniqueArgs>(args: SelectSubset<T, FilmeFindUniqueArgs<ExtArgs>>): Prisma__FilmeClient<$Result.GetResult<Prisma.$FilmePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Filme that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FilmeFindUniqueOrThrowArgs} args - Arguments to find a Filme
     * @example
     * // Get one Filme
     * const filme = await prisma.filme.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FilmeFindUniqueOrThrowArgs>(args: SelectSubset<T, FilmeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FilmeClient<$Result.GetResult<Prisma.$FilmePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Filme that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilmeFindFirstArgs} args - Arguments to find a Filme
     * @example
     * // Get one Filme
     * const filme = await prisma.filme.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FilmeFindFirstArgs>(args?: SelectSubset<T, FilmeFindFirstArgs<ExtArgs>>): Prisma__FilmeClient<$Result.GetResult<Prisma.$FilmePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Filme that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilmeFindFirstOrThrowArgs} args - Arguments to find a Filme
     * @example
     * // Get one Filme
     * const filme = await prisma.filme.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FilmeFindFirstOrThrowArgs>(args?: SelectSubset<T, FilmeFindFirstOrThrowArgs<ExtArgs>>): Prisma__FilmeClient<$Result.GetResult<Prisma.$FilmePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Filmes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilmeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Filmes
     * const filmes = await prisma.filme.findMany()
     * 
     * // Get first 10 Filmes
     * const filmes = await prisma.filme.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const filmeWithIdOnly = await prisma.filme.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FilmeFindManyArgs>(args?: SelectSubset<T, FilmeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilmePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Filme.
     * @param {FilmeCreateArgs} args - Arguments to create a Filme.
     * @example
     * // Create one Filme
     * const Filme = await prisma.filme.create({
     *   data: {
     *     // ... data to create a Filme
     *   }
     * })
     * 
     */
    create<T extends FilmeCreateArgs>(args: SelectSubset<T, FilmeCreateArgs<ExtArgs>>): Prisma__FilmeClient<$Result.GetResult<Prisma.$FilmePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Filmes.
     * @param {FilmeCreateManyArgs} args - Arguments to create many Filmes.
     * @example
     * // Create many Filmes
     * const filme = await prisma.filme.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FilmeCreateManyArgs>(args?: SelectSubset<T, FilmeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Filmes and returns the data saved in the database.
     * @param {FilmeCreateManyAndReturnArgs} args - Arguments to create many Filmes.
     * @example
     * // Create many Filmes
     * const filme = await prisma.filme.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Filmes and only return the `id`
     * const filmeWithIdOnly = await prisma.filme.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FilmeCreateManyAndReturnArgs>(args?: SelectSubset<T, FilmeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilmePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Filme.
     * @param {FilmeDeleteArgs} args - Arguments to delete one Filme.
     * @example
     * // Delete one Filme
     * const Filme = await prisma.filme.delete({
     *   where: {
     *     // ... filter to delete one Filme
     *   }
     * })
     * 
     */
    delete<T extends FilmeDeleteArgs>(args: SelectSubset<T, FilmeDeleteArgs<ExtArgs>>): Prisma__FilmeClient<$Result.GetResult<Prisma.$FilmePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Filme.
     * @param {FilmeUpdateArgs} args - Arguments to update one Filme.
     * @example
     * // Update one Filme
     * const filme = await prisma.filme.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FilmeUpdateArgs>(args: SelectSubset<T, FilmeUpdateArgs<ExtArgs>>): Prisma__FilmeClient<$Result.GetResult<Prisma.$FilmePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Filmes.
     * @param {FilmeDeleteManyArgs} args - Arguments to filter Filmes to delete.
     * @example
     * // Delete a few Filmes
     * const { count } = await prisma.filme.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FilmeDeleteManyArgs>(args?: SelectSubset<T, FilmeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Filmes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilmeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Filmes
     * const filme = await prisma.filme.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FilmeUpdateManyArgs>(args: SelectSubset<T, FilmeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Filmes and returns the data updated in the database.
     * @param {FilmeUpdateManyAndReturnArgs} args - Arguments to update many Filmes.
     * @example
     * // Update many Filmes
     * const filme = await prisma.filme.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Filmes and only return the `id`
     * const filmeWithIdOnly = await prisma.filme.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FilmeUpdateManyAndReturnArgs>(args: SelectSubset<T, FilmeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilmePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Filme.
     * @param {FilmeUpsertArgs} args - Arguments to update or create a Filme.
     * @example
     * // Update or create a Filme
     * const filme = await prisma.filme.upsert({
     *   create: {
     *     // ... data to create a Filme
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Filme we want to update
     *   }
     * })
     */
    upsert<T extends FilmeUpsertArgs>(args: SelectSubset<T, FilmeUpsertArgs<ExtArgs>>): Prisma__FilmeClient<$Result.GetResult<Prisma.$FilmePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Filmes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilmeCountArgs} args - Arguments to filter Filmes to count.
     * @example
     * // Count the number of Filmes
     * const count = await prisma.filme.count({
     *   where: {
     *     // ... the filter for the Filmes we want to count
     *   }
     * })
    **/
    count<T extends FilmeCountArgs>(
      args?: Subset<T, FilmeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FilmeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Filme.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilmeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FilmeAggregateArgs>(args: Subset<T, FilmeAggregateArgs>): Prisma.PrismaPromise<GetFilmeAggregateType<T>>

    /**
     * Group by Filme.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilmeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FilmeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FilmeGroupByArgs['orderBy'] }
        : { orderBy?: FilmeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FilmeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFilmeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Filme model
   */
  readonly fields: FilmeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Filme.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FilmeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classificacaoIndicativa<T extends ClassificacaoIndicativaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClassificacaoIndicativaDefaultArgs<ExtArgs>>): Prisma__ClassificacaoIndicativaClient<$Result.GetResult<Prisma.$ClassificacaoIndicativaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    generos<T extends Filme$generosArgs<ExtArgs> = {}>(args?: Subset<T, Filme$generosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilmeGeneroPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    integrantes<T extends Filme$integrantesArgs<ExtArgs> = {}>(args?: Subset<T, Filme$integrantesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilmeIntegrantePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessoes<T extends Filme$sessoesArgs<ExtArgs> = {}>(args?: Subset<T, Filme$sessoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Filme model
   */
  interface FilmeFieldRefs {
    readonly id: FieldRef<"Filme", 'Int'>
    readonly classificacaoIndicativaId: FieldRef<"Filme", 'Int'>
    readonly titulo: FieldRef<"Filme", 'String'>
    readonly descricao: FieldRef<"Filme", 'String'>
    readonly duracaoEmMinutos: FieldRef<"Filme", 'Int'>
    readonly trailerUrl: FieldRef<"Filme", 'String'>
    readonly capaUrl: FieldRef<"Filme", 'String'>
    readonly dataLancamento: FieldRef<"Filme", 'DateTime'>
    readonly dataInicioCartaz: FieldRef<"Filme", 'DateTime'>
    readonly dataFimCartaz: FieldRef<"Filme", 'DateTime'>
    readonly ativo: FieldRef<"Filme", 'Boolean'>
    readonly criadoEm: FieldRef<"Filme", 'DateTime'>
    readonly atualizadoEm: FieldRef<"Filme", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Filme findUnique
   */
  export type FilmeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filme
     */
    select?: FilmeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Filme
     */
    omit?: FilmeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeInclude<ExtArgs> | null
    /**
     * Filter, which Filme to fetch.
     */
    where: FilmeWhereUniqueInput
  }

  /**
   * Filme findUniqueOrThrow
   */
  export type FilmeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filme
     */
    select?: FilmeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Filme
     */
    omit?: FilmeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeInclude<ExtArgs> | null
    /**
     * Filter, which Filme to fetch.
     */
    where: FilmeWhereUniqueInput
  }

  /**
   * Filme findFirst
   */
  export type FilmeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filme
     */
    select?: FilmeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Filme
     */
    omit?: FilmeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeInclude<ExtArgs> | null
    /**
     * Filter, which Filme to fetch.
     */
    where?: FilmeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Filmes to fetch.
     */
    orderBy?: FilmeOrderByWithRelationInput | FilmeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Filmes.
     */
    cursor?: FilmeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Filmes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Filmes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Filmes.
     */
    distinct?: FilmeScalarFieldEnum | FilmeScalarFieldEnum[]
  }

  /**
   * Filme findFirstOrThrow
   */
  export type FilmeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filme
     */
    select?: FilmeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Filme
     */
    omit?: FilmeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeInclude<ExtArgs> | null
    /**
     * Filter, which Filme to fetch.
     */
    where?: FilmeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Filmes to fetch.
     */
    orderBy?: FilmeOrderByWithRelationInput | FilmeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Filmes.
     */
    cursor?: FilmeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Filmes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Filmes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Filmes.
     */
    distinct?: FilmeScalarFieldEnum | FilmeScalarFieldEnum[]
  }

  /**
   * Filme findMany
   */
  export type FilmeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filme
     */
    select?: FilmeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Filme
     */
    omit?: FilmeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeInclude<ExtArgs> | null
    /**
     * Filter, which Filmes to fetch.
     */
    where?: FilmeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Filmes to fetch.
     */
    orderBy?: FilmeOrderByWithRelationInput | FilmeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Filmes.
     */
    cursor?: FilmeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Filmes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Filmes.
     */
    skip?: number
    distinct?: FilmeScalarFieldEnum | FilmeScalarFieldEnum[]
  }

  /**
   * Filme create
   */
  export type FilmeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filme
     */
    select?: FilmeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Filme
     */
    omit?: FilmeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeInclude<ExtArgs> | null
    /**
     * The data needed to create a Filme.
     */
    data: XOR<FilmeCreateInput, FilmeUncheckedCreateInput>
  }

  /**
   * Filme createMany
   */
  export type FilmeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Filmes.
     */
    data: FilmeCreateManyInput | FilmeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Filme createManyAndReturn
   */
  export type FilmeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filme
     */
    select?: FilmeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Filme
     */
    omit?: FilmeOmit<ExtArgs> | null
    /**
     * The data used to create many Filmes.
     */
    data: FilmeCreateManyInput | FilmeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Filme update
   */
  export type FilmeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filme
     */
    select?: FilmeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Filme
     */
    omit?: FilmeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeInclude<ExtArgs> | null
    /**
     * The data needed to update a Filme.
     */
    data: XOR<FilmeUpdateInput, FilmeUncheckedUpdateInput>
    /**
     * Choose, which Filme to update.
     */
    where: FilmeWhereUniqueInput
  }

  /**
   * Filme updateMany
   */
  export type FilmeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Filmes.
     */
    data: XOR<FilmeUpdateManyMutationInput, FilmeUncheckedUpdateManyInput>
    /**
     * Filter which Filmes to update
     */
    where?: FilmeWhereInput
    /**
     * Limit how many Filmes to update.
     */
    limit?: number
  }

  /**
   * Filme updateManyAndReturn
   */
  export type FilmeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filme
     */
    select?: FilmeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Filme
     */
    omit?: FilmeOmit<ExtArgs> | null
    /**
     * The data used to update Filmes.
     */
    data: XOR<FilmeUpdateManyMutationInput, FilmeUncheckedUpdateManyInput>
    /**
     * Filter which Filmes to update
     */
    where?: FilmeWhereInput
    /**
     * Limit how many Filmes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Filme upsert
   */
  export type FilmeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filme
     */
    select?: FilmeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Filme
     */
    omit?: FilmeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeInclude<ExtArgs> | null
    /**
     * The filter to search for the Filme to update in case it exists.
     */
    where: FilmeWhereUniqueInput
    /**
     * In case the Filme found by the `where` argument doesn't exist, create a new Filme with this data.
     */
    create: XOR<FilmeCreateInput, FilmeUncheckedCreateInput>
    /**
     * In case the Filme was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FilmeUpdateInput, FilmeUncheckedUpdateInput>
  }

  /**
   * Filme delete
   */
  export type FilmeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filme
     */
    select?: FilmeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Filme
     */
    omit?: FilmeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeInclude<ExtArgs> | null
    /**
     * Filter which Filme to delete.
     */
    where: FilmeWhereUniqueInput
  }

  /**
   * Filme deleteMany
   */
  export type FilmeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Filmes to delete
     */
    where?: FilmeWhereInput
    /**
     * Limit how many Filmes to delete.
     */
    limit?: number
  }

  /**
   * Filme.generos
   */
  export type Filme$generosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilmeGenero
     */
    select?: FilmeGeneroSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilmeGenero
     */
    omit?: FilmeGeneroOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeGeneroInclude<ExtArgs> | null
    where?: FilmeGeneroWhereInput
    orderBy?: FilmeGeneroOrderByWithRelationInput | FilmeGeneroOrderByWithRelationInput[]
    cursor?: FilmeGeneroWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FilmeGeneroScalarFieldEnum | FilmeGeneroScalarFieldEnum[]
  }

  /**
   * Filme.integrantes
   */
  export type Filme$integrantesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilmeIntegrante
     */
    select?: FilmeIntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilmeIntegrante
     */
    omit?: FilmeIntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeIntegranteInclude<ExtArgs> | null
    where?: FilmeIntegranteWhereInput
    orderBy?: FilmeIntegranteOrderByWithRelationInput | FilmeIntegranteOrderByWithRelationInput[]
    cursor?: FilmeIntegranteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FilmeIntegranteScalarFieldEnum | FilmeIntegranteScalarFieldEnum[]
  }

  /**
   * Filme.sessoes
   */
  export type Filme$sessoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessao
     */
    select?: SessaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sessao
     */
    omit?: SessaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoInclude<ExtArgs> | null
    where?: SessaoWhereInput
    orderBy?: SessaoOrderByWithRelationInput | SessaoOrderByWithRelationInput[]
    cursor?: SessaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessaoScalarFieldEnum | SessaoScalarFieldEnum[]
  }

  /**
   * Filme without action
   */
  export type FilmeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filme
     */
    select?: FilmeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Filme
     */
    omit?: FilmeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeInclude<ExtArgs> | null
  }


  /**
   * Model FilmeIntegrante
   */

  export type AggregateFilmeIntegrante = {
    _count: FilmeIntegranteCountAggregateOutputType | null
    _avg: FilmeIntegranteAvgAggregateOutputType | null
    _sum: FilmeIntegranteSumAggregateOutputType | null
    _min: FilmeIntegranteMinAggregateOutputType | null
    _max: FilmeIntegranteMaxAggregateOutputType | null
  }

  export type FilmeIntegranteAvgAggregateOutputType = {
    id: number | null
    filmeId: number | null
    integranteId: number | null
  }

  export type FilmeIntegranteSumAggregateOutputType = {
    id: number | null
    filmeId: number | null
    integranteId: number | null
  }

  export type FilmeIntegranteMinAggregateOutputType = {
    id: number | null
    filmeId: number | null
    integranteId: number | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type FilmeIntegranteMaxAggregateOutputType = {
    id: number | null
    filmeId: number | null
    integranteId: number | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type FilmeIntegranteCountAggregateOutputType = {
    id: number
    filmeId: number
    integranteId: number
    ativo: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type FilmeIntegranteAvgAggregateInputType = {
    id?: true
    filmeId?: true
    integranteId?: true
  }

  export type FilmeIntegranteSumAggregateInputType = {
    id?: true
    filmeId?: true
    integranteId?: true
  }

  export type FilmeIntegranteMinAggregateInputType = {
    id?: true
    filmeId?: true
    integranteId?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type FilmeIntegranteMaxAggregateInputType = {
    id?: true
    filmeId?: true
    integranteId?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type FilmeIntegranteCountAggregateInputType = {
    id?: true
    filmeId?: true
    integranteId?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type FilmeIntegranteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FilmeIntegrante to aggregate.
     */
    where?: FilmeIntegranteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilmeIntegrantes to fetch.
     */
    orderBy?: FilmeIntegranteOrderByWithRelationInput | FilmeIntegranteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FilmeIntegranteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilmeIntegrantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilmeIntegrantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FilmeIntegrantes
    **/
    _count?: true | FilmeIntegranteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FilmeIntegranteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FilmeIntegranteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FilmeIntegranteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FilmeIntegranteMaxAggregateInputType
  }

  export type GetFilmeIntegranteAggregateType<T extends FilmeIntegranteAggregateArgs> = {
        [P in keyof T & keyof AggregateFilmeIntegrante]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFilmeIntegrante[P]>
      : GetScalarType<T[P], AggregateFilmeIntegrante[P]>
  }




  export type FilmeIntegranteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FilmeIntegranteWhereInput
    orderBy?: FilmeIntegranteOrderByWithAggregationInput | FilmeIntegranteOrderByWithAggregationInput[]
    by: FilmeIntegranteScalarFieldEnum[] | FilmeIntegranteScalarFieldEnum
    having?: FilmeIntegranteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FilmeIntegranteCountAggregateInputType | true
    _avg?: FilmeIntegranteAvgAggregateInputType
    _sum?: FilmeIntegranteSumAggregateInputType
    _min?: FilmeIntegranteMinAggregateInputType
    _max?: FilmeIntegranteMaxAggregateInputType
  }

  export type FilmeIntegranteGroupByOutputType = {
    id: number
    filmeId: number
    integranteId: number
    ativo: boolean
    criadoEm: Date
    atualizadoEm: Date
    _count: FilmeIntegranteCountAggregateOutputType | null
    _avg: FilmeIntegranteAvgAggregateOutputType | null
    _sum: FilmeIntegranteSumAggregateOutputType | null
    _min: FilmeIntegranteMinAggregateOutputType | null
    _max: FilmeIntegranteMaxAggregateOutputType | null
  }

  type GetFilmeIntegranteGroupByPayload<T extends FilmeIntegranteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FilmeIntegranteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FilmeIntegranteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FilmeIntegranteGroupByOutputType[P]>
            : GetScalarType<T[P], FilmeIntegranteGroupByOutputType[P]>
        }
      >
    >


  export type FilmeIntegranteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filmeId?: boolean
    integranteId?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    filme?: boolean | FilmeDefaultArgs<ExtArgs>
    integrante?: boolean | IntegranteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["filmeIntegrante"]>

  export type FilmeIntegranteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filmeId?: boolean
    integranteId?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    filme?: boolean | FilmeDefaultArgs<ExtArgs>
    integrante?: boolean | IntegranteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["filmeIntegrante"]>

  export type FilmeIntegranteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filmeId?: boolean
    integranteId?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    filme?: boolean | FilmeDefaultArgs<ExtArgs>
    integrante?: boolean | IntegranteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["filmeIntegrante"]>

  export type FilmeIntegranteSelectScalar = {
    id?: boolean
    filmeId?: boolean
    integranteId?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type FilmeIntegranteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "filmeId" | "integranteId" | "ativo" | "criadoEm" | "atualizadoEm", ExtArgs["result"]["filmeIntegrante"]>
  export type FilmeIntegranteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filme?: boolean | FilmeDefaultArgs<ExtArgs>
    integrante?: boolean | IntegranteDefaultArgs<ExtArgs>
  }
  export type FilmeIntegranteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filme?: boolean | FilmeDefaultArgs<ExtArgs>
    integrante?: boolean | IntegranteDefaultArgs<ExtArgs>
  }
  export type FilmeIntegranteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filme?: boolean | FilmeDefaultArgs<ExtArgs>
    integrante?: boolean | IntegranteDefaultArgs<ExtArgs>
  }

  export type $FilmeIntegrantePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FilmeIntegrante"
    objects: {
      filme: Prisma.$FilmePayload<ExtArgs>
      integrante: Prisma.$IntegrantePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      filmeId: number
      integranteId: number
      ativo: boolean
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["filmeIntegrante"]>
    composites: {}
  }

  type FilmeIntegranteGetPayload<S extends boolean | null | undefined | FilmeIntegranteDefaultArgs> = $Result.GetResult<Prisma.$FilmeIntegrantePayload, S>

  type FilmeIntegranteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FilmeIntegranteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FilmeIntegranteCountAggregateInputType | true
    }

  export interface FilmeIntegranteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FilmeIntegrante'], meta: { name: 'FilmeIntegrante' } }
    /**
     * Find zero or one FilmeIntegrante that matches the filter.
     * @param {FilmeIntegranteFindUniqueArgs} args - Arguments to find a FilmeIntegrante
     * @example
     * // Get one FilmeIntegrante
     * const filmeIntegrante = await prisma.filmeIntegrante.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FilmeIntegranteFindUniqueArgs>(args: SelectSubset<T, FilmeIntegranteFindUniqueArgs<ExtArgs>>): Prisma__FilmeIntegranteClient<$Result.GetResult<Prisma.$FilmeIntegrantePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FilmeIntegrante that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FilmeIntegranteFindUniqueOrThrowArgs} args - Arguments to find a FilmeIntegrante
     * @example
     * // Get one FilmeIntegrante
     * const filmeIntegrante = await prisma.filmeIntegrante.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FilmeIntegranteFindUniqueOrThrowArgs>(args: SelectSubset<T, FilmeIntegranteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FilmeIntegranteClient<$Result.GetResult<Prisma.$FilmeIntegrantePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FilmeIntegrante that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilmeIntegranteFindFirstArgs} args - Arguments to find a FilmeIntegrante
     * @example
     * // Get one FilmeIntegrante
     * const filmeIntegrante = await prisma.filmeIntegrante.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FilmeIntegranteFindFirstArgs>(args?: SelectSubset<T, FilmeIntegranteFindFirstArgs<ExtArgs>>): Prisma__FilmeIntegranteClient<$Result.GetResult<Prisma.$FilmeIntegrantePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FilmeIntegrante that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilmeIntegranteFindFirstOrThrowArgs} args - Arguments to find a FilmeIntegrante
     * @example
     * // Get one FilmeIntegrante
     * const filmeIntegrante = await prisma.filmeIntegrante.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FilmeIntegranteFindFirstOrThrowArgs>(args?: SelectSubset<T, FilmeIntegranteFindFirstOrThrowArgs<ExtArgs>>): Prisma__FilmeIntegranteClient<$Result.GetResult<Prisma.$FilmeIntegrantePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FilmeIntegrantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilmeIntegranteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FilmeIntegrantes
     * const filmeIntegrantes = await prisma.filmeIntegrante.findMany()
     * 
     * // Get first 10 FilmeIntegrantes
     * const filmeIntegrantes = await prisma.filmeIntegrante.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const filmeIntegranteWithIdOnly = await prisma.filmeIntegrante.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FilmeIntegranteFindManyArgs>(args?: SelectSubset<T, FilmeIntegranteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilmeIntegrantePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FilmeIntegrante.
     * @param {FilmeIntegranteCreateArgs} args - Arguments to create a FilmeIntegrante.
     * @example
     * // Create one FilmeIntegrante
     * const FilmeIntegrante = await prisma.filmeIntegrante.create({
     *   data: {
     *     // ... data to create a FilmeIntegrante
     *   }
     * })
     * 
     */
    create<T extends FilmeIntegranteCreateArgs>(args: SelectSubset<T, FilmeIntegranteCreateArgs<ExtArgs>>): Prisma__FilmeIntegranteClient<$Result.GetResult<Prisma.$FilmeIntegrantePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FilmeIntegrantes.
     * @param {FilmeIntegranteCreateManyArgs} args - Arguments to create many FilmeIntegrantes.
     * @example
     * // Create many FilmeIntegrantes
     * const filmeIntegrante = await prisma.filmeIntegrante.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FilmeIntegranteCreateManyArgs>(args?: SelectSubset<T, FilmeIntegranteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FilmeIntegrantes and returns the data saved in the database.
     * @param {FilmeIntegranteCreateManyAndReturnArgs} args - Arguments to create many FilmeIntegrantes.
     * @example
     * // Create many FilmeIntegrantes
     * const filmeIntegrante = await prisma.filmeIntegrante.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FilmeIntegrantes and only return the `id`
     * const filmeIntegranteWithIdOnly = await prisma.filmeIntegrante.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FilmeIntegranteCreateManyAndReturnArgs>(args?: SelectSubset<T, FilmeIntegranteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilmeIntegrantePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FilmeIntegrante.
     * @param {FilmeIntegranteDeleteArgs} args - Arguments to delete one FilmeIntegrante.
     * @example
     * // Delete one FilmeIntegrante
     * const FilmeIntegrante = await prisma.filmeIntegrante.delete({
     *   where: {
     *     // ... filter to delete one FilmeIntegrante
     *   }
     * })
     * 
     */
    delete<T extends FilmeIntegranteDeleteArgs>(args: SelectSubset<T, FilmeIntegranteDeleteArgs<ExtArgs>>): Prisma__FilmeIntegranteClient<$Result.GetResult<Prisma.$FilmeIntegrantePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FilmeIntegrante.
     * @param {FilmeIntegranteUpdateArgs} args - Arguments to update one FilmeIntegrante.
     * @example
     * // Update one FilmeIntegrante
     * const filmeIntegrante = await prisma.filmeIntegrante.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FilmeIntegranteUpdateArgs>(args: SelectSubset<T, FilmeIntegranteUpdateArgs<ExtArgs>>): Prisma__FilmeIntegranteClient<$Result.GetResult<Prisma.$FilmeIntegrantePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FilmeIntegrantes.
     * @param {FilmeIntegranteDeleteManyArgs} args - Arguments to filter FilmeIntegrantes to delete.
     * @example
     * // Delete a few FilmeIntegrantes
     * const { count } = await prisma.filmeIntegrante.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FilmeIntegranteDeleteManyArgs>(args?: SelectSubset<T, FilmeIntegranteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FilmeIntegrantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilmeIntegranteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FilmeIntegrantes
     * const filmeIntegrante = await prisma.filmeIntegrante.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FilmeIntegranteUpdateManyArgs>(args: SelectSubset<T, FilmeIntegranteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FilmeIntegrantes and returns the data updated in the database.
     * @param {FilmeIntegranteUpdateManyAndReturnArgs} args - Arguments to update many FilmeIntegrantes.
     * @example
     * // Update many FilmeIntegrantes
     * const filmeIntegrante = await prisma.filmeIntegrante.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FilmeIntegrantes and only return the `id`
     * const filmeIntegranteWithIdOnly = await prisma.filmeIntegrante.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FilmeIntegranteUpdateManyAndReturnArgs>(args: SelectSubset<T, FilmeIntegranteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilmeIntegrantePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FilmeIntegrante.
     * @param {FilmeIntegranteUpsertArgs} args - Arguments to update or create a FilmeIntegrante.
     * @example
     * // Update or create a FilmeIntegrante
     * const filmeIntegrante = await prisma.filmeIntegrante.upsert({
     *   create: {
     *     // ... data to create a FilmeIntegrante
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FilmeIntegrante we want to update
     *   }
     * })
     */
    upsert<T extends FilmeIntegranteUpsertArgs>(args: SelectSubset<T, FilmeIntegranteUpsertArgs<ExtArgs>>): Prisma__FilmeIntegranteClient<$Result.GetResult<Prisma.$FilmeIntegrantePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FilmeIntegrantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilmeIntegranteCountArgs} args - Arguments to filter FilmeIntegrantes to count.
     * @example
     * // Count the number of FilmeIntegrantes
     * const count = await prisma.filmeIntegrante.count({
     *   where: {
     *     // ... the filter for the FilmeIntegrantes we want to count
     *   }
     * })
    **/
    count<T extends FilmeIntegranteCountArgs>(
      args?: Subset<T, FilmeIntegranteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FilmeIntegranteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FilmeIntegrante.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilmeIntegranteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FilmeIntegranteAggregateArgs>(args: Subset<T, FilmeIntegranteAggregateArgs>): Prisma.PrismaPromise<GetFilmeIntegranteAggregateType<T>>

    /**
     * Group by FilmeIntegrante.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FilmeIntegranteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FilmeIntegranteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FilmeIntegranteGroupByArgs['orderBy'] }
        : { orderBy?: FilmeIntegranteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FilmeIntegranteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFilmeIntegranteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FilmeIntegrante model
   */
  readonly fields: FilmeIntegranteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FilmeIntegrante.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FilmeIntegranteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    filme<T extends FilmeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FilmeDefaultArgs<ExtArgs>>): Prisma__FilmeClient<$Result.GetResult<Prisma.$FilmePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    integrante<T extends IntegranteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IntegranteDefaultArgs<ExtArgs>>): Prisma__IntegranteClient<$Result.GetResult<Prisma.$IntegrantePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FilmeIntegrante model
   */
  interface FilmeIntegranteFieldRefs {
    readonly id: FieldRef<"FilmeIntegrante", 'Int'>
    readonly filmeId: FieldRef<"FilmeIntegrante", 'Int'>
    readonly integranteId: FieldRef<"FilmeIntegrante", 'Int'>
    readonly ativo: FieldRef<"FilmeIntegrante", 'Boolean'>
    readonly criadoEm: FieldRef<"FilmeIntegrante", 'DateTime'>
    readonly atualizadoEm: FieldRef<"FilmeIntegrante", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FilmeIntegrante findUnique
   */
  export type FilmeIntegranteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilmeIntegrante
     */
    select?: FilmeIntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilmeIntegrante
     */
    omit?: FilmeIntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeIntegranteInclude<ExtArgs> | null
    /**
     * Filter, which FilmeIntegrante to fetch.
     */
    where: FilmeIntegranteWhereUniqueInput
  }

  /**
   * FilmeIntegrante findUniqueOrThrow
   */
  export type FilmeIntegranteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilmeIntegrante
     */
    select?: FilmeIntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilmeIntegrante
     */
    omit?: FilmeIntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeIntegranteInclude<ExtArgs> | null
    /**
     * Filter, which FilmeIntegrante to fetch.
     */
    where: FilmeIntegranteWhereUniqueInput
  }

  /**
   * FilmeIntegrante findFirst
   */
  export type FilmeIntegranteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilmeIntegrante
     */
    select?: FilmeIntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilmeIntegrante
     */
    omit?: FilmeIntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeIntegranteInclude<ExtArgs> | null
    /**
     * Filter, which FilmeIntegrante to fetch.
     */
    where?: FilmeIntegranteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilmeIntegrantes to fetch.
     */
    orderBy?: FilmeIntegranteOrderByWithRelationInput | FilmeIntegranteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FilmeIntegrantes.
     */
    cursor?: FilmeIntegranteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilmeIntegrantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilmeIntegrantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FilmeIntegrantes.
     */
    distinct?: FilmeIntegranteScalarFieldEnum | FilmeIntegranteScalarFieldEnum[]
  }

  /**
   * FilmeIntegrante findFirstOrThrow
   */
  export type FilmeIntegranteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilmeIntegrante
     */
    select?: FilmeIntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilmeIntegrante
     */
    omit?: FilmeIntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeIntegranteInclude<ExtArgs> | null
    /**
     * Filter, which FilmeIntegrante to fetch.
     */
    where?: FilmeIntegranteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilmeIntegrantes to fetch.
     */
    orderBy?: FilmeIntegranteOrderByWithRelationInput | FilmeIntegranteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FilmeIntegrantes.
     */
    cursor?: FilmeIntegranteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilmeIntegrantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilmeIntegrantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FilmeIntegrantes.
     */
    distinct?: FilmeIntegranteScalarFieldEnum | FilmeIntegranteScalarFieldEnum[]
  }

  /**
   * FilmeIntegrante findMany
   */
  export type FilmeIntegranteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilmeIntegrante
     */
    select?: FilmeIntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilmeIntegrante
     */
    omit?: FilmeIntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeIntegranteInclude<ExtArgs> | null
    /**
     * Filter, which FilmeIntegrantes to fetch.
     */
    where?: FilmeIntegranteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FilmeIntegrantes to fetch.
     */
    orderBy?: FilmeIntegranteOrderByWithRelationInput | FilmeIntegranteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FilmeIntegrantes.
     */
    cursor?: FilmeIntegranteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FilmeIntegrantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FilmeIntegrantes.
     */
    skip?: number
    distinct?: FilmeIntegranteScalarFieldEnum | FilmeIntegranteScalarFieldEnum[]
  }

  /**
   * FilmeIntegrante create
   */
  export type FilmeIntegranteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilmeIntegrante
     */
    select?: FilmeIntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilmeIntegrante
     */
    omit?: FilmeIntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeIntegranteInclude<ExtArgs> | null
    /**
     * The data needed to create a FilmeIntegrante.
     */
    data: XOR<FilmeIntegranteCreateInput, FilmeIntegranteUncheckedCreateInput>
  }

  /**
   * FilmeIntegrante createMany
   */
  export type FilmeIntegranteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FilmeIntegrantes.
     */
    data: FilmeIntegranteCreateManyInput | FilmeIntegranteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FilmeIntegrante createManyAndReturn
   */
  export type FilmeIntegranteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilmeIntegrante
     */
    select?: FilmeIntegranteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FilmeIntegrante
     */
    omit?: FilmeIntegranteOmit<ExtArgs> | null
    /**
     * The data used to create many FilmeIntegrantes.
     */
    data: FilmeIntegranteCreateManyInput | FilmeIntegranteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeIntegranteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FilmeIntegrante update
   */
  export type FilmeIntegranteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilmeIntegrante
     */
    select?: FilmeIntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilmeIntegrante
     */
    omit?: FilmeIntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeIntegranteInclude<ExtArgs> | null
    /**
     * The data needed to update a FilmeIntegrante.
     */
    data: XOR<FilmeIntegranteUpdateInput, FilmeIntegranteUncheckedUpdateInput>
    /**
     * Choose, which FilmeIntegrante to update.
     */
    where: FilmeIntegranteWhereUniqueInput
  }

  /**
   * FilmeIntegrante updateMany
   */
  export type FilmeIntegranteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FilmeIntegrantes.
     */
    data: XOR<FilmeIntegranteUpdateManyMutationInput, FilmeIntegranteUncheckedUpdateManyInput>
    /**
     * Filter which FilmeIntegrantes to update
     */
    where?: FilmeIntegranteWhereInput
    /**
     * Limit how many FilmeIntegrantes to update.
     */
    limit?: number
  }

  /**
   * FilmeIntegrante updateManyAndReturn
   */
  export type FilmeIntegranteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilmeIntegrante
     */
    select?: FilmeIntegranteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FilmeIntegrante
     */
    omit?: FilmeIntegranteOmit<ExtArgs> | null
    /**
     * The data used to update FilmeIntegrantes.
     */
    data: XOR<FilmeIntegranteUpdateManyMutationInput, FilmeIntegranteUncheckedUpdateManyInput>
    /**
     * Filter which FilmeIntegrantes to update
     */
    where?: FilmeIntegranteWhereInput
    /**
     * Limit how many FilmeIntegrantes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeIntegranteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FilmeIntegrante upsert
   */
  export type FilmeIntegranteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilmeIntegrante
     */
    select?: FilmeIntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilmeIntegrante
     */
    omit?: FilmeIntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeIntegranteInclude<ExtArgs> | null
    /**
     * The filter to search for the FilmeIntegrante to update in case it exists.
     */
    where: FilmeIntegranteWhereUniqueInput
    /**
     * In case the FilmeIntegrante found by the `where` argument doesn't exist, create a new FilmeIntegrante with this data.
     */
    create: XOR<FilmeIntegranteCreateInput, FilmeIntegranteUncheckedCreateInput>
    /**
     * In case the FilmeIntegrante was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FilmeIntegranteUpdateInput, FilmeIntegranteUncheckedUpdateInput>
  }

  /**
   * FilmeIntegrante delete
   */
  export type FilmeIntegranteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilmeIntegrante
     */
    select?: FilmeIntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilmeIntegrante
     */
    omit?: FilmeIntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeIntegranteInclude<ExtArgs> | null
    /**
     * Filter which FilmeIntegrante to delete.
     */
    where: FilmeIntegranteWhereUniqueInput
  }

  /**
   * FilmeIntegrante deleteMany
   */
  export type FilmeIntegranteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FilmeIntegrantes to delete
     */
    where?: FilmeIntegranteWhereInput
    /**
     * Limit how many FilmeIntegrantes to delete.
     */
    limit?: number
  }

  /**
   * FilmeIntegrante without action
   */
  export type FilmeIntegranteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilmeIntegrante
     */
    select?: FilmeIntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilmeIntegrante
     */
    omit?: FilmeIntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeIntegranteInclude<ExtArgs> | null
  }


  /**
   * Model Integrante
   */

  export type AggregateIntegrante = {
    _count: IntegranteCountAggregateOutputType | null
    _avg: IntegranteAvgAggregateOutputType | null
    _sum: IntegranteSumAggregateOutputType | null
    _min: IntegranteMinAggregateOutputType | null
    _max: IntegranteMaxAggregateOutputType | null
  }

  export type IntegranteAvgAggregateOutputType = {
    id: number | null
    tipoIntegranteId: number | null
  }

  export type IntegranteSumAggregateOutputType = {
    id: number | null
    tipoIntegranteId: number | null
  }

  export type IntegranteMinAggregateOutputType = {
    id: number | null
    tipoIntegranteId: number | null
    nome: string | null
    sobrenome: string | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type IntegranteMaxAggregateOutputType = {
    id: number | null
    tipoIntegranteId: number | null
    nome: string | null
    sobrenome: string | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type IntegranteCountAggregateOutputType = {
    id: number
    tipoIntegranteId: number
    nome: number
    sobrenome: number
    ativo: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type IntegranteAvgAggregateInputType = {
    id?: true
    tipoIntegranteId?: true
  }

  export type IntegranteSumAggregateInputType = {
    id?: true
    tipoIntegranteId?: true
  }

  export type IntegranteMinAggregateInputType = {
    id?: true
    tipoIntegranteId?: true
    nome?: true
    sobrenome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type IntegranteMaxAggregateInputType = {
    id?: true
    tipoIntegranteId?: true
    nome?: true
    sobrenome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type IntegranteCountAggregateInputType = {
    id?: true
    tipoIntegranteId?: true
    nome?: true
    sobrenome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type IntegranteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Integrante to aggregate.
     */
    where?: IntegranteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrantes to fetch.
     */
    orderBy?: IntegranteOrderByWithRelationInput | IntegranteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntegranteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Integrantes
    **/
    _count?: true | IntegranteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IntegranteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IntegranteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntegranteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntegranteMaxAggregateInputType
  }

  export type GetIntegranteAggregateType<T extends IntegranteAggregateArgs> = {
        [P in keyof T & keyof AggregateIntegrante]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntegrante[P]>
      : GetScalarType<T[P], AggregateIntegrante[P]>
  }




  export type IntegranteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegranteWhereInput
    orderBy?: IntegranteOrderByWithAggregationInput | IntegranteOrderByWithAggregationInput[]
    by: IntegranteScalarFieldEnum[] | IntegranteScalarFieldEnum
    having?: IntegranteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntegranteCountAggregateInputType | true
    _avg?: IntegranteAvgAggregateInputType
    _sum?: IntegranteSumAggregateInputType
    _min?: IntegranteMinAggregateInputType
    _max?: IntegranteMaxAggregateInputType
  }

  export type IntegranteGroupByOutputType = {
    id: number
    tipoIntegranteId: number
    nome: string
    sobrenome: string
    ativo: boolean
    criadoEm: Date
    atualizadoEm: Date
    _count: IntegranteCountAggregateOutputType | null
    _avg: IntegranteAvgAggregateOutputType | null
    _sum: IntegranteSumAggregateOutputType | null
    _min: IntegranteMinAggregateOutputType | null
    _max: IntegranteMaxAggregateOutputType | null
  }

  type GetIntegranteGroupByPayload<T extends IntegranteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntegranteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntegranteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntegranteGroupByOutputType[P]>
            : GetScalarType<T[P], IntegranteGroupByOutputType[P]>
        }
      >
    >


  export type IntegranteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipoIntegranteId?: boolean
    nome?: boolean
    sobrenome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    tipoIntegrante?: boolean | TipoIntegranteDefaultArgs<ExtArgs>
    filmes?: boolean | Integrante$filmesArgs<ExtArgs>
    _count?: boolean | IntegranteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integrante"]>

  export type IntegranteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipoIntegranteId?: boolean
    nome?: boolean
    sobrenome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    tipoIntegrante?: boolean | TipoIntegranteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integrante"]>

  export type IntegranteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipoIntegranteId?: boolean
    nome?: boolean
    sobrenome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    tipoIntegrante?: boolean | TipoIntegranteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integrante"]>

  export type IntegranteSelectScalar = {
    id?: boolean
    tipoIntegranteId?: boolean
    nome?: boolean
    sobrenome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type IntegranteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tipoIntegranteId" | "nome" | "sobrenome" | "ativo" | "criadoEm" | "atualizadoEm", ExtArgs["result"]["integrante"]>
  export type IntegranteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tipoIntegrante?: boolean | TipoIntegranteDefaultArgs<ExtArgs>
    filmes?: boolean | Integrante$filmesArgs<ExtArgs>
    _count?: boolean | IntegranteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IntegranteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tipoIntegrante?: boolean | TipoIntegranteDefaultArgs<ExtArgs>
  }
  export type IntegranteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tipoIntegrante?: boolean | TipoIntegranteDefaultArgs<ExtArgs>
  }

  export type $IntegrantePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Integrante"
    objects: {
      tipoIntegrante: Prisma.$TipoIntegrantePayload<ExtArgs>
      filmes: Prisma.$FilmeIntegrantePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tipoIntegranteId: number
      nome: string
      sobrenome: string
      ativo: boolean
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["integrante"]>
    composites: {}
  }

  type IntegranteGetPayload<S extends boolean | null | undefined | IntegranteDefaultArgs> = $Result.GetResult<Prisma.$IntegrantePayload, S>

  type IntegranteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IntegranteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IntegranteCountAggregateInputType | true
    }

  export interface IntegranteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Integrante'], meta: { name: 'Integrante' } }
    /**
     * Find zero or one Integrante that matches the filter.
     * @param {IntegranteFindUniqueArgs} args - Arguments to find a Integrante
     * @example
     * // Get one Integrante
     * const integrante = await prisma.integrante.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntegranteFindUniqueArgs>(args: SelectSubset<T, IntegranteFindUniqueArgs<ExtArgs>>): Prisma__IntegranteClient<$Result.GetResult<Prisma.$IntegrantePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Integrante that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IntegranteFindUniqueOrThrowArgs} args - Arguments to find a Integrante
     * @example
     * // Get one Integrante
     * const integrante = await prisma.integrante.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntegranteFindUniqueOrThrowArgs>(args: SelectSubset<T, IntegranteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntegranteClient<$Result.GetResult<Prisma.$IntegrantePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Integrante that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegranteFindFirstArgs} args - Arguments to find a Integrante
     * @example
     * // Get one Integrante
     * const integrante = await prisma.integrante.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntegranteFindFirstArgs>(args?: SelectSubset<T, IntegranteFindFirstArgs<ExtArgs>>): Prisma__IntegranteClient<$Result.GetResult<Prisma.$IntegrantePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Integrante that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegranteFindFirstOrThrowArgs} args - Arguments to find a Integrante
     * @example
     * // Get one Integrante
     * const integrante = await prisma.integrante.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntegranteFindFirstOrThrowArgs>(args?: SelectSubset<T, IntegranteFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntegranteClient<$Result.GetResult<Prisma.$IntegrantePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Integrantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegranteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Integrantes
     * const integrantes = await prisma.integrante.findMany()
     * 
     * // Get first 10 Integrantes
     * const integrantes = await prisma.integrante.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const integranteWithIdOnly = await prisma.integrante.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntegranteFindManyArgs>(args?: SelectSubset<T, IntegranteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrantePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Integrante.
     * @param {IntegranteCreateArgs} args - Arguments to create a Integrante.
     * @example
     * // Create one Integrante
     * const Integrante = await prisma.integrante.create({
     *   data: {
     *     // ... data to create a Integrante
     *   }
     * })
     * 
     */
    create<T extends IntegranteCreateArgs>(args: SelectSubset<T, IntegranteCreateArgs<ExtArgs>>): Prisma__IntegranteClient<$Result.GetResult<Prisma.$IntegrantePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Integrantes.
     * @param {IntegranteCreateManyArgs} args - Arguments to create many Integrantes.
     * @example
     * // Create many Integrantes
     * const integrante = await prisma.integrante.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntegranteCreateManyArgs>(args?: SelectSubset<T, IntegranteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Integrantes and returns the data saved in the database.
     * @param {IntegranteCreateManyAndReturnArgs} args - Arguments to create many Integrantes.
     * @example
     * // Create many Integrantes
     * const integrante = await prisma.integrante.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Integrantes and only return the `id`
     * const integranteWithIdOnly = await prisma.integrante.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IntegranteCreateManyAndReturnArgs>(args?: SelectSubset<T, IntegranteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrantePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Integrante.
     * @param {IntegranteDeleteArgs} args - Arguments to delete one Integrante.
     * @example
     * // Delete one Integrante
     * const Integrante = await prisma.integrante.delete({
     *   where: {
     *     // ... filter to delete one Integrante
     *   }
     * })
     * 
     */
    delete<T extends IntegranteDeleteArgs>(args: SelectSubset<T, IntegranteDeleteArgs<ExtArgs>>): Prisma__IntegranteClient<$Result.GetResult<Prisma.$IntegrantePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Integrante.
     * @param {IntegranteUpdateArgs} args - Arguments to update one Integrante.
     * @example
     * // Update one Integrante
     * const integrante = await prisma.integrante.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntegranteUpdateArgs>(args: SelectSubset<T, IntegranteUpdateArgs<ExtArgs>>): Prisma__IntegranteClient<$Result.GetResult<Prisma.$IntegrantePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Integrantes.
     * @param {IntegranteDeleteManyArgs} args - Arguments to filter Integrantes to delete.
     * @example
     * // Delete a few Integrantes
     * const { count } = await prisma.integrante.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntegranteDeleteManyArgs>(args?: SelectSubset<T, IntegranteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Integrantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegranteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Integrantes
     * const integrante = await prisma.integrante.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntegranteUpdateManyArgs>(args: SelectSubset<T, IntegranteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Integrantes and returns the data updated in the database.
     * @param {IntegranteUpdateManyAndReturnArgs} args - Arguments to update many Integrantes.
     * @example
     * // Update many Integrantes
     * const integrante = await prisma.integrante.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Integrantes and only return the `id`
     * const integranteWithIdOnly = await prisma.integrante.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IntegranteUpdateManyAndReturnArgs>(args: SelectSubset<T, IntegranteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrantePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Integrante.
     * @param {IntegranteUpsertArgs} args - Arguments to update or create a Integrante.
     * @example
     * // Update or create a Integrante
     * const integrante = await prisma.integrante.upsert({
     *   create: {
     *     // ... data to create a Integrante
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Integrante we want to update
     *   }
     * })
     */
    upsert<T extends IntegranteUpsertArgs>(args: SelectSubset<T, IntegranteUpsertArgs<ExtArgs>>): Prisma__IntegranteClient<$Result.GetResult<Prisma.$IntegrantePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Integrantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegranteCountArgs} args - Arguments to filter Integrantes to count.
     * @example
     * // Count the number of Integrantes
     * const count = await prisma.integrante.count({
     *   where: {
     *     // ... the filter for the Integrantes we want to count
     *   }
     * })
    **/
    count<T extends IntegranteCountArgs>(
      args?: Subset<T, IntegranteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntegranteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Integrante.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegranteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntegranteAggregateArgs>(args: Subset<T, IntegranteAggregateArgs>): Prisma.PrismaPromise<GetIntegranteAggregateType<T>>

    /**
     * Group by Integrante.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegranteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntegranteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntegranteGroupByArgs['orderBy'] }
        : { orderBy?: IntegranteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntegranteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntegranteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Integrante model
   */
  readonly fields: IntegranteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Integrante.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntegranteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tipoIntegrante<T extends TipoIntegranteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TipoIntegranteDefaultArgs<ExtArgs>>): Prisma__TipoIntegranteClient<$Result.GetResult<Prisma.$TipoIntegrantePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    filmes<T extends Integrante$filmesArgs<ExtArgs> = {}>(args?: Subset<T, Integrante$filmesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilmeIntegrantePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Integrante model
   */
  interface IntegranteFieldRefs {
    readonly id: FieldRef<"Integrante", 'Int'>
    readonly tipoIntegranteId: FieldRef<"Integrante", 'Int'>
    readonly nome: FieldRef<"Integrante", 'String'>
    readonly sobrenome: FieldRef<"Integrante", 'String'>
    readonly ativo: FieldRef<"Integrante", 'Boolean'>
    readonly criadoEm: FieldRef<"Integrante", 'DateTime'>
    readonly atualizadoEm: FieldRef<"Integrante", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Integrante findUnique
   */
  export type IntegranteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integrante
     */
    select?: IntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integrante
     */
    omit?: IntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegranteInclude<ExtArgs> | null
    /**
     * Filter, which Integrante to fetch.
     */
    where: IntegranteWhereUniqueInput
  }

  /**
   * Integrante findUniqueOrThrow
   */
  export type IntegranteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integrante
     */
    select?: IntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integrante
     */
    omit?: IntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegranteInclude<ExtArgs> | null
    /**
     * Filter, which Integrante to fetch.
     */
    where: IntegranteWhereUniqueInput
  }

  /**
   * Integrante findFirst
   */
  export type IntegranteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integrante
     */
    select?: IntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integrante
     */
    omit?: IntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegranteInclude<ExtArgs> | null
    /**
     * Filter, which Integrante to fetch.
     */
    where?: IntegranteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrantes to fetch.
     */
    orderBy?: IntegranteOrderByWithRelationInput | IntegranteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Integrantes.
     */
    cursor?: IntegranteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Integrantes.
     */
    distinct?: IntegranteScalarFieldEnum | IntegranteScalarFieldEnum[]
  }

  /**
   * Integrante findFirstOrThrow
   */
  export type IntegranteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integrante
     */
    select?: IntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integrante
     */
    omit?: IntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegranteInclude<ExtArgs> | null
    /**
     * Filter, which Integrante to fetch.
     */
    where?: IntegranteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrantes to fetch.
     */
    orderBy?: IntegranteOrderByWithRelationInput | IntegranteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Integrantes.
     */
    cursor?: IntegranteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Integrantes.
     */
    distinct?: IntegranteScalarFieldEnum | IntegranteScalarFieldEnum[]
  }

  /**
   * Integrante findMany
   */
  export type IntegranteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integrante
     */
    select?: IntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integrante
     */
    omit?: IntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegranteInclude<ExtArgs> | null
    /**
     * Filter, which Integrantes to fetch.
     */
    where?: IntegranteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrantes to fetch.
     */
    orderBy?: IntegranteOrderByWithRelationInput | IntegranteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Integrantes.
     */
    cursor?: IntegranteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrantes.
     */
    skip?: number
    distinct?: IntegranteScalarFieldEnum | IntegranteScalarFieldEnum[]
  }

  /**
   * Integrante create
   */
  export type IntegranteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integrante
     */
    select?: IntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integrante
     */
    omit?: IntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegranteInclude<ExtArgs> | null
    /**
     * The data needed to create a Integrante.
     */
    data: XOR<IntegranteCreateInput, IntegranteUncheckedCreateInput>
  }

  /**
   * Integrante createMany
   */
  export type IntegranteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Integrantes.
     */
    data: IntegranteCreateManyInput | IntegranteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Integrante createManyAndReturn
   */
  export type IntegranteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integrante
     */
    select?: IntegranteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Integrante
     */
    omit?: IntegranteOmit<ExtArgs> | null
    /**
     * The data used to create many Integrantes.
     */
    data: IntegranteCreateManyInput | IntegranteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegranteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Integrante update
   */
  export type IntegranteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integrante
     */
    select?: IntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integrante
     */
    omit?: IntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegranteInclude<ExtArgs> | null
    /**
     * The data needed to update a Integrante.
     */
    data: XOR<IntegranteUpdateInput, IntegranteUncheckedUpdateInput>
    /**
     * Choose, which Integrante to update.
     */
    where: IntegranteWhereUniqueInput
  }

  /**
   * Integrante updateMany
   */
  export type IntegranteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Integrantes.
     */
    data: XOR<IntegranteUpdateManyMutationInput, IntegranteUncheckedUpdateManyInput>
    /**
     * Filter which Integrantes to update
     */
    where?: IntegranteWhereInput
    /**
     * Limit how many Integrantes to update.
     */
    limit?: number
  }

  /**
   * Integrante updateManyAndReturn
   */
  export type IntegranteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integrante
     */
    select?: IntegranteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Integrante
     */
    omit?: IntegranteOmit<ExtArgs> | null
    /**
     * The data used to update Integrantes.
     */
    data: XOR<IntegranteUpdateManyMutationInput, IntegranteUncheckedUpdateManyInput>
    /**
     * Filter which Integrantes to update
     */
    where?: IntegranteWhereInput
    /**
     * Limit how many Integrantes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegranteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Integrante upsert
   */
  export type IntegranteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integrante
     */
    select?: IntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integrante
     */
    omit?: IntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegranteInclude<ExtArgs> | null
    /**
     * The filter to search for the Integrante to update in case it exists.
     */
    where: IntegranteWhereUniqueInput
    /**
     * In case the Integrante found by the `where` argument doesn't exist, create a new Integrante with this data.
     */
    create: XOR<IntegranteCreateInput, IntegranteUncheckedCreateInput>
    /**
     * In case the Integrante was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntegranteUpdateInput, IntegranteUncheckedUpdateInput>
  }

  /**
   * Integrante delete
   */
  export type IntegranteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integrante
     */
    select?: IntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integrante
     */
    omit?: IntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegranteInclude<ExtArgs> | null
    /**
     * Filter which Integrante to delete.
     */
    where: IntegranteWhereUniqueInput
  }

  /**
   * Integrante deleteMany
   */
  export type IntegranteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Integrantes to delete
     */
    where?: IntegranteWhereInput
    /**
     * Limit how many Integrantes to delete.
     */
    limit?: number
  }

  /**
   * Integrante.filmes
   */
  export type Integrante$filmesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FilmeIntegrante
     */
    select?: FilmeIntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FilmeIntegrante
     */
    omit?: FilmeIntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeIntegranteInclude<ExtArgs> | null
    where?: FilmeIntegranteWhereInput
    orderBy?: FilmeIntegranteOrderByWithRelationInput | FilmeIntegranteOrderByWithRelationInput[]
    cursor?: FilmeIntegranteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FilmeIntegranteScalarFieldEnum | FilmeIntegranteScalarFieldEnum[]
  }

  /**
   * Integrante without action
   */
  export type IntegranteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integrante
     */
    select?: IntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integrante
     */
    omit?: IntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegranteInclude<ExtArgs> | null
  }


  /**
   * Model TipoIntegrante
   */

  export type AggregateTipoIntegrante = {
    _count: TipoIntegranteCountAggregateOutputType | null
    _avg: TipoIntegranteAvgAggregateOutputType | null
    _sum: TipoIntegranteSumAggregateOutputType | null
    _min: TipoIntegranteMinAggregateOutputType | null
    _max: TipoIntegranteMaxAggregateOutputType | null
  }

  export type TipoIntegranteAvgAggregateOutputType = {
    id: number | null
  }

  export type TipoIntegranteSumAggregateOutputType = {
    id: number | null
  }

  export type TipoIntegranteMinAggregateOutputType = {
    id: number | null
    nome: string | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type TipoIntegranteMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type TipoIntegranteCountAggregateOutputType = {
    id: number
    nome: number
    ativo: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type TipoIntegranteAvgAggregateInputType = {
    id?: true
  }

  export type TipoIntegranteSumAggregateInputType = {
    id?: true
  }

  export type TipoIntegranteMinAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type TipoIntegranteMaxAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type TipoIntegranteCountAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type TipoIntegranteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoIntegrante to aggregate.
     */
    where?: TipoIntegranteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoIntegrantes to fetch.
     */
    orderBy?: TipoIntegranteOrderByWithRelationInput | TipoIntegranteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TipoIntegranteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoIntegrantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoIntegrantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TipoIntegrantes
    **/
    _count?: true | TipoIntegranteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoIntegranteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoIntegranteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoIntegranteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoIntegranteMaxAggregateInputType
  }

  export type GetTipoIntegranteAggregateType<T extends TipoIntegranteAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoIntegrante]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoIntegrante[P]>
      : GetScalarType<T[P], AggregateTipoIntegrante[P]>
  }




  export type TipoIntegranteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TipoIntegranteWhereInput
    orderBy?: TipoIntegranteOrderByWithAggregationInput | TipoIntegranteOrderByWithAggregationInput[]
    by: TipoIntegranteScalarFieldEnum[] | TipoIntegranteScalarFieldEnum
    having?: TipoIntegranteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoIntegranteCountAggregateInputType | true
    _avg?: TipoIntegranteAvgAggregateInputType
    _sum?: TipoIntegranteSumAggregateInputType
    _min?: TipoIntegranteMinAggregateInputType
    _max?: TipoIntegranteMaxAggregateInputType
  }

  export type TipoIntegranteGroupByOutputType = {
    id: number
    nome: string
    ativo: boolean
    criadoEm: Date
    atualizadoEm: Date
    _count: TipoIntegranteCountAggregateOutputType | null
    _avg: TipoIntegranteAvgAggregateOutputType | null
    _sum: TipoIntegranteSumAggregateOutputType | null
    _min: TipoIntegranteMinAggregateOutputType | null
    _max: TipoIntegranteMaxAggregateOutputType | null
  }

  type GetTipoIntegranteGroupByPayload<T extends TipoIntegranteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TipoIntegranteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoIntegranteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoIntegranteGroupByOutputType[P]>
            : GetScalarType<T[P], TipoIntegranteGroupByOutputType[P]>
        }
      >
    >


  export type TipoIntegranteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    integrantes?: boolean | TipoIntegrante$integrantesArgs<ExtArgs>
    _count?: boolean | TipoIntegranteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipoIntegrante"]>

  export type TipoIntegranteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }, ExtArgs["result"]["tipoIntegrante"]>

  export type TipoIntegranteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }, ExtArgs["result"]["tipoIntegrante"]>

  export type TipoIntegranteSelectScalar = {
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type TipoIntegranteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "ativo" | "criadoEm" | "atualizadoEm", ExtArgs["result"]["tipoIntegrante"]>
  export type TipoIntegranteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    integrantes?: boolean | TipoIntegrante$integrantesArgs<ExtArgs>
    _count?: boolean | TipoIntegranteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TipoIntegranteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TipoIntegranteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TipoIntegrantePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TipoIntegrante"
    objects: {
      integrantes: Prisma.$IntegrantePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      ativo: boolean
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["tipoIntegrante"]>
    composites: {}
  }

  type TipoIntegranteGetPayload<S extends boolean | null | undefined | TipoIntegranteDefaultArgs> = $Result.GetResult<Prisma.$TipoIntegrantePayload, S>

  type TipoIntegranteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TipoIntegranteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TipoIntegranteCountAggregateInputType | true
    }

  export interface TipoIntegranteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TipoIntegrante'], meta: { name: 'TipoIntegrante' } }
    /**
     * Find zero or one TipoIntegrante that matches the filter.
     * @param {TipoIntegranteFindUniqueArgs} args - Arguments to find a TipoIntegrante
     * @example
     * // Get one TipoIntegrante
     * const tipoIntegrante = await prisma.tipoIntegrante.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TipoIntegranteFindUniqueArgs>(args: SelectSubset<T, TipoIntegranteFindUniqueArgs<ExtArgs>>): Prisma__TipoIntegranteClient<$Result.GetResult<Prisma.$TipoIntegrantePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TipoIntegrante that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TipoIntegranteFindUniqueOrThrowArgs} args - Arguments to find a TipoIntegrante
     * @example
     * // Get one TipoIntegrante
     * const tipoIntegrante = await prisma.tipoIntegrante.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TipoIntegranteFindUniqueOrThrowArgs>(args: SelectSubset<T, TipoIntegranteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TipoIntegranteClient<$Result.GetResult<Prisma.$TipoIntegrantePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoIntegrante that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoIntegranteFindFirstArgs} args - Arguments to find a TipoIntegrante
     * @example
     * // Get one TipoIntegrante
     * const tipoIntegrante = await prisma.tipoIntegrante.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TipoIntegranteFindFirstArgs>(args?: SelectSubset<T, TipoIntegranteFindFirstArgs<ExtArgs>>): Prisma__TipoIntegranteClient<$Result.GetResult<Prisma.$TipoIntegrantePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoIntegrante that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoIntegranteFindFirstOrThrowArgs} args - Arguments to find a TipoIntegrante
     * @example
     * // Get one TipoIntegrante
     * const tipoIntegrante = await prisma.tipoIntegrante.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TipoIntegranteFindFirstOrThrowArgs>(args?: SelectSubset<T, TipoIntegranteFindFirstOrThrowArgs<ExtArgs>>): Prisma__TipoIntegranteClient<$Result.GetResult<Prisma.$TipoIntegrantePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TipoIntegrantes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoIntegranteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoIntegrantes
     * const tipoIntegrantes = await prisma.tipoIntegrante.findMany()
     * 
     * // Get first 10 TipoIntegrantes
     * const tipoIntegrantes = await prisma.tipoIntegrante.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipoIntegranteWithIdOnly = await prisma.tipoIntegrante.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TipoIntegranteFindManyArgs>(args?: SelectSubset<T, TipoIntegranteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoIntegrantePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TipoIntegrante.
     * @param {TipoIntegranteCreateArgs} args - Arguments to create a TipoIntegrante.
     * @example
     * // Create one TipoIntegrante
     * const TipoIntegrante = await prisma.tipoIntegrante.create({
     *   data: {
     *     // ... data to create a TipoIntegrante
     *   }
     * })
     * 
     */
    create<T extends TipoIntegranteCreateArgs>(args: SelectSubset<T, TipoIntegranteCreateArgs<ExtArgs>>): Prisma__TipoIntegranteClient<$Result.GetResult<Prisma.$TipoIntegrantePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TipoIntegrantes.
     * @param {TipoIntegranteCreateManyArgs} args - Arguments to create many TipoIntegrantes.
     * @example
     * // Create many TipoIntegrantes
     * const tipoIntegrante = await prisma.tipoIntegrante.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TipoIntegranteCreateManyArgs>(args?: SelectSubset<T, TipoIntegranteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TipoIntegrantes and returns the data saved in the database.
     * @param {TipoIntegranteCreateManyAndReturnArgs} args - Arguments to create many TipoIntegrantes.
     * @example
     * // Create many TipoIntegrantes
     * const tipoIntegrante = await prisma.tipoIntegrante.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TipoIntegrantes and only return the `id`
     * const tipoIntegranteWithIdOnly = await prisma.tipoIntegrante.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TipoIntegranteCreateManyAndReturnArgs>(args?: SelectSubset<T, TipoIntegranteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoIntegrantePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TipoIntegrante.
     * @param {TipoIntegranteDeleteArgs} args - Arguments to delete one TipoIntegrante.
     * @example
     * // Delete one TipoIntegrante
     * const TipoIntegrante = await prisma.tipoIntegrante.delete({
     *   where: {
     *     // ... filter to delete one TipoIntegrante
     *   }
     * })
     * 
     */
    delete<T extends TipoIntegranteDeleteArgs>(args: SelectSubset<T, TipoIntegranteDeleteArgs<ExtArgs>>): Prisma__TipoIntegranteClient<$Result.GetResult<Prisma.$TipoIntegrantePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TipoIntegrante.
     * @param {TipoIntegranteUpdateArgs} args - Arguments to update one TipoIntegrante.
     * @example
     * // Update one TipoIntegrante
     * const tipoIntegrante = await prisma.tipoIntegrante.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TipoIntegranteUpdateArgs>(args: SelectSubset<T, TipoIntegranteUpdateArgs<ExtArgs>>): Prisma__TipoIntegranteClient<$Result.GetResult<Prisma.$TipoIntegrantePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TipoIntegrantes.
     * @param {TipoIntegranteDeleteManyArgs} args - Arguments to filter TipoIntegrantes to delete.
     * @example
     * // Delete a few TipoIntegrantes
     * const { count } = await prisma.tipoIntegrante.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TipoIntegranteDeleteManyArgs>(args?: SelectSubset<T, TipoIntegranteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoIntegrantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoIntegranteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoIntegrantes
     * const tipoIntegrante = await prisma.tipoIntegrante.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TipoIntegranteUpdateManyArgs>(args: SelectSubset<T, TipoIntegranteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoIntegrantes and returns the data updated in the database.
     * @param {TipoIntegranteUpdateManyAndReturnArgs} args - Arguments to update many TipoIntegrantes.
     * @example
     * // Update many TipoIntegrantes
     * const tipoIntegrante = await prisma.tipoIntegrante.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TipoIntegrantes and only return the `id`
     * const tipoIntegranteWithIdOnly = await prisma.tipoIntegrante.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TipoIntegranteUpdateManyAndReturnArgs>(args: SelectSubset<T, TipoIntegranteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoIntegrantePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TipoIntegrante.
     * @param {TipoIntegranteUpsertArgs} args - Arguments to update or create a TipoIntegrante.
     * @example
     * // Update or create a TipoIntegrante
     * const tipoIntegrante = await prisma.tipoIntegrante.upsert({
     *   create: {
     *     // ... data to create a TipoIntegrante
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoIntegrante we want to update
     *   }
     * })
     */
    upsert<T extends TipoIntegranteUpsertArgs>(args: SelectSubset<T, TipoIntegranteUpsertArgs<ExtArgs>>): Prisma__TipoIntegranteClient<$Result.GetResult<Prisma.$TipoIntegrantePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TipoIntegrantes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoIntegranteCountArgs} args - Arguments to filter TipoIntegrantes to count.
     * @example
     * // Count the number of TipoIntegrantes
     * const count = await prisma.tipoIntegrante.count({
     *   where: {
     *     // ... the filter for the TipoIntegrantes we want to count
     *   }
     * })
    **/
    count<T extends TipoIntegranteCountArgs>(
      args?: Subset<T, TipoIntegranteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoIntegranteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoIntegrante.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoIntegranteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoIntegranteAggregateArgs>(args: Subset<T, TipoIntegranteAggregateArgs>): Prisma.PrismaPromise<GetTipoIntegranteAggregateType<T>>

    /**
     * Group by TipoIntegrante.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoIntegranteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TipoIntegranteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TipoIntegranteGroupByArgs['orderBy'] }
        : { orderBy?: TipoIntegranteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TipoIntegranteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoIntegranteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TipoIntegrante model
   */
  readonly fields: TipoIntegranteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TipoIntegrante.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TipoIntegranteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    integrantes<T extends TipoIntegrante$integrantesArgs<ExtArgs> = {}>(args?: Subset<T, TipoIntegrante$integrantesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrantePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TipoIntegrante model
   */
  interface TipoIntegranteFieldRefs {
    readonly id: FieldRef<"TipoIntegrante", 'Int'>
    readonly nome: FieldRef<"TipoIntegrante", 'String'>
    readonly ativo: FieldRef<"TipoIntegrante", 'Boolean'>
    readonly criadoEm: FieldRef<"TipoIntegrante", 'DateTime'>
    readonly atualizadoEm: FieldRef<"TipoIntegrante", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TipoIntegrante findUnique
   */
  export type TipoIntegranteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoIntegrante
     */
    select?: TipoIntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoIntegrante
     */
    omit?: TipoIntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoIntegranteInclude<ExtArgs> | null
    /**
     * Filter, which TipoIntegrante to fetch.
     */
    where: TipoIntegranteWhereUniqueInput
  }

  /**
   * TipoIntegrante findUniqueOrThrow
   */
  export type TipoIntegranteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoIntegrante
     */
    select?: TipoIntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoIntegrante
     */
    omit?: TipoIntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoIntegranteInclude<ExtArgs> | null
    /**
     * Filter, which TipoIntegrante to fetch.
     */
    where: TipoIntegranteWhereUniqueInput
  }

  /**
   * TipoIntegrante findFirst
   */
  export type TipoIntegranteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoIntegrante
     */
    select?: TipoIntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoIntegrante
     */
    omit?: TipoIntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoIntegranteInclude<ExtArgs> | null
    /**
     * Filter, which TipoIntegrante to fetch.
     */
    where?: TipoIntegranteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoIntegrantes to fetch.
     */
    orderBy?: TipoIntegranteOrderByWithRelationInput | TipoIntegranteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoIntegrantes.
     */
    cursor?: TipoIntegranteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoIntegrantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoIntegrantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoIntegrantes.
     */
    distinct?: TipoIntegranteScalarFieldEnum | TipoIntegranteScalarFieldEnum[]
  }

  /**
   * TipoIntegrante findFirstOrThrow
   */
  export type TipoIntegranteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoIntegrante
     */
    select?: TipoIntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoIntegrante
     */
    omit?: TipoIntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoIntegranteInclude<ExtArgs> | null
    /**
     * Filter, which TipoIntegrante to fetch.
     */
    where?: TipoIntegranteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoIntegrantes to fetch.
     */
    orderBy?: TipoIntegranteOrderByWithRelationInput | TipoIntegranteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoIntegrantes.
     */
    cursor?: TipoIntegranteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoIntegrantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoIntegrantes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoIntegrantes.
     */
    distinct?: TipoIntegranteScalarFieldEnum | TipoIntegranteScalarFieldEnum[]
  }

  /**
   * TipoIntegrante findMany
   */
  export type TipoIntegranteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoIntegrante
     */
    select?: TipoIntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoIntegrante
     */
    omit?: TipoIntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoIntegranteInclude<ExtArgs> | null
    /**
     * Filter, which TipoIntegrantes to fetch.
     */
    where?: TipoIntegranteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoIntegrantes to fetch.
     */
    orderBy?: TipoIntegranteOrderByWithRelationInput | TipoIntegranteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TipoIntegrantes.
     */
    cursor?: TipoIntegranteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoIntegrantes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoIntegrantes.
     */
    skip?: number
    distinct?: TipoIntegranteScalarFieldEnum | TipoIntegranteScalarFieldEnum[]
  }

  /**
   * TipoIntegrante create
   */
  export type TipoIntegranteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoIntegrante
     */
    select?: TipoIntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoIntegrante
     */
    omit?: TipoIntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoIntegranteInclude<ExtArgs> | null
    /**
     * The data needed to create a TipoIntegrante.
     */
    data: XOR<TipoIntegranteCreateInput, TipoIntegranteUncheckedCreateInput>
  }

  /**
   * TipoIntegrante createMany
   */
  export type TipoIntegranteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TipoIntegrantes.
     */
    data: TipoIntegranteCreateManyInput | TipoIntegranteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoIntegrante createManyAndReturn
   */
  export type TipoIntegranteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoIntegrante
     */
    select?: TipoIntegranteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoIntegrante
     */
    omit?: TipoIntegranteOmit<ExtArgs> | null
    /**
     * The data used to create many TipoIntegrantes.
     */
    data: TipoIntegranteCreateManyInput | TipoIntegranteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoIntegrante update
   */
  export type TipoIntegranteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoIntegrante
     */
    select?: TipoIntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoIntegrante
     */
    omit?: TipoIntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoIntegranteInclude<ExtArgs> | null
    /**
     * The data needed to update a TipoIntegrante.
     */
    data: XOR<TipoIntegranteUpdateInput, TipoIntegranteUncheckedUpdateInput>
    /**
     * Choose, which TipoIntegrante to update.
     */
    where: TipoIntegranteWhereUniqueInput
  }

  /**
   * TipoIntegrante updateMany
   */
  export type TipoIntegranteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TipoIntegrantes.
     */
    data: XOR<TipoIntegranteUpdateManyMutationInput, TipoIntegranteUncheckedUpdateManyInput>
    /**
     * Filter which TipoIntegrantes to update
     */
    where?: TipoIntegranteWhereInput
    /**
     * Limit how many TipoIntegrantes to update.
     */
    limit?: number
  }

  /**
   * TipoIntegrante updateManyAndReturn
   */
  export type TipoIntegranteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoIntegrante
     */
    select?: TipoIntegranteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoIntegrante
     */
    omit?: TipoIntegranteOmit<ExtArgs> | null
    /**
     * The data used to update TipoIntegrantes.
     */
    data: XOR<TipoIntegranteUpdateManyMutationInput, TipoIntegranteUncheckedUpdateManyInput>
    /**
     * Filter which TipoIntegrantes to update
     */
    where?: TipoIntegranteWhereInput
    /**
     * Limit how many TipoIntegrantes to update.
     */
    limit?: number
  }

  /**
   * TipoIntegrante upsert
   */
  export type TipoIntegranteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoIntegrante
     */
    select?: TipoIntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoIntegrante
     */
    omit?: TipoIntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoIntegranteInclude<ExtArgs> | null
    /**
     * The filter to search for the TipoIntegrante to update in case it exists.
     */
    where: TipoIntegranteWhereUniqueInput
    /**
     * In case the TipoIntegrante found by the `where` argument doesn't exist, create a new TipoIntegrante with this data.
     */
    create: XOR<TipoIntegranteCreateInput, TipoIntegranteUncheckedCreateInput>
    /**
     * In case the TipoIntegrante was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TipoIntegranteUpdateInput, TipoIntegranteUncheckedUpdateInput>
  }

  /**
   * TipoIntegrante delete
   */
  export type TipoIntegranteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoIntegrante
     */
    select?: TipoIntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoIntegrante
     */
    omit?: TipoIntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoIntegranteInclude<ExtArgs> | null
    /**
     * Filter which TipoIntegrante to delete.
     */
    where: TipoIntegranteWhereUniqueInput
  }

  /**
   * TipoIntegrante deleteMany
   */
  export type TipoIntegranteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoIntegrantes to delete
     */
    where?: TipoIntegranteWhereInput
    /**
     * Limit how many TipoIntegrantes to delete.
     */
    limit?: number
  }

  /**
   * TipoIntegrante.integrantes
   */
  export type TipoIntegrante$integrantesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integrante
     */
    select?: IntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integrante
     */
    omit?: IntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegranteInclude<ExtArgs> | null
    where?: IntegranteWhereInput
    orderBy?: IntegranteOrderByWithRelationInput | IntegranteOrderByWithRelationInput[]
    cursor?: IntegranteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntegranteScalarFieldEnum | IntegranteScalarFieldEnum[]
  }

  /**
   * TipoIntegrante without action
   */
  export type TipoIntegranteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoIntegrante
     */
    select?: TipoIntegranteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoIntegrante
     */
    omit?: TipoIntegranteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoIntegranteInclude<ExtArgs> | null
  }


  /**
   * Model ClassificacaoIndicativa
   */

  export type AggregateClassificacaoIndicativa = {
    _count: ClassificacaoIndicativaCountAggregateOutputType | null
    _avg: ClassificacaoIndicativaAvgAggregateOutputType | null
    _sum: ClassificacaoIndicativaSumAggregateOutputType | null
    _min: ClassificacaoIndicativaMinAggregateOutputType | null
    _max: ClassificacaoIndicativaMaxAggregateOutputType | null
  }

  export type ClassificacaoIndicativaAvgAggregateOutputType = {
    id: number | null
  }

  export type ClassificacaoIndicativaSumAggregateOutputType = {
    id: number | null
  }

  export type ClassificacaoIndicativaMinAggregateOutputType = {
    id: number | null
    nome: string | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type ClassificacaoIndicativaMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type ClassificacaoIndicativaCountAggregateOutputType = {
    id: number
    nome: number
    ativo: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type ClassificacaoIndicativaAvgAggregateInputType = {
    id?: true
  }

  export type ClassificacaoIndicativaSumAggregateInputType = {
    id?: true
  }

  export type ClassificacaoIndicativaMinAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type ClassificacaoIndicativaMaxAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type ClassificacaoIndicativaCountAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type ClassificacaoIndicativaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassificacaoIndicativa to aggregate.
     */
    where?: ClassificacaoIndicativaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassificacaoIndicativas to fetch.
     */
    orderBy?: ClassificacaoIndicativaOrderByWithRelationInput | ClassificacaoIndicativaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassificacaoIndicativaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassificacaoIndicativas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassificacaoIndicativas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClassificacaoIndicativas
    **/
    _count?: true | ClassificacaoIndicativaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassificacaoIndicativaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassificacaoIndicativaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassificacaoIndicativaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassificacaoIndicativaMaxAggregateInputType
  }

  export type GetClassificacaoIndicativaAggregateType<T extends ClassificacaoIndicativaAggregateArgs> = {
        [P in keyof T & keyof AggregateClassificacaoIndicativa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassificacaoIndicativa[P]>
      : GetScalarType<T[P], AggregateClassificacaoIndicativa[P]>
  }




  export type ClassificacaoIndicativaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassificacaoIndicativaWhereInput
    orderBy?: ClassificacaoIndicativaOrderByWithAggregationInput | ClassificacaoIndicativaOrderByWithAggregationInput[]
    by: ClassificacaoIndicativaScalarFieldEnum[] | ClassificacaoIndicativaScalarFieldEnum
    having?: ClassificacaoIndicativaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassificacaoIndicativaCountAggregateInputType | true
    _avg?: ClassificacaoIndicativaAvgAggregateInputType
    _sum?: ClassificacaoIndicativaSumAggregateInputType
    _min?: ClassificacaoIndicativaMinAggregateInputType
    _max?: ClassificacaoIndicativaMaxAggregateInputType
  }

  export type ClassificacaoIndicativaGroupByOutputType = {
    id: number
    nome: string
    ativo: boolean
    criadoEm: Date
    atualizadoEm: Date
    _count: ClassificacaoIndicativaCountAggregateOutputType | null
    _avg: ClassificacaoIndicativaAvgAggregateOutputType | null
    _sum: ClassificacaoIndicativaSumAggregateOutputType | null
    _min: ClassificacaoIndicativaMinAggregateOutputType | null
    _max: ClassificacaoIndicativaMaxAggregateOutputType | null
  }

  type GetClassificacaoIndicativaGroupByPayload<T extends ClassificacaoIndicativaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassificacaoIndicativaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassificacaoIndicativaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassificacaoIndicativaGroupByOutputType[P]>
            : GetScalarType<T[P], ClassificacaoIndicativaGroupByOutputType[P]>
        }
      >
    >


  export type ClassificacaoIndicativaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    filmes?: boolean | ClassificacaoIndicativa$filmesArgs<ExtArgs>
    _count?: boolean | ClassificacaoIndicativaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classificacaoIndicativa"]>

  export type ClassificacaoIndicativaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }, ExtArgs["result"]["classificacaoIndicativa"]>

  export type ClassificacaoIndicativaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }, ExtArgs["result"]["classificacaoIndicativa"]>

  export type ClassificacaoIndicativaSelectScalar = {
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type ClassificacaoIndicativaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "ativo" | "criadoEm" | "atualizadoEm", ExtArgs["result"]["classificacaoIndicativa"]>
  export type ClassificacaoIndicativaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filmes?: boolean | ClassificacaoIndicativa$filmesArgs<ExtArgs>
    _count?: boolean | ClassificacaoIndicativaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClassificacaoIndicativaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ClassificacaoIndicativaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClassificacaoIndicativaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClassificacaoIndicativa"
    objects: {
      filmes: Prisma.$FilmePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      ativo: boolean
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["classificacaoIndicativa"]>
    composites: {}
  }

  type ClassificacaoIndicativaGetPayload<S extends boolean | null | undefined | ClassificacaoIndicativaDefaultArgs> = $Result.GetResult<Prisma.$ClassificacaoIndicativaPayload, S>

  type ClassificacaoIndicativaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassificacaoIndicativaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassificacaoIndicativaCountAggregateInputType | true
    }

  export interface ClassificacaoIndicativaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClassificacaoIndicativa'], meta: { name: 'ClassificacaoIndicativa' } }
    /**
     * Find zero or one ClassificacaoIndicativa that matches the filter.
     * @param {ClassificacaoIndicativaFindUniqueArgs} args - Arguments to find a ClassificacaoIndicativa
     * @example
     * // Get one ClassificacaoIndicativa
     * const classificacaoIndicativa = await prisma.classificacaoIndicativa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassificacaoIndicativaFindUniqueArgs>(args: SelectSubset<T, ClassificacaoIndicativaFindUniqueArgs<ExtArgs>>): Prisma__ClassificacaoIndicativaClient<$Result.GetResult<Prisma.$ClassificacaoIndicativaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClassificacaoIndicativa that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassificacaoIndicativaFindUniqueOrThrowArgs} args - Arguments to find a ClassificacaoIndicativa
     * @example
     * // Get one ClassificacaoIndicativa
     * const classificacaoIndicativa = await prisma.classificacaoIndicativa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassificacaoIndicativaFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassificacaoIndicativaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassificacaoIndicativaClient<$Result.GetResult<Prisma.$ClassificacaoIndicativaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassificacaoIndicativa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassificacaoIndicativaFindFirstArgs} args - Arguments to find a ClassificacaoIndicativa
     * @example
     * // Get one ClassificacaoIndicativa
     * const classificacaoIndicativa = await prisma.classificacaoIndicativa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassificacaoIndicativaFindFirstArgs>(args?: SelectSubset<T, ClassificacaoIndicativaFindFirstArgs<ExtArgs>>): Prisma__ClassificacaoIndicativaClient<$Result.GetResult<Prisma.$ClassificacaoIndicativaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClassificacaoIndicativa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassificacaoIndicativaFindFirstOrThrowArgs} args - Arguments to find a ClassificacaoIndicativa
     * @example
     * // Get one ClassificacaoIndicativa
     * const classificacaoIndicativa = await prisma.classificacaoIndicativa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassificacaoIndicativaFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassificacaoIndicativaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassificacaoIndicativaClient<$Result.GetResult<Prisma.$ClassificacaoIndicativaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClassificacaoIndicativas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassificacaoIndicativaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClassificacaoIndicativas
     * const classificacaoIndicativas = await prisma.classificacaoIndicativa.findMany()
     * 
     * // Get first 10 ClassificacaoIndicativas
     * const classificacaoIndicativas = await prisma.classificacaoIndicativa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classificacaoIndicativaWithIdOnly = await prisma.classificacaoIndicativa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassificacaoIndicativaFindManyArgs>(args?: SelectSubset<T, ClassificacaoIndicativaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassificacaoIndicativaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClassificacaoIndicativa.
     * @param {ClassificacaoIndicativaCreateArgs} args - Arguments to create a ClassificacaoIndicativa.
     * @example
     * // Create one ClassificacaoIndicativa
     * const ClassificacaoIndicativa = await prisma.classificacaoIndicativa.create({
     *   data: {
     *     // ... data to create a ClassificacaoIndicativa
     *   }
     * })
     * 
     */
    create<T extends ClassificacaoIndicativaCreateArgs>(args: SelectSubset<T, ClassificacaoIndicativaCreateArgs<ExtArgs>>): Prisma__ClassificacaoIndicativaClient<$Result.GetResult<Prisma.$ClassificacaoIndicativaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClassificacaoIndicativas.
     * @param {ClassificacaoIndicativaCreateManyArgs} args - Arguments to create many ClassificacaoIndicativas.
     * @example
     * // Create many ClassificacaoIndicativas
     * const classificacaoIndicativa = await prisma.classificacaoIndicativa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassificacaoIndicativaCreateManyArgs>(args?: SelectSubset<T, ClassificacaoIndicativaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClassificacaoIndicativas and returns the data saved in the database.
     * @param {ClassificacaoIndicativaCreateManyAndReturnArgs} args - Arguments to create many ClassificacaoIndicativas.
     * @example
     * // Create many ClassificacaoIndicativas
     * const classificacaoIndicativa = await prisma.classificacaoIndicativa.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClassificacaoIndicativas and only return the `id`
     * const classificacaoIndicativaWithIdOnly = await prisma.classificacaoIndicativa.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassificacaoIndicativaCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassificacaoIndicativaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassificacaoIndicativaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClassificacaoIndicativa.
     * @param {ClassificacaoIndicativaDeleteArgs} args - Arguments to delete one ClassificacaoIndicativa.
     * @example
     * // Delete one ClassificacaoIndicativa
     * const ClassificacaoIndicativa = await prisma.classificacaoIndicativa.delete({
     *   where: {
     *     // ... filter to delete one ClassificacaoIndicativa
     *   }
     * })
     * 
     */
    delete<T extends ClassificacaoIndicativaDeleteArgs>(args: SelectSubset<T, ClassificacaoIndicativaDeleteArgs<ExtArgs>>): Prisma__ClassificacaoIndicativaClient<$Result.GetResult<Prisma.$ClassificacaoIndicativaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClassificacaoIndicativa.
     * @param {ClassificacaoIndicativaUpdateArgs} args - Arguments to update one ClassificacaoIndicativa.
     * @example
     * // Update one ClassificacaoIndicativa
     * const classificacaoIndicativa = await prisma.classificacaoIndicativa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassificacaoIndicativaUpdateArgs>(args: SelectSubset<T, ClassificacaoIndicativaUpdateArgs<ExtArgs>>): Prisma__ClassificacaoIndicativaClient<$Result.GetResult<Prisma.$ClassificacaoIndicativaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClassificacaoIndicativas.
     * @param {ClassificacaoIndicativaDeleteManyArgs} args - Arguments to filter ClassificacaoIndicativas to delete.
     * @example
     * // Delete a few ClassificacaoIndicativas
     * const { count } = await prisma.classificacaoIndicativa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassificacaoIndicativaDeleteManyArgs>(args?: SelectSubset<T, ClassificacaoIndicativaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassificacaoIndicativas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassificacaoIndicativaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClassificacaoIndicativas
     * const classificacaoIndicativa = await prisma.classificacaoIndicativa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassificacaoIndicativaUpdateManyArgs>(args: SelectSubset<T, ClassificacaoIndicativaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClassificacaoIndicativas and returns the data updated in the database.
     * @param {ClassificacaoIndicativaUpdateManyAndReturnArgs} args - Arguments to update many ClassificacaoIndicativas.
     * @example
     * // Update many ClassificacaoIndicativas
     * const classificacaoIndicativa = await prisma.classificacaoIndicativa.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClassificacaoIndicativas and only return the `id`
     * const classificacaoIndicativaWithIdOnly = await prisma.classificacaoIndicativa.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassificacaoIndicativaUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassificacaoIndicativaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassificacaoIndicativaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClassificacaoIndicativa.
     * @param {ClassificacaoIndicativaUpsertArgs} args - Arguments to update or create a ClassificacaoIndicativa.
     * @example
     * // Update or create a ClassificacaoIndicativa
     * const classificacaoIndicativa = await prisma.classificacaoIndicativa.upsert({
     *   create: {
     *     // ... data to create a ClassificacaoIndicativa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClassificacaoIndicativa we want to update
     *   }
     * })
     */
    upsert<T extends ClassificacaoIndicativaUpsertArgs>(args: SelectSubset<T, ClassificacaoIndicativaUpsertArgs<ExtArgs>>): Prisma__ClassificacaoIndicativaClient<$Result.GetResult<Prisma.$ClassificacaoIndicativaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClassificacaoIndicativas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassificacaoIndicativaCountArgs} args - Arguments to filter ClassificacaoIndicativas to count.
     * @example
     * // Count the number of ClassificacaoIndicativas
     * const count = await prisma.classificacaoIndicativa.count({
     *   where: {
     *     // ... the filter for the ClassificacaoIndicativas we want to count
     *   }
     * })
    **/
    count<T extends ClassificacaoIndicativaCountArgs>(
      args?: Subset<T, ClassificacaoIndicativaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassificacaoIndicativaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClassificacaoIndicativa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassificacaoIndicativaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassificacaoIndicativaAggregateArgs>(args: Subset<T, ClassificacaoIndicativaAggregateArgs>): Prisma.PrismaPromise<GetClassificacaoIndicativaAggregateType<T>>

    /**
     * Group by ClassificacaoIndicativa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassificacaoIndicativaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassificacaoIndicativaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassificacaoIndicativaGroupByArgs['orderBy'] }
        : { orderBy?: ClassificacaoIndicativaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassificacaoIndicativaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassificacaoIndicativaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClassificacaoIndicativa model
   */
  readonly fields: ClassificacaoIndicativaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClassificacaoIndicativa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassificacaoIndicativaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    filmes<T extends ClassificacaoIndicativa$filmesArgs<ExtArgs> = {}>(args?: Subset<T, ClassificacaoIndicativa$filmesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilmePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClassificacaoIndicativa model
   */
  interface ClassificacaoIndicativaFieldRefs {
    readonly id: FieldRef<"ClassificacaoIndicativa", 'Int'>
    readonly nome: FieldRef<"ClassificacaoIndicativa", 'String'>
    readonly ativo: FieldRef<"ClassificacaoIndicativa", 'Boolean'>
    readonly criadoEm: FieldRef<"ClassificacaoIndicativa", 'DateTime'>
    readonly atualizadoEm: FieldRef<"ClassificacaoIndicativa", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClassificacaoIndicativa findUnique
   */
  export type ClassificacaoIndicativaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassificacaoIndicativa
     */
    select?: ClassificacaoIndicativaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassificacaoIndicativa
     */
    omit?: ClassificacaoIndicativaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificacaoIndicativaInclude<ExtArgs> | null
    /**
     * Filter, which ClassificacaoIndicativa to fetch.
     */
    where: ClassificacaoIndicativaWhereUniqueInput
  }

  /**
   * ClassificacaoIndicativa findUniqueOrThrow
   */
  export type ClassificacaoIndicativaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassificacaoIndicativa
     */
    select?: ClassificacaoIndicativaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassificacaoIndicativa
     */
    omit?: ClassificacaoIndicativaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificacaoIndicativaInclude<ExtArgs> | null
    /**
     * Filter, which ClassificacaoIndicativa to fetch.
     */
    where: ClassificacaoIndicativaWhereUniqueInput
  }

  /**
   * ClassificacaoIndicativa findFirst
   */
  export type ClassificacaoIndicativaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassificacaoIndicativa
     */
    select?: ClassificacaoIndicativaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassificacaoIndicativa
     */
    omit?: ClassificacaoIndicativaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificacaoIndicativaInclude<ExtArgs> | null
    /**
     * Filter, which ClassificacaoIndicativa to fetch.
     */
    where?: ClassificacaoIndicativaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassificacaoIndicativas to fetch.
     */
    orderBy?: ClassificacaoIndicativaOrderByWithRelationInput | ClassificacaoIndicativaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassificacaoIndicativas.
     */
    cursor?: ClassificacaoIndicativaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassificacaoIndicativas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassificacaoIndicativas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassificacaoIndicativas.
     */
    distinct?: ClassificacaoIndicativaScalarFieldEnum | ClassificacaoIndicativaScalarFieldEnum[]
  }

  /**
   * ClassificacaoIndicativa findFirstOrThrow
   */
  export type ClassificacaoIndicativaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassificacaoIndicativa
     */
    select?: ClassificacaoIndicativaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassificacaoIndicativa
     */
    omit?: ClassificacaoIndicativaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificacaoIndicativaInclude<ExtArgs> | null
    /**
     * Filter, which ClassificacaoIndicativa to fetch.
     */
    where?: ClassificacaoIndicativaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassificacaoIndicativas to fetch.
     */
    orderBy?: ClassificacaoIndicativaOrderByWithRelationInput | ClassificacaoIndicativaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClassificacaoIndicativas.
     */
    cursor?: ClassificacaoIndicativaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassificacaoIndicativas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassificacaoIndicativas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClassificacaoIndicativas.
     */
    distinct?: ClassificacaoIndicativaScalarFieldEnum | ClassificacaoIndicativaScalarFieldEnum[]
  }

  /**
   * ClassificacaoIndicativa findMany
   */
  export type ClassificacaoIndicativaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassificacaoIndicativa
     */
    select?: ClassificacaoIndicativaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassificacaoIndicativa
     */
    omit?: ClassificacaoIndicativaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificacaoIndicativaInclude<ExtArgs> | null
    /**
     * Filter, which ClassificacaoIndicativas to fetch.
     */
    where?: ClassificacaoIndicativaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClassificacaoIndicativas to fetch.
     */
    orderBy?: ClassificacaoIndicativaOrderByWithRelationInput | ClassificacaoIndicativaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClassificacaoIndicativas.
     */
    cursor?: ClassificacaoIndicativaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClassificacaoIndicativas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClassificacaoIndicativas.
     */
    skip?: number
    distinct?: ClassificacaoIndicativaScalarFieldEnum | ClassificacaoIndicativaScalarFieldEnum[]
  }

  /**
   * ClassificacaoIndicativa create
   */
  export type ClassificacaoIndicativaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassificacaoIndicativa
     */
    select?: ClassificacaoIndicativaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassificacaoIndicativa
     */
    omit?: ClassificacaoIndicativaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificacaoIndicativaInclude<ExtArgs> | null
    /**
     * The data needed to create a ClassificacaoIndicativa.
     */
    data: XOR<ClassificacaoIndicativaCreateInput, ClassificacaoIndicativaUncheckedCreateInput>
  }

  /**
   * ClassificacaoIndicativa createMany
   */
  export type ClassificacaoIndicativaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClassificacaoIndicativas.
     */
    data: ClassificacaoIndicativaCreateManyInput | ClassificacaoIndicativaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassificacaoIndicativa createManyAndReturn
   */
  export type ClassificacaoIndicativaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassificacaoIndicativa
     */
    select?: ClassificacaoIndicativaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClassificacaoIndicativa
     */
    omit?: ClassificacaoIndicativaOmit<ExtArgs> | null
    /**
     * The data used to create many ClassificacaoIndicativas.
     */
    data: ClassificacaoIndicativaCreateManyInput | ClassificacaoIndicativaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClassificacaoIndicativa update
   */
  export type ClassificacaoIndicativaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassificacaoIndicativa
     */
    select?: ClassificacaoIndicativaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassificacaoIndicativa
     */
    omit?: ClassificacaoIndicativaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificacaoIndicativaInclude<ExtArgs> | null
    /**
     * The data needed to update a ClassificacaoIndicativa.
     */
    data: XOR<ClassificacaoIndicativaUpdateInput, ClassificacaoIndicativaUncheckedUpdateInput>
    /**
     * Choose, which ClassificacaoIndicativa to update.
     */
    where: ClassificacaoIndicativaWhereUniqueInput
  }

  /**
   * ClassificacaoIndicativa updateMany
   */
  export type ClassificacaoIndicativaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClassificacaoIndicativas.
     */
    data: XOR<ClassificacaoIndicativaUpdateManyMutationInput, ClassificacaoIndicativaUncheckedUpdateManyInput>
    /**
     * Filter which ClassificacaoIndicativas to update
     */
    where?: ClassificacaoIndicativaWhereInput
    /**
     * Limit how many ClassificacaoIndicativas to update.
     */
    limit?: number
  }

  /**
   * ClassificacaoIndicativa updateManyAndReturn
   */
  export type ClassificacaoIndicativaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassificacaoIndicativa
     */
    select?: ClassificacaoIndicativaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClassificacaoIndicativa
     */
    omit?: ClassificacaoIndicativaOmit<ExtArgs> | null
    /**
     * The data used to update ClassificacaoIndicativas.
     */
    data: XOR<ClassificacaoIndicativaUpdateManyMutationInput, ClassificacaoIndicativaUncheckedUpdateManyInput>
    /**
     * Filter which ClassificacaoIndicativas to update
     */
    where?: ClassificacaoIndicativaWhereInput
    /**
     * Limit how many ClassificacaoIndicativas to update.
     */
    limit?: number
  }

  /**
   * ClassificacaoIndicativa upsert
   */
  export type ClassificacaoIndicativaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassificacaoIndicativa
     */
    select?: ClassificacaoIndicativaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassificacaoIndicativa
     */
    omit?: ClassificacaoIndicativaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificacaoIndicativaInclude<ExtArgs> | null
    /**
     * The filter to search for the ClassificacaoIndicativa to update in case it exists.
     */
    where: ClassificacaoIndicativaWhereUniqueInput
    /**
     * In case the ClassificacaoIndicativa found by the `where` argument doesn't exist, create a new ClassificacaoIndicativa with this data.
     */
    create: XOR<ClassificacaoIndicativaCreateInput, ClassificacaoIndicativaUncheckedCreateInput>
    /**
     * In case the ClassificacaoIndicativa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassificacaoIndicativaUpdateInput, ClassificacaoIndicativaUncheckedUpdateInput>
  }

  /**
   * ClassificacaoIndicativa delete
   */
  export type ClassificacaoIndicativaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassificacaoIndicativa
     */
    select?: ClassificacaoIndicativaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassificacaoIndicativa
     */
    omit?: ClassificacaoIndicativaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificacaoIndicativaInclude<ExtArgs> | null
    /**
     * Filter which ClassificacaoIndicativa to delete.
     */
    where: ClassificacaoIndicativaWhereUniqueInput
  }

  /**
   * ClassificacaoIndicativa deleteMany
   */
  export type ClassificacaoIndicativaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClassificacaoIndicativas to delete
     */
    where?: ClassificacaoIndicativaWhereInput
    /**
     * Limit how many ClassificacaoIndicativas to delete.
     */
    limit?: number
  }

  /**
   * ClassificacaoIndicativa.filmes
   */
  export type ClassificacaoIndicativa$filmesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Filme
     */
    select?: FilmeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Filme
     */
    omit?: FilmeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FilmeInclude<ExtArgs> | null
    where?: FilmeWhereInput
    orderBy?: FilmeOrderByWithRelationInput | FilmeOrderByWithRelationInput[]
    cursor?: FilmeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FilmeScalarFieldEnum | FilmeScalarFieldEnum[]
  }

  /**
   * ClassificacaoIndicativa without action
   */
  export type ClassificacaoIndicativaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassificacaoIndicativa
     */
    select?: ClassificacaoIndicativaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClassificacaoIndicativa
     */
    omit?: ClassificacaoIndicativaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassificacaoIndicativaInclude<ExtArgs> | null
  }


  /**
   * Model TipoIdioma
   */

  export type AggregateTipoIdioma = {
    _count: TipoIdiomaCountAggregateOutputType | null
    _avg: TipoIdiomaAvgAggregateOutputType | null
    _sum: TipoIdiomaSumAggregateOutputType | null
    _min: TipoIdiomaMinAggregateOutputType | null
    _max: TipoIdiomaMaxAggregateOutputType | null
  }

  export type TipoIdiomaAvgAggregateOutputType = {
    id: number | null
  }

  export type TipoIdiomaSumAggregateOutputType = {
    id: number | null
  }

  export type TipoIdiomaMinAggregateOutputType = {
    id: number | null
    nome: string | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type TipoIdiomaMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type TipoIdiomaCountAggregateOutputType = {
    id: number
    nome: number
    ativo: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type TipoIdiomaAvgAggregateInputType = {
    id?: true
  }

  export type TipoIdiomaSumAggregateInputType = {
    id?: true
  }

  export type TipoIdiomaMinAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type TipoIdiomaMaxAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type TipoIdiomaCountAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type TipoIdiomaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoIdioma to aggregate.
     */
    where?: TipoIdiomaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoIdiomas to fetch.
     */
    orderBy?: TipoIdiomaOrderByWithRelationInput | TipoIdiomaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TipoIdiomaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoIdiomas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoIdiomas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TipoIdiomas
    **/
    _count?: true | TipoIdiomaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoIdiomaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoIdiomaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoIdiomaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoIdiomaMaxAggregateInputType
  }

  export type GetTipoIdiomaAggregateType<T extends TipoIdiomaAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoIdioma]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoIdioma[P]>
      : GetScalarType<T[P], AggregateTipoIdioma[P]>
  }




  export type TipoIdiomaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TipoIdiomaWhereInput
    orderBy?: TipoIdiomaOrderByWithAggregationInput | TipoIdiomaOrderByWithAggregationInput[]
    by: TipoIdiomaScalarFieldEnum[] | TipoIdiomaScalarFieldEnum
    having?: TipoIdiomaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoIdiomaCountAggregateInputType | true
    _avg?: TipoIdiomaAvgAggregateInputType
    _sum?: TipoIdiomaSumAggregateInputType
    _min?: TipoIdiomaMinAggregateInputType
    _max?: TipoIdiomaMaxAggregateInputType
  }

  export type TipoIdiomaGroupByOutputType = {
    id: number
    nome: string
    ativo: boolean
    criadoEm: Date
    atualizadoEm: Date
    _count: TipoIdiomaCountAggregateOutputType | null
    _avg: TipoIdiomaAvgAggregateOutputType | null
    _sum: TipoIdiomaSumAggregateOutputType | null
    _min: TipoIdiomaMinAggregateOutputType | null
    _max: TipoIdiomaMaxAggregateOutputType | null
  }

  type GetTipoIdiomaGroupByPayload<T extends TipoIdiomaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TipoIdiomaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoIdiomaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoIdiomaGroupByOutputType[P]>
            : GetScalarType<T[P], TipoIdiomaGroupByOutputType[P]>
        }
      >
    >


  export type TipoIdiomaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    sessoes?: boolean | TipoIdioma$sessoesArgs<ExtArgs>
    _count?: boolean | TipoIdiomaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipoIdioma"]>

  export type TipoIdiomaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }, ExtArgs["result"]["tipoIdioma"]>

  export type TipoIdiomaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }, ExtArgs["result"]["tipoIdioma"]>

  export type TipoIdiomaSelectScalar = {
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type TipoIdiomaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "ativo" | "criadoEm" | "atualizadoEm", ExtArgs["result"]["tipoIdioma"]>
  export type TipoIdiomaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessoes?: boolean | TipoIdioma$sessoesArgs<ExtArgs>
    _count?: boolean | TipoIdiomaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TipoIdiomaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TipoIdiomaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TipoIdiomaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TipoIdioma"
    objects: {
      sessoes: Prisma.$SessaoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      ativo: boolean
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["tipoIdioma"]>
    composites: {}
  }

  type TipoIdiomaGetPayload<S extends boolean | null | undefined | TipoIdiomaDefaultArgs> = $Result.GetResult<Prisma.$TipoIdiomaPayload, S>

  type TipoIdiomaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TipoIdiomaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TipoIdiomaCountAggregateInputType | true
    }

  export interface TipoIdiomaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TipoIdioma'], meta: { name: 'TipoIdioma' } }
    /**
     * Find zero or one TipoIdioma that matches the filter.
     * @param {TipoIdiomaFindUniqueArgs} args - Arguments to find a TipoIdioma
     * @example
     * // Get one TipoIdioma
     * const tipoIdioma = await prisma.tipoIdioma.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TipoIdiomaFindUniqueArgs>(args: SelectSubset<T, TipoIdiomaFindUniqueArgs<ExtArgs>>): Prisma__TipoIdiomaClient<$Result.GetResult<Prisma.$TipoIdiomaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TipoIdioma that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TipoIdiomaFindUniqueOrThrowArgs} args - Arguments to find a TipoIdioma
     * @example
     * // Get one TipoIdioma
     * const tipoIdioma = await prisma.tipoIdioma.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TipoIdiomaFindUniqueOrThrowArgs>(args: SelectSubset<T, TipoIdiomaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TipoIdiomaClient<$Result.GetResult<Prisma.$TipoIdiomaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoIdioma that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoIdiomaFindFirstArgs} args - Arguments to find a TipoIdioma
     * @example
     * // Get one TipoIdioma
     * const tipoIdioma = await prisma.tipoIdioma.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TipoIdiomaFindFirstArgs>(args?: SelectSubset<T, TipoIdiomaFindFirstArgs<ExtArgs>>): Prisma__TipoIdiomaClient<$Result.GetResult<Prisma.$TipoIdiomaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoIdioma that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoIdiomaFindFirstOrThrowArgs} args - Arguments to find a TipoIdioma
     * @example
     * // Get one TipoIdioma
     * const tipoIdioma = await prisma.tipoIdioma.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TipoIdiomaFindFirstOrThrowArgs>(args?: SelectSubset<T, TipoIdiomaFindFirstOrThrowArgs<ExtArgs>>): Prisma__TipoIdiomaClient<$Result.GetResult<Prisma.$TipoIdiomaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TipoIdiomas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoIdiomaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoIdiomas
     * const tipoIdiomas = await prisma.tipoIdioma.findMany()
     * 
     * // Get first 10 TipoIdiomas
     * const tipoIdiomas = await prisma.tipoIdioma.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipoIdiomaWithIdOnly = await prisma.tipoIdioma.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TipoIdiomaFindManyArgs>(args?: SelectSubset<T, TipoIdiomaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoIdiomaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TipoIdioma.
     * @param {TipoIdiomaCreateArgs} args - Arguments to create a TipoIdioma.
     * @example
     * // Create one TipoIdioma
     * const TipoIdioma = await prisma.tipoIdioma.create({
     *   data: {
     *     // ... data to create a TipoIdioma
     *   }
     * })
     * 
     */
    create<T extends TipoIdiomaCreateArgs>(args: SelectSubset<T, TipoIdiomaCreateArgs<ExtArgs>>): Prisma__TipoIdiomaClient<$Result.GetResult<Prisma.$TipoIdiomaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TipoIdiomas.
     * @param {TipoIdiomaCreateManyArgs} args - Arguments to create many TipoIdiomas.
     * @example
     * // Create many TipoIdiomas
     * const tipoIdioma = await prisma.tipoIdioma.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TipoIdiomaCreateManyArgs>(args?: SelectSubset<T, TipoIdiomaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TipoIdiomas and returns the data saved in the database.
     * @param {TipoIdiomaCreateManyAndReturnArgs} args - Arguments to create many TipoIdiomas.
     * @example
     * // Create many TipoIdiomas
     * const tipoIdioma = await prisma.tipoIdioma.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TipoIdiomas and only return the `id`
     * const tipoIdiomaWithIdOnly = await prisma.tipoIdioma.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TipoIdiomaCreateManyAndReturnArgs>(args?: SelectSubset<T, TipoIdiomaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoIdiomaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TipoIdioma.
     * @param {TipoIdiomaDeleteArgs} args - Arguments to delete one TipoIdioma.
     * @example
     * // Delete one TipoIdioma
     * const TipoIdioma = await prisma.tipoIdioma.delete({
     *   where: {
     *     // ... filter to delete one TipoIdioma
     *   }
     * })
     * 
     */
    delete<T extends TipoIdiomaDeleteArgs>(args: SelectSubset<T, TipoIdiomaDeleteArgs<ExtArgs>>): Prisma__TipoIdiomaClient<$Result.GetResult<Prisma.$TipoIdiomaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TipoIdioma.
     * @param {TipoIdiomaUpdateArgs} args - Arguments to update one TipoIdioma.
     * @example
     * // Update one TipoIdioma
     * const tipoIdioma = await prisma.tipoIdioma.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TipoIdiomaUpdateArgs>(args: SelectSubset<T, TipoIdiomaUpdateArgs<ExtArgs>>): Prisma__TipoIdiomaClient<$Result.GetResult<Prisma.$TipoIdiomaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TipoIdiomas.
     * @param {TipoIdiomaDeleteManyArgs} args - Arguments to filter TipoIdiomas to delete.
     * @example
     * // Delete a few TipoIdiomas
     * const { count } = await prisma.tipoIdioma.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TipoIdiomaDeleteManyArgs>(args?: SelectSubset<T, TipoIdiomaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoIdiomas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoIdiomaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoIdiomas
     * const tipoIdioma = await prisma.tipoIdioma.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TipoIdiomaUpdateManyArgs>(args: SelectSubset<T, TipoIdiomaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoIdiomas and returns the data updated in the database.
     * @param {TipoIdiomaUpdateManyAndReturnArgs} args - Arguments to update many TipoIdiomas.
     * @example
     * // Update many TipoIdiomas
     * const tipoIdioma = await prisma.tipoIdioma.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TipoIdiomas and only return the `id`
     * const tipoIdiomaWithIdOnly = await prisma.tipoIdioma.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TipoIdiomaUpdateManyAndReturnArgs>(args: SelectSubset<T, TipoIdiomaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoIdiomaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TipoIdioma.
     * @param {TipoIdiomaUpsertArgs} args - Arguments to update or create a TipoIdioma.
     * @example
     * // Update or create a TipoIdioma
     * const tipoIdioma = await prisma.tipoIdioma.upsert({
     *   create: {
     *     // ... data to create a TipoIdioma
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoIdioma we want to update
     *   }
     * })
     */
    upsert<T extends TipoIdiomaUpsertArgs>(args: SelectSubset<T, TipoIdiomaUpsertArgs<ExtArgs>>): Prisma__TipoIdiomaClient<$Result.GetResult<Prisma.$TipoIdiomaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TipoIdiomas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoIdiomaCountArgs} args - Arguments to filter TipoIdiomas to count.
     * @example
     * // Count the number of TipoIdiomas
     * const count = await prisma.tipoIdioma.count({
     *   where: {
     *     // ... the filter for the TipoIdiomas we want to count
     *   }
     * })
    **/
    count<T extends TipoIdiomaCountArgs>(
      args?: Subset<T, TipoIdiomaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoIdiomaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoIdioma.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoIdiomaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoIdiomaAggregateArgs>(args: Subset<T, TipoIdiomaAggregateArgs>): Prisma.PrismaPromise<GetTipoIdiomaAggregateType<T>>

    /**
     * Group by TipoIdioma.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoIdiomaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TipoIdiomaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TipoIdiomaGroupByArgs['orderBy'] }
        : { orderBy?: TipoIdiomaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TipoIdiomaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoIdiomaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TipoIdioma model
   */
  readonly fields: TipoIdiomaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TipoIdioma.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TipoIdiomaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessoes<T extends TipoIdioma$sessoesArgs<ExtArgs> = {}>(args?: Subset<T, TipoIdioma$sessoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TipoIdioma model
   */
  interface TipoIdiomaFieldRefs {
    readonly id: FieldRef<"TipoIdioma", 'Int'>
    readonly nome: FieldRef<"TipoIdioma", 'String'>
    readonly ativo: FieldRef<"TipoIdioma", 'Boolean'>
    readonly criadoEm: FieldRef<"TipoIdioma", 'DateTime'>
    readonly atualizadoEm: FieldRef<"TipoIdioma", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TipoIdioma findUnique
   */
  export type TipoIdiomaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoIdioma
     */
    select?: TipoIdiomaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoIdioma
     */
    omit?: TipoIdiomaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoIdiomaInclude<ExtArgs> | null
    /**
     * Filter, which TipoIdioma to fetch.
     */
    where: TipoIdiomaWhereUniqueInput
  }

  /**
   * TipoIdioma findUniqueOrThrow
   */
  export type TipoIdiomaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoIdioma
     */
    select?: TipoIdiomaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoIdioma
     */
    omit?: TipoIdiomaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoIdiomaInclude<ExtArgs> | null
    /**
     * Filter, which TipoIdioma to fetch.
     */
    where: TipoIdiomaWhereUniqueInput
  }

  /**
   * TipoIdioma findFirst
   */
  export type TipoIdiomaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoIdioma
     */
    select?: TipoIdiomaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoIdioma
     */
    omit?: TipoIdiomaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoIdiomaInclude<ExtArgs> | null
    /**
     * Filter, which TipoIdioma to fetch.
     */
    where?: TipoIdiomaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoIdiomas to fetch.
     */
    orderBy?: TipoIdiomaOrderByWithRelationInput | TipoIdiomaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoIdiomas.
     */
    cursor?: TipoIdiomaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoIdiomas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoIdiomas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoIdiomas.
     */
    distinct?: TipoIdiomaScalarFieldEnum | TipoIdiomaScalarFieldEnum[]
  }

  /**
   * TipoIdioma findFirstOrThrow
   */
  export type TipoIdiomaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoIdioma
     */
    select?: TipoIdiomaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoIdioma
     */
    omit?: TipoIdiomaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoIdiomaInclude<ExtArgs> | null
    /**
     * Filter, which TipoIdioma to fetch.
     */
    where?: TipoIdiomaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoIdiomas to fetch.
     */
    orderBy?: TipoIdiomaOrderByWithRelationInput | TipoIdiomaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoIdiomas.
     */
    cursor?: TipoIdiomaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoIdiomas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoIdiomas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoIdiomas.
     */
    distinct?: TipoIdiomaScalarFieldEnum | TipoIdiomaScalarFieldEnum[]
  }

  /**
   * TipoIdioma findMany
   */
  export type TipoIdiomaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoIdioma
     */
    select?: TipoIdiomaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoIdioma
     */
    omit?: TipoIdiomaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoIdiomaInclude<ExtArgs> | null
    /**
     * Filter, which TipoIdiomas to fetch.
     */
    where?: TipoIdiomaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoIdiomas to fetch.
     */
    orderBy?: TipoIdiomaOrderByWithRelationInput | TipoIdiomaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TipoIdiomas.
     */
    cursor?: TipoIdiomaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoIdiomas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoIdiomas.
     */
    skip?: number
    distinct?: TipoIdiomaScalarFieldEnum | TipoIdiomaScalarFieldEnum[]
  }

  /**
   * TipoIdioma create
   */
  export type TipoIdiomaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoIdioma
     */
    select?: TipoIdiomaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoIdioma
     */
    omit?: TipoIdiomaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoIdiomaInclude<ExtArgs> | null
    /**
     * The data needed to create a TipoIdioma.
     */
    data: XOR<TipoIdiomaCreateInput, TipoIdiomaUncheckedCreateInput>
  }

  /**
   * TipoIdioma createMany
   */
  export type TipoIdiomaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TipoIdiomas.
     */
    data: TipoIdiomaCreateManyInput | TipoIdiomaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoIdioma createManyAndReturn
   */
  export type TipoIdiomaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoIdioma
     */
    select?: TipoIdiomaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoIdioma
     */
    omit?: TipoIdiomaOmit<ExtArgs> | null
    /**
     * The data used to create many TipoIdiomas.
     */
    data: TipoIdiomaCreateManyInput | TipoIdiomaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoIdioma update
   */
  export type TipoIdiomaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoIdioma
     */
    select?: TipoIdiomaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoIdioma
     */
    omit?: TipoIdiomaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoIdiomaInclude<ExtArgs> | null
    /**
     * The data needed to update a TipoIdioma.
     */
    data: XOR<TipoIdiomaUpdateInput, TipoIdiomaUncheckedUpdateInput>
    /**
     * Choose, which TipoIdioma to update.
     */
    where: TipoIdiomaWhereUniqueInput
  }

  /**
   * TipoIdioma updateMany
   */
  export type TipoIdiomaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TipoIdiomas.
     */
    data: XOR<TipoIdiomaUpdateManyMutationInput, TipoIdiomaUncheckedUpdateManyInput>
    /**
     * Filter which TipoIdiomas to update
     */
    where?: TipoIdiomaWhereInput
    /**
     * Limit how many TipoIdiomas to update.
     */
    limit?: number
  }

  /**
   * TipoIdioma updateManyAndReturn
   */
  export type TipoIdiomaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoIdioma
     */
    select?: TipoIdiomaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoIdioma
     */
    omit?: TipoIdiomaOmit<ExtArgs> | null
    /**
     * The data used to update TipoIdiomas.
     */
    data: XOR<TipoIdiomaUpdateManyMutationInput, TipoIdiomaUncheckedUpdateManyInput>
    /**
     * Filter which TipoIdiomas to update
     */
    where?: TipoIdiomaWhereInput
    /**
     * Limit how many TipoIdiomas to update.
     */
    limit?: number
  }

  /**
   * TipoIdioma upsert
   */
  export type TipoIdiomaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoIdioma
     */
    select?: TipoIdiomaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoIdioma
     */
    omit?: TipoIdiomaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoIdiomaInclude<ExtArgs> | null
    /**
     * The filter to search for the TipoIdioma to update in case it exists.
     */
    where: TipoIdiomaWhereUniqueInput
    /**
     * In case the TipoIdioma found by the `where` argument doesn't exist, create a new TipoIdioma with this data.
     */
    create: XOR<TipoIdiomaCreateInput, TipoIdiomaUncheckedCreateInput>
    /**
     * In case the TipoIdioma was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TipoIdiomaUpdateInput, TipoIdiomaUncheckedUpdateInput>
  }

  /**
   * TipoIdioma delete
   */
  export type TipoIdiomaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoIdioma
     */
    select?: TipoIdiomaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoIdioma
     */
    omit?: TipoIdiomaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoIdiomaInclude<ExtArgs> | null
    /**
     * Filter which TipoIdioma to delete.
     */
    where: TipoIdiomaWhereUniqueInput
  }

  /**
   * TipoIdioma deleteMany
   */
  export type TipoIdiomaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoIdiomas to delete
     */
    where?: TipoIdiomaWhereInput
    /**
     * Limit how many TipoIdiomas to delete.
     */
    limit?: number
  }

  /**
   * TipoIdioma.sessoes
   */
  export type TipoIdioma$sessoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessao
     */
    select?: SessaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sessao
     */
    omit?: SessaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoInclude<ExtArgs> | null
    where?: SessaoWhereInput
    orderBy?: SessaoOrderByWithRelationInput | SessaoOrderByWithRelationInput[]
    cursor?: SessaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessaoScalarFieldEnum | SessaoScalarFieldEnum[]
  }

  /**
   * TipoIdioma without action
   */
  export type TipoIdiomaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoIdioma
     */
    select?: TipoIdiomaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoIdioma
     */
    omit?: TipoIdiomaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoIdiomaInclude<ExtArgs> | null
  }


  /**
   * Model TipoSessao
   */

  export type AggregateTipoSessao = {
    _count: TipoSessaoCountAggregateOutputType | null
    _avg: TipoSessaoAvgAggregateOutputType | null
    _sum: TipoSessaoSumAggregateOutputType | null
    _min: TipoSessaoMinAggregateOutputType | null
    _max: TipoSessaoMaxAggregateOutputType | null
  }

  export type TipoSessaoAvgAggregateOutputType = {
    id: number | null
  }

  export type TipoSessaoSumAggregateOutputType = {
    id: number | null
  }

  export type TipoSessaoMinAggregateOutputType = {
    id: number | null
    nome: string | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type TipoSessaoMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type TipoSessaoCountAggregateOutputType = {
    id: number
    nome: number
    ativo: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type TipoSessaoAvgAggregateInputType = {
    id?: true
  }

  export type TipoSessaoSumAggregateInputType = {
    id?: true
  }

  export type TipoSessaoMinAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type TipoSessaoMaxAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type TipoSessaoCountAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type TipoSessaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoSessao to aggregate.
     */
    where?: TipoSessaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoSessaos to fetch.
     */
    orderBy?: TipoSessaoOrderByWithRelationInput | TipoSessaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TipoSessaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoSessaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoSessaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TipoSessaos
    **/
    _count?: true | TipoSessaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoSessaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoSessaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoSessaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoSessaoMaxAggregateInputType
  }

  export type GetTipoSessaoAggregateType<T extends TipoSessaoAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoSessao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoSessao[P]>
      : GetScalarType<T[P], AggregateTipoSessao[P]>
  }




  export type TipoSessaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TipoSessaoWhereInput
    orderBy?: TipoSessaoOrderByWithAggregationInput | TipoSessaoOrderByWithAggregationInput[]
    by: TipoSessaoScalarFieldEnum[] | TipoSessaoScalarFieldEnum
    having?: TipoSessaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoSessaoCountAggregateInputType | true
    _avg?: TipoSessaoAvgAggregateInputType
    _sum?: TipoSessaoSumAggregateInputType
    _min?: TipoSessaoMinAggregateInputType
    _max?: TipoSessaoMaxAggregateInputType
  }

  export type TipoSessaoGroupByOutputType = {
    id: number
    nome: string
    ativo: boolean
    criadoEm: Date
    atualizadoEm: Date
    _count: TipoSessaoCountAggregateOutputType | null
    _avg: TipoSessaoAvgAggregateOutputType | null
    _sum: TipoSessaoSumAggregateOutputType | null
    _min: TipoSessaoMinAggregateOutputType | null
    _max: TipoSessaoMaxAggregateOutputType | null
  }

  type GetTipoSessaoGroupByPayload<T extends TipoSessaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TipoSessaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoSessaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoSessaoGroupByOutputType[P]>
            : GetScalarType<T[P], TipoSessaoGroupByOutputType[P]>
        }
      >
    >


  export type TipoSessaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    sessoes?: boolean | TipoSessao$sessoesArgs<ExtArgs>
    _count?: boolean | TipoSessaoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipoSessao"]>

  export type TipoSessaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }, ExtArgs["result"]["tipoSessao"]>

  export type TipoSessaoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }, ExtArgs["result"]["tipoSessao"]>

  export type TipoSessaoSelectScalar = {
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type TipoSessaoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "ativo" | "criadoEm" | "atualizadoEm", ExtArgs["result"]["tipoSessao"]>
  export type TipoSessaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessoes?: boolean | TipoSessao$sessoesArgs<ExtArgs>
    _count?: boolean | TipoSessaoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TipoSessaoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TipoSessaoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TipoSessaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TipoSessao"
    objects: {
      sessoes: Prisma.$SessaoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      ativo: boolean
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["tipoSessao"]>
    composites: {}
  }

  type TipoSessaoGetPayload<S extends boolean | null | undefined | TipoSessaoDefaultArgs> = $Result.GetResult<Prisma.$TipoSessaoPayload, S>

  type TipoSessaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TipoSessaoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TipoSessaoCountAggregateInputType | true
    }

  export interface TipoSessaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TipoSessao'], meta: { name: 'TipoSessao' } }
    /**
     * Find zero or one TipoSessao that matches the filter.
     * @param {TipoSessaoFindUniqueArgs} args - Arguments to find a TipoSessao
     * @example
     * // Get one TipoSessao
     * const tipoSessao = await prisma.tipoSessao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TipoSessaoFindUniqueArgs>(args: SelectSubset<T, TipoSessaoFindUniqueArgs<ExtArgs>>): Prisma__TipoSessaoClient<$Result.GetResult<Prisma.$TipoSessaoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TipoSessao that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TipoSessaoFindUniqueOrThrowArgs} args - Arguments to find a TipoSessao
     * @example
     * // Get one TipoSessao
     * const tipoSessao = await prisma.tipoSessao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TipoSessaoFindUniqueOrThrowArgs>(args: SelectSubset<T, TipoSessaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TipoSessaoClient<$Result.GetResult<Prisma.$TipoSessaoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoSessao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoSessaoFindFirstArgs} args - Arguments to find a TipoSessao
     * @example
     * // Get one TipoSessao
     * const tipoSessao = await prisma.tipoSessao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TipoSessaoFindFirstArgs>(args?: SelectSubset<T, TipoSessaoFindFirstArgs<ExtArgs>>): Prisma__TipoSessaoClient<$Result.GetResult<Prisma.$TipoSessaoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoSessao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoSessaoFindFirstOrThrowArgs} args - Arguments to find a TipoSessao
     * @example
     * // Get one TipoSessao
     * const tipoSessao = await prisma.tipoSessao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TipoSessaoFindFirstOrThrowArgs>(args?: SelectSubset<T, TipoSessaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__TipoSessaoClient<$Result.GetResult<Prisma.$TipoSessaoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TipoSessaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoSessaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoSessaos
     * const tipoSessaos = await prisma.tipoSessao.findMany()
     * 
     * // Get first 10 TipoSessaos
     * const tipoSessaos = await prisma.tipoSessao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipoSessaoWithIdOnly = await prisma.tipoSessao.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TipoSessaoFindManyArgs>(args?: SelectSubset<T, TipoSessaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoSessaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TipoSessao.
     * @param {TipoSessaoCreateArgs} args - Arguments to create a TipoSessao.
     * @example
     * // Create one TipoSessao
     * const TipoSessao = await prisma.tipoSessao.create({
     *   data: {
     *     // ... data to create a TipoSessao
     *   }
     * })
     * 
     */
    create<T extends TipoSessaoCreateArgs>(args: SelectSubset<T, TipoSessaoCreateArgs<ExtArgs>>): Prisma__TipoSessaoClient<$Result.GetResult<Prisma.$TipoSessaoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TipoSessaos.
     * @param {TipoSessaoCreateManyArgs} args - Arguments to create many TipoSessaos.
     * @example
     * // Create many TipoSessaos
     * const tipoSessao = await prisma.tipoSessao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TipoSessaoCreateManyArgs>(args?: SelectSubset<T, TipoSessaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TipoSessaos and returns the data saved in the database.
     * @param {TipoSessaoCreateManyAndReturnArgs} args - Arguments to create many TipoSessaos.
     * @example
     * // Create many TipoSessaos
     * const tipoSessao = await prisma.tipoSessao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TipoSessaos and only return the `id`
     * const tipoSessaoWithIdOnly = await prisma.tipoSessao.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TipoSessaoCreateManyAndReturnArgs>(args?: SelectSubset<T, TipoSessaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoSessaoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TipoSessao.
     * @param {TipoSessaoDeleteArgs} args - Arguments to delete one TipoSessao.
     * @example
     * // Delete one TipoSessao
     * const TipoSessao = await prisma.tipoSessao.delete({
     *   where: {
     *     // ... filter to delete one TipoSessao
     *   }
     * })
     * 
     */
    delete<T extends TipoSessaoDeleteArgs>(args: SelectSubset<T, TipoSessaoDeleteArgs<ExtArgs>>): Prisma__TipoSessaoClient<$Result.GetResult<Prisma.$TipoSessaoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TipoSessao.
     * @param {TipoSessaoUpdateArgs} args - Arguments to update one TipoSessao.
     * @example
     * // Update one TipoSessao
     * const tipoSessao = await prisma.tipoSessao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TipoSessaoUpdateArgs>(args: SelectSubset<T, TipoSessaoUpdateArgs<ExtArgs>>): Prisma__TipoSessaoClient<$Result.GetResult<Prisma.$TipoSessaoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TipoSessaos.
     * @param {TipoSessaoDeleteManyArgs} args - Arguments to filter TipoSessaos to delete.
     * @example
     * // Delete a few TipoSessaos
     * const { count } = await prisma.tipoSessao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TipoSessaoDeleteManyArgs>(args?: SelectSubset<T, TipoSessaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoSessaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoSessaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoSessaos
     * const tipoSessao = await prisma.tipoSessao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TipoSessaoUpdateManyArgs>(args: SelectSubset<T, TipoSessaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoSessaos and returns the data updated in the database.
     * @param {TipoSessaoUpdateManyAndReturnArgs} args - Arguments to update many TipoSessaos.
     * @example
     * // Update many TipoSessaos
     * const tipoSessao = await prisma.tipoSessao.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TipoSessaos and only return the `id`
     * const tipoSessaoWithIdOnly = await prisma.tipoSessao.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TipoSessaoUpdateManyAndReturnArgs>(args: SelectSubset<T, TipoSessaoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoSessaoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TipoSessao.
     * @param {TipoSessaoUpsertArgs} args - Arguments to update or create a TipoSessao.
     * @example
     * // Update or create a TipoSessao
     * const tipoSessao = await prisma.tipoSessao.upsert({
     *   create: {
     *     // ... data to create a TipoSessao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoSessao we want to update
     *   }
     * })
     */
    upsert<T extends TipoSessaoUpsertArgs>(args: SelectSubset<T, TipoSessaoUpsertArgs<ExtArgs>>): Prisma__TipoSessaoClient<$Result.GetResult<Prisma.$TipoSessaoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TipoSessaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoSessaoCountArgs} args - Arguments to filter TipoSessaos to count.
     * @example
     * // Count the number of TipoSessaos
     * const count = await prisma.tipoSessao.count({
     *   where: {
     *     // ... the filter for the TipoSessaos we want to count
     *   }
     * })
    **/
    count<T extends TipoSessaoCountArgs>(
      args?: Subset<T, TipoSessaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoSessaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoSessao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoSessaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoSessaoAggregateArgs>(args: Subset<T, TipoSessaoAggregateArgs>): Prisma.PrismaPromise<GetTipoSessaoAggregateType<T>>

    /**
     * Group by TipoSessao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoSessaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TipoSessaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TipoSessaoGroupByArgs['orderBy'] }
        : { orderBy?: TipoSessaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TipoSessaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoSessaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TipoSessao model
   */
  readonly fields: TipoSessaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TipoSessao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TipoSessaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessoes<T extends TipoSessao$sessoesArgs<ExtArgs> = {}>(args?: Subset<T, TipoSessao$sessoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TipoSessao model
   */
  interface TipoSessaoFieldRefs {
    readonly id: FieldRef<"TipoSessao", 'Int'>
    readonly nome: FieldRef<"TipoSessao", 'String'>
    readonly ativo: FieldRef<"TipoSessao", 'Boolean'>
    readonly criadoEm: FieldRef<"TipoSessao", 'DateTime'>
    readonly atualizadoEm: FieldRef<"TipoSessao", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TipoSessao findUnique
   */
  export type TipoSessaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSessao
     */
    select?: TipoSessaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSessao
     */
    omit?: TipoSessaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoSessaoInclude<ExtArgs> | null
    /**
     * Filter, which TipoSessao to fetch.
     */
    where: TipoSessaoWhereUniqueInput
  }

  /**
   * TipoSessao findUniqueOrThrow
   */
  export type TipoSessaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSessao
     */
    select?: TipoSessaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSessao
     */
    omit?: TipoSessaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoSessaoInclude<ExtArgs> | null
    /**
     * Filter, which TipoSessao to fetch.
     */
    where: TipoSessaoWhereUniqueInput
  }

  /**
   * TipoSessao findFirst
   */
  export type TipoSessaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSessao
     */
    select?: TipoSessaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSessao
     */
    omit?: TipoSessaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoSessaoInclude<ExtArgs> | null
    /**
     * Filter, which TipoSessao to fetch.
     */
    where?: TipoSessaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoSessaos to fetch.
     */
    orderBy?: TipoSessaoOrderByWithRelationInput | TipoSessaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoSessaos.
     */
    cursor?: TipoSessaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoSessaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoSessaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoSessaos.
     */
    distinct?: TipoSessaoScalarFieldEnum | TipoSessaoScalarFieldEnum[]
  }

  /**
   * TipoSessao findFirstOrThrow
   */
  export type TipoSessaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSessao
     */
    select?: TipoSessaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSessao
     */
    omit?: TipoSessaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoSessaoInclude<ExtArgs> | null
    /**
     * Filter, which TipoSessao to fetch.
     */
    where?: TipoSessaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoSessaos to fetch.
     */
    orderBy?: TipoSessaoOrderByWithRelationInput | TipoSessaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoSessaos.
     */
    cursor?: TipoSessaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoSessaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoSessaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoSessaos.
     */
    distinct?: TipoSessaoScalarFieldEnum | TipoSessaoScalarFieldEnum[]
  }

  /**
   * TipoSessao findMany
   */
  export type TipoSessaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSessao
     */
    select?: TipoSessaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSessao
     */
    omit?: TipoSessaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoSessaoInclude<ExtArgs> | null
    /**
     * Filter, which TipoSessaos to fetch.
     */
    where?: TipoSessaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoSessaos to fetch.
     */
    orderBy?: TipoSessaoOrderByWithRelationInput | TipoSessaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TipoSessaos.
     */
    cursor?: TipoSessaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoSessaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoSessaos.
     */
    skip?: number
    distinct?: TipoSessaoScalarFieldEnum | TipoSessaoScalarFieldEnum[]
  }

  /**
   * TipoSessao create
   */
  export type TipoSessaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSessao
     */
    select?: TipoSessaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSessao
     */
    omit?: TipoSessaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoSessaoInclude<ExtArgs> | null
    /**
     * The data needed to create a TipoSessao.
     */
    data: XOR<TipoSessaoCreateInput, TipoSessaoUncheckedCreateInput>
  }

  /**
   * TipoSessao createMany
   */
  export type TipoSessaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TipoSessaos.
     */
    data: TipoSessaoCreateManyInput | TipoSessaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoSessao createManyAndReturn
   */
  export type TipoSessaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSessao
     */
    select?: TipoSessaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSessao
     */
    omit?: TipoSessaoOmit<ExtArgs> | null
    /**
     * The data used to create many TipoSessaos.
     */
    data: TipoSessaoCreateManyInput | TipoSessaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoSessao update
   */
  export type TipoSessaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSessao
     */
    select?: TipoSessaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSessao
     */
    omit?: TipoSessaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoSessaoInclude<ExtArgs> | null
    /**
     * The data needed to update a TipoSessao.
     */
    data: XOR<TipoSessaoUpdateInput, TipoSessaoUncheckedUpdateInput>
    /**
     * Choose, which TipoSessao to update.
     */
    where: TipoSessaoWhereUniqueInput
  }

  /**
   * TipoSessao updateMany
   */
  export type TipoSessaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TipoSessaos.
     */
    data: XOR<TipoSessaoUpdateManyMutationInput, TipoSessaoUncheckedUpdateManyInput>
    /**
     * Filter which TipoSessaos to update
     */
    where?: TipoSessaoWhereInput
    /**
     * Limit how many TipoSessaos to update.
     */
    limit?: number
  }

  /**
   * TipoSessao updateManyAndReturn
   */
  export type TipoSessaoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSessao
     */
    select?: TipoSessaoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSessao
     */
    omit?: TipoSessaoOmit<ExtArgs> | null
    /**
     * The data used to update TipoSessaos.
     */
    data: XOR<TipoSessaoUpdateManyMutationInput, TipoSessaoUncheckedUpdateManyInput>
    /**
     * Filter which TipoSessaos to update
     */
    where?: TipoSessaoWhereInput
    /**
     * Limit how many TipoSessaos to update.
     */
    limit?: number
  }

  /**
   * TipoSessao upsert
   */
  export type TipoSessaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSessao
     */
    select?: TipoSessaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSessao
     */
    omit?: TipoSessaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoSessaoInclude<ExtArgs> | null
    /**
     * The filter to search for the TipoSessao to update in case it exists.
     */
    where: TipoSessaoWhereUniqueInput
    /**
     * In case the TipoSessao found by the `where` argument doesn't exist, create a new TipoSessao with this data.
     */
    create: XOR<TipoSessaoCreateInput, TipoSessaoUncheckedCreateInput>
    /**
     * In case the TipoSessao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TipoSessaoUpdateInput, TipoSessaoUncheckedUpdateInput>
  }

  /**
   * TipoSessao delete
   */
  export type TipoSessaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSessao
     */
    select?: TipoSessaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSessao
     */
    omit?: TipoSessaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoSessaoInclude<ExtArgs> | null
    /**
     * Filter which TipoSessao to delete.
     */
    where: TipoSessaoWhereUniqueInput
  }

  /**
   * TipoSessao deleteMany
   */
  export type TipoSessaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoSessaos to delete
     */
    where?: TipoSessaoWhereInput
    /**
     * Limit how many TipoSessaos to delete.
     */
    limit?: number
  }

  /**
   * TipoSessao.sessoes
   */
  export type TipoSessao$sessoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessao
     */
    select?: SessaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sessao
     */
    omit?: SessaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoInclude<ExtArgs> | null
    where?: SessaoWhereInput
    orderBy?: SessaoOrderByWithRelationInput | SessaoOrderByWithRelationInput[]
    cursor?: SessaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessaoScalarFieldEnum | SessaoScalarFieldEnum[]
  }

  /**
   * TipoSessao without action
   */
  export type TipoSessaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSessao
     */
    select?: TipoSessaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSessao
     */
    omit?: TipoSessaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoSessaoInclude<ExtArgs> | null
  }


  /**
   * Model Sessao
   */

  export type AggregateSessao = {
    _count: SessaoCountAggregateOutputType | null
    _avg: SessaoAvgAggregateOutputType | null
    _sum: SessaoSumAggregateOutputType | null
    _min: SessaoMinAggregateOutputType | null
    _max: SessaoMaxAggregateOutputType | null
  }

  export type SessaoAvgAggregateOutputType = {
    id: number | null
    filmeId: number | null
    salaId: number | null
    tipoSessaoId: number | null
    tipoIdiomaId: number | null
  }

  export type SessaoSumAggregateOutputType = {
    id: number | null
    filmeId: number | null
    salaId: number | null
    tipoSessaoId: number | null
    tipoIdiomaId: number | null
  }

  export type SessaoMinAggregateOutputType = {
    id: number | null
    filmeId: number | null
    salaId: number | null
    tipoSessaoId: number | null
    tipoIdiomaId: number | null
    inicio: Date | null
    fim: Date | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type SessaoMaxAggregateOutputType = {
    id: number | null
    filmeId: number | null
    salaId: number | null
    tipoSessaoId: number | null
    tipoIdiomaId: number | null
    inicio: Date | null
    fim: Date | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type SessaoCountAggregateOutputType = {
    id: number
    filmeId: number
    salaId: number
    tipoSessaoId: number
    tipoIdiomaId: number
    inicio: number
    fim: number
    ativo: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type SessaoAvgAggregateInputType = {
    id?: true
    filmeId?: true
    salaId?: true
    tipoSessaoId?: true
    tipoIdiomaId?: true
  }

  export type SessaoSumAggregateInputType = {
    id?: true
    filmeId?: true
    salaId?: true
    tipoSessaoId?: true
    tipoIdiomaId?: true
  }

  export type SessaoMinAggregateInputType = {
    id?: true
    filmeId?: true
    salaId?: true
    tipoSessaoId?: true
    tipoIdiomaId?: true
    inicio?: true
    fim?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type SessaoMaxAggregateInputType = {
    id?: true
    filmeId?: true
    salaId?: true
    tipoSessaoId?: true
    tipoIdiomaId?: true
    inicio?: true
    fim?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type SessaoCountAggregateInputType = {
    id?: true
    filmeId?: true
    salaId?: true
    tipoSessaoId?: true
    tipoIdiomaId?: true
    inicio?: true
    fim?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type SessaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessao to aggregate.
     */
    where?: SessaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessaos to fetch.
     */
    orderBy?: SessaoOrderByWithRelationInput | SessaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessaos
    **/
    _count?: true | SessaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessaoMaxAggregateInputType
  }

  export type GetSessaoAggregateType<T extends SessaoAggregateArgs> = {
        [P in keyof T & keyof AggregateSessao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessao[P]>
      : GetScalarType<T[P], AggregateSessao[P]>
  }




  export type SessaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessaoWhereInput
    orderBy?: SessaoOrderByWithAggregationInput | SessaoOrderByWithAggregationInput[]
    by: SessaoScalarFieldEnum[] | SessaoScalarFieldEnum
    having?: SessaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessaoCountAggregateInputType | true
    _avg?: SessaoAvgAggregateInputType
    _sum?: SessaoSumAggregateInputType
    _min?: SessaoMinAggregateInputType
    _max?: SessaoMaxAggregateInputType
  }

  export type SessaoGroupByOutputType = {
    id: number
    filmeId: number
    salaId: number
    tipoSessaoId: number
    tipoIdiomaId: number
    inicio: Date
    fim: Date
    ativo: boolean
    criadoEm: Date
    atualizadoEm: Date
    _count: SessaoCountAggregateOutputType | null
    _avg: SessaoAvgAggregateOutputType | null
    _sum: SessaoSumAggregateOutputType | null
    _min: SessaoMinAggregateOutputType | null
    _max: SessaoMaxAggregateOutputType | null
  }

  type GetSessaoGroupByPayload<T extends SessaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessaoGroupByOutputType[P]>
            : GetScalarType<T[P], SessaoGroupByOutputType[P]>
        }
      >
    >


  export type SessaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filmeId?: boolean
    salaId?: boolean
    tipoSessaoId?: boolean
    tipoIdiomaId?: boolean
    inicio?: boolean
    fim?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    filme?: boolean | FilmeDefaultArgs<ExtArgs>
    sala?: boolean | SalaDefaultArgs<ExtArgs>
    tipoSessao?: boolean | TipoSessaoDefaultArgs<ExtArgs>
    tipoIdioma?: boolean | TipoIdiomaDefaultArgs<ExtArgs>
    sessoesAssentos?: boolean | Sessao$sessoesAssentosArgs<ExtArgs>
    _count?: boolean | SessaoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessao"]>

  export type SessaoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filmeId?: boolean
    salaId?: boolean
    tipoSessaoId?: boolean
    tipoIdiomaId?: boolean
    inicio?: boolean
    fim?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    filme?: boolean | FilmeDefaultArgs<ExtArgs>
    sala?: boolean | SalaDefaultArgs<ExtArgs>
    tipoSessao?: boolean | TipoSessaoDefaultArgs<ExtArgs>
    tipoIdioma?: boolean | TipoIdiomaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessao"]>

  export type SessaoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filmeId?: boolean
    salaId?: boolean
    tipoSessaoId?: boolean
    tipoIdiomaId?: boolean
    inicio?: boolean
    fim?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    filme?: boolean | FilmeDefaultArgs<ExtArgs>
    sala?: boolean | SalaDefaultArgs<ExtArgs>
    tipoSessao?: boolean | TipoSessaoDefaultArgs<ExtArgs>
    tipoIdioma?: boolean | TipoIdiomaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessao"]>

  export type SessaoSelectScalar = {
    id?: boolean
    filmeId?: boolean
    salaId?: boolean
    tipoSessaoId?: boolean
    tipoIdiomaId?: boolean
    inicio?: boolean
    fim?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type SessaoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "filmeId" | "salaId" | "tipoSessaoId" | "tipoIdiomaId" | "inicio" | "fim" | "ativo" | "criadoEm" | "atualizadoEm", ExtArgs["result"]["sessao"]>
  export type SessaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filme?: boolean | FilmeDefaultArgs<ExtArgs>
    sala?: boolean | SalaDefaultArgs<ExtArgs>
    tipoSessao?: boolean | TipoSessaoDefaultArgs<ExtArgs>
    tipoIdioma?: boolean | TipoIdiomaDefaultArgs<ExtArgs>
    sessoesAssentos?: boolean | Sessao$sessoesAssentosArgs<ExtArgs>
    _count?: boolean | SessaoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SessaoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filme?: boolean | FilmeDefaultArgs<ExtArgs>
    sala?: boolean | SalaDefaultArgs<ExtArgs>
    tipoSessao?: boolean | TipoSessaoDefaultArgs<ExtArgs>
    tipoIdioma?: boolean | TipoIdiomaDefaultArgs<ExtArgs>
  }
  export type SessaoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    filme?: boolean | FilmeDefaultArgs<ExtArgs>
    sala?: boolean | SalaDefaultArgs<ExtArgs>
    tipoSessao?: boolean | TipoSessaoDefaultArgs<ExtArgs>
    tipoIdioma?: boolean | TipoIdiomaDefaultArgs<ExtArgs>
  }

  export type $SessaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sessao"
    objects: {
      filme: Prisma.$FilmePayload<ExtArgs>
      sala: Prisma.$SalaPayload<ExtArgs>
      tipoSessao: Prisma.$TipoSessaoPayload<ExtArgs>
      tipoIdioma: Prisma.$TipoIdiomaPayload<ExtArgs>
      sessoesAssentos: Prisma.$SessaoAssentoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      filmeId: number
      salaId: number
      tipoSessaoId: number
      tipoIdiomaId: number
      inicio: Date
      fim: Date
      ativo: boolean
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["sessao"]>
    composites: {}
  }

  type SessaoGetPayload<S extends boolean | null | undefined | SessaoDefaultArgs> = $Result.GetResult<Prisma.$SessaoPayload, S>

  type SessaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessaoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessaoCountAggregateInputType | true
    }

  export interface SessaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sessao'], meta: { name: 'Sessao' } }
    /**
     * Find zero or one Sessao that matches the filter.
     * @param {SessaoFindUniqueArgs} args - Arguments to find a Sessao
     * @example
     * // Get one Sessao
     * const sessao = await prisma.sessao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessaoFindUniqueArgs>(args: SelectSubset<T, SessaoFindUniqueArgs<ExtArgs>>): Prisma__SessaoClient<$Result.GetResult<Prisma.$SessaoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sessao that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessaoFindUniqueOrThrowArgs} args - Arguments to find a Sessao
     * @example
     * // Get one Sessao
     * const sessao = await prisma.sessao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessaoFindUniqueOrThrowArgs>(args: SelectSubset<T, SessaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessaoClient<$Result.GetResult<Prisma.$SessaoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessaoFindFirstArgs} args - Arguments to find a Sessao
     * @example
     * // Get one Sessao
     * const sessao = await prisma.sessao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessaoFindFirstArgs>(args?: SelectSubset<T, SessaoFindFirstArgs<ExtArgs>>): Prisma__SessaoClient<$Result.GetResult<Prisma.$SessaoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessaoFindFirstOrThrowArgs} args - Arguments to find a Sessao
     * @example
     * // Get one Sessao
     * const sessao = await prisma.sessao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessaoFindFirstOrThrowArgs>(args?: SelectSubset<T, SessaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessaoClient<$Result.GetResult<Prisma.$SessaoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessaos
     * const sessaos = await prisma.sessao.findMany()
     * 
     * // Get first 10 Sessaos
     * const sessaos = await prisma.sessao.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessaoWithIdOnly = await prisma.sessao.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessaoFindManyArgs>(args?: SelectSubset<T, SessaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sessao.
     * @param {SessaoCreateArgs} args - Arguments to create a Sessao.
     * @example
     * // Create one Sessao
     * const Sessao = await prisma.sessao.create({
     *   data: {
     *     // ... data to create a Sessao
     *   }
     * })
     * 
     */
    create<T extends SessaoCreateArgs>(args: SelectSubset<T, SessaoCreateArgs<ExtArgs>>): Prisma__SessaoClient<$Result.GetResult<Prisma.$SessaoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessaos.
     * @param {SessaoCreateManyArgs} args - Arguments to create many Sessaos.
     * @example
     * // Create many Sessaos
     * const sessao = await prisma.sessao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessaoCreateManyArgs>(args?: SelectSubset<T, SessaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessaos and returns the data saved in the database.
     * @param {SessaoCreateManyAndReturnArgs} args - Arguments to create many Sessaos.
     * @example
     * // Create many Sessaos
     * const sessao = await prisma.sessao.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessaos and only return the `id`
     * const sessaoWithIdOnly = await prisma.sessao.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessaoCreateManyAndReturnArgs>(args?: SelectSubset<T, SessaoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessaoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sessao.
     * @param {SessaoDeleteArgs} args - Arguments to delete one Sessao.
     * @example
     * // Delete one Sessao
     * const Sessao = await prisma.sessao.delete({
     *   where: {
     *     // ... filter to delete one Sessao
     *   }
     * })
     * 
     */
    delete<T extends SessaoDeleteArgs>(args: SelectSubset<T, SessaoDeleteArgs<ExtArgs>>): Prisma__SessaoClient<$Result.GetResult<Prisma.$SessaoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sessao.
     * @param {SessaoUpdateArgs} args - Arguments to update one Sessao.
     * @example
     * // Update one Sessao
     * const sessao = await prisma.sessao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessaoUpdateArgs>(args: SelectSubset<T, SessaoUpdateArgs<ExtArgs>>): Prisma__SessaoClient<$Result.GetResult<Prisma.$SessaoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessaos.
     * @param {SessaoDeleteManyArgs} args - Arguments to filter Sessaos to delete.
     * @example
     * // Delete a few Sessaos
     * const { count } = await prisma.sessao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessaoDeleteManyArgs>(args?: SelectSubset<T, SessaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessaos
     * const sessao = await prisma.sessao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessaoUpdateManyArgs>(args: SelectSubset<T, SessaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessaos and returns the data updated in the database.
     * @param {SessaoUpdateManyAndReturnArgs} args - Arguments to update many Sessaos.
     * @example
     * // Update many Sessaos
     * const sessao = await prisma.sessao.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessaos and only return the `id`
     * const sessaoWithIdOnly = await prisma.sessao.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessaoUpdateManyAndReturnArgs>(args: SelectSubset<T, SessaoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessaoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sessao.
     * @param {SessaoUpsertArgs} args - Arguments to update or create a Sessao.
     * @example
     * // Update or create a Sessao
     * const sessao = await prisma.sessao.upsert({
     *   create: {
     *     // ... data to create a Sessao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sessao we want to update
     *   }
     * })
     */
    upsert<T extends SessaoUpsertArgs>(args: SelectSubset<T, SessaoUpsertArgs<ExtArgs>>): Prisma__SessaoClient<$Result.GetResult<Prisma.$SessaoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessaoCountArgs} args - Arguments to filter Sessaos to count.
     * @example
     * // Count the number of Sessaos
     * const count = await prisma.sessao.count({
     *   where: {
     *     // ... the filter for the Sessaos we want to count
     *   }
     * })
    **/
    count<T extends SessaoCountArgs>(
      args?: Subset<T, SessaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sessao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessaoAggregateArgs>(args: Subset<T, SessaoAggregateArgs>): Prisma.PrismaPromise<GetSessaoAggregateType<T>>

    /**
     * Group by Sessao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessaoGroupByArgs['orderBy'] }
        : { orderBy?: SessaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sessao model
   */
  readonly fields: SessaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sessao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    filme<T extends FilmeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FilmeDefaultArgs<ExtArgs>>): Prisma__FilmeClient<$Result.GetResult<Prisma.$FilmePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sala<T extends SalaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalaDefaultArgs<ExtArgs>>): Prisma__SalaClient<$Result.GetResult<Prisma.$SalaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tipoSessao<T extends TipoSessaoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TipoSessaoDefaultArgs<ExtArgs>>): Prisma__TipoSessaoClient<$Result.GetResult<Prisma.$TipoSessaoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tipoIdioma<T extends TipoIdiomaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TipoIdiomaDefaultArgs<ExtArgs>>): Prisma__TipoIdiomaClient<$Result.GetResult<Prisma.$TipoIdiomaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sessoesAssentos<T extends Sessao$sessoesAssentosArgs<ExtArgs> = {}>(args?: Subset<T, Sessao$sessoesAssentosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessaoAssentoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sessao model
   */
  interface SessaoFieldRefs {
    readonly id: FieldRef<"Sessao", 'Int'>
    readonly filmeId: FieldRef<"Sessao", 'Int'>
    readonly salaId: FieldRef<"Sessao", 'Int'>
    readonly tipoSessaoId: FieldRef<"Sessao", 'Int'>
    readonly tipoIdiomaId: FieldRef<"Sessao", 'Int'>
    readonly inicio: FieldRef<"Sessao", 'DateTime'>
    readonly fim: FieldRef<"Sessao", 'DateTime'>
    readonly ativo: FieldRef<"Sessao", 'Boolean'>
    readonly criadoEm: FieldRef<"Sessao", 'DateTime'>
    readonly atualizadoEm: FieldRef<"Sessao", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sessao findUnique
   */
  export type SessaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessao
     */
    select?: SessaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sessao
     */
    omit?: SessaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoInclude<ExtArgs> | null
    /**
     * Filter, which Sessao to fetch.
     */
    where: SessaoWhereUniqueInput
  }

  /**
   * Sessao findUniqueOrThrow
   */
  export type SessaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessao
     */
    select?: SessaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sessao
     */
    omit?: SessaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoInclude<ExtArgs> | null
    /**
     * Filter, which Sessao to fetch.
     */
    where: SessaoWhereUniqueInput
  }

  /**
   * Sessao findFirst
   */
  export type SessaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessao
     */
    select?: SessaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sessao
     */
    omit?: SessaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoInclude<ExtArgs> | null
    /**
     * Filter, which Sessao to fetch.
     */
    where?: SessaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessaos to fetch.
     */
    orderBy?: SessaoOrderByWithRelationInput | SessaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessaos.
     */
    cursor?: SessaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessaos.
     */
    distinct?: SessaoScalarFieldEnum | SessaoScalarFieldEnum[]
  }

  /**
   * Sessao findFirstOrThrow
   */
  export type SessaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessao
     */
    select?: SessaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sessao
     */
    omit?: SessaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoInclude<ExtArgs> | null
    /**
     * Filter, which Sessao to fetch.
     */
    where?: SessaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessaos to fetch.
     */
    orderBy?: SessaoOrderByWithRelationInput | SessaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessaos.
     */
    cursor?: SessaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessaos.
     */
    distinct?: SessaoScalarFieldEnum | SessaoScalarFieldEnum[]
  }

  /**
   * Sessao findMany
   */
  export type SessaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessao
     */
    select?: SessaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sessao
     */
    omit?: SessaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoInclude<ExtArgs> | null
    /**
     * Filter, which Sessaos to fetch.
     */
    where?: SessaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessaos to fetch.
     */
    orderBy?: SessaoOrderByWithRelationInput | SessaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessaos.
     */
    cursor?: SessaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessaos.
     */
    skip?: number
    distinct?: SessaoScalarFieldEnum | SessaoScalarFieldEnum[]
  }

  /**
   * Sessao create
   */
  export type SessaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessao
     */
    select?: SessaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sessao
     */
    omit?: SessaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoInclude<ExtArgs> | null
    /**
     * The data needed to create a Sessao.
     */
    data: XOR<SessaoCreateInput, SessaoUncheckedCreateInput>
  }

  /**
   * Sessao createMany
   */
  export type SessaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessaos.
     */
    data: SessaoCreateManyInput | SessaoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sessao createManyAndReturn
   */
  export type SessaoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessao
     */
    select?: SessaoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sessao
     */
    omit?: SessaoOmit<ExtArgs> | null
    /**
     * The data used to create many Sessaos.
     */
    data: SessaoCreateManyInput | SessaoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sessao update
   */
  export type SessaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessao
     */
    select?: SessaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sessao
     */
    omit?: SessaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoInclude<ExtArgs> | null
    /**
     * The data needed to update a Sessao.
     */
    data: XOR<SessaoUpdateInput, SessaoUncheckedUpdateInput>
    /**
     * Choose, which Sessao to update.
     */
    where: SessaoWhereUniqueInput
  }

  /**
   * Sessao updateMany
   */
  export type SessaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessaos.
     */
    data: XOR<SessaoUpdateManyMutationInput, SessaoUncheckedUpdateManyInput>
    /**
     * Filter which Sessaos to update
     */
    where?: SessaoWhereInput
    /**
     * Limit how many Sessaos to update.
     */
    limit?: number
  }

  /**
   * Sessao updateManyAndReturn
   */
  export type SessaoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessao
     */
    select?: SessaoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sessao
     */
    omit?: SessaoOmit<ExtArgs> | null
    /**
     * The data used to update Sessaos.
     */
    data: XOR<SessaoUpdateManyMutationInput, SessaoUncheckedUpdateManyInput>
    /**
     * Filter which Sessaos to update
     */
    where?: SessaoWhereInput
    /**
     * Limit how many Sessaos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sessao upsert
   */
  export type SessaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessao
     */
    select?: SessaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sessao
     */
    omit?: SessaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoInclude<ExtArgs> | null
    /**
     * The filter to search for the Sessao to update in case it exists.
     */
    where: SessaoWhereUniqueInput
    /**
     * In case the Sessao found by the `where` argument doesn't exist, create a new Sessao with this data.
     */
    create: XOR<SessaoCreateInput, SessaoUncheckedCreateInput>
    /**
     * In case the Sessao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessaoUpdateInput, SessaoUncheckedUpdateInput>
  }

  /**
   * Sessao delete
   */
  export type SessaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessao
     */
    select?: SessaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sessao
     */
    omit?: SessaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoInclude<ExtArgs> | null
    /**
     * Filter which Sessao to delete.
     */
    where: SessaoWhereUniqueInput
  }

  /**
   * Sessao deleteMany
   */
  export type SessaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessaos to delete
     */
    where?: SessaoWhereInput
    /**
     * Limit how many Sessaos to delete.
     */
    limit?: number
  }

  /**
   * Sessao.sessoesAssentos
   */
  export type Sessao$sessoesAssentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessaoAssento
     */
    select?: SessaoAssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessaoAssento
     */
    omit?: SessaoAssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoAssentoInclude<ExtArgs> | null
    where?: SessaoAssentoWhereInput
    orderBy?: SessaoAssentoOrderByWithRelationInput | SessaoAssentoOrderByWithRelationInput[]
    cursor?: SessaoAssentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessaoAssentoScalarFieldEnum | SessaoAssentoScalarFieldEnum[]
  }

  /**
   * Sessao without action
   */
  export type SessaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessao
     */
    select?: SessaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sessao
     */
    omit?: SessaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoInclude<ExtArgs> | null
  }


  /**
   * Model TipoSala
   */

  export type AggregateTipoSala = {
    _count: TipoSalaCountAggregateOutputType | null
    _avg: TipoSalaAvgAggregateOutputType | null
    _sum: TipoSalaSumAggregateOutputType | null
    _min: TipoSalaMinAggregateOutputType | null
    _max: TipoSalaMaxAggregateOutputType | null
  }

  export type TipoSalaAvgAggregateOutputType = {
    id: number | null
  }

  export type TipoSalaSumAggregateOutputType = {
    id: number | null
  }

  export type TipoSalaMinAggregateOutputType = {
    id: number | null
    nome: string | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type TipoSalaMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type TipoSalaCountAggregateOutputType = {
    id: number
    nome: number
    ativo: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type TipoSalaAvgAggregateInputType = {
    id?: true
  }

  export type TipoSalaSumAggregateInputType = {
    id?: true
  }

  export type TipoSalaMinAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type TipoSalaMaxAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type TipoSalaCountAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type TipoSalaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoSala to aggregate.
     */
    where?: TipoSalaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoSalas to fetch.
     */
    orderBy?: TipoSalaOrderByWithRelationInput | TipoSalaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TipoSalaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoSalas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoSalas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TipoSalas
    **/
    _count?: true | TipoSalaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoSalaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoSalaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoSalaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoSalaMaxAggregateInputType
  }

  export type GetTipoSalaAggregateType<T extends TipoSalaAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoSala]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoSala[P]>
      : GetScalarType<T[P], AggregateTipoSala[P]>
  }




  export type TipoSalaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TipoSalaWhereInput
    orderBy?: TipoSalaOrderByWithAggregationInput | TipoSalaOrderByWithAggregationInput[]
    by: TipoSalaScalarFieldEnum[] | TipoSalaScalarFieldEnum
    having?: TipoSalaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoSalaCountAggregateInputType | true
    _avg?: TipoSalaAvgAggregateInputType
    _sum?: TipoSalaSumAggregateInputType
    _min?: TipoSalaMinAggregateInputType
    _max?: TipoSalaMaxAggregateInputType
  }

  export type TipoSalaGroupByOutputType = {
    id: number
    nome: string
    ativo: boolean
    criadoEm: Date
    atualizadoEm: Date
    _count: TipoSalaCountAggregateOutputType | null
    _avg: TipoSalaAvgAggregateOutputType | null
    _sum: TipoSalaSumAggregateOutputType | null
    _min: TipoSalaMinAggregateOutputType | null
    _max: TipoSalaMaxAggregateOutputType | null
  }

  type GetTipoSalaGroupByPayload<T extends TipoSalaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TipoSalaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoSalaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoSalaGroupByOutputType[P]>
            : GetScalarType<T[P], TipoSalaGroupByOutputType[P]>
        }
      >
    >


  export type TipoSalaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    salas?: boolean | TipoSala$salasArgs<ExtArgs>
    _count?: boolean | TipoSalaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipoSala"]>

  export type TipoSalaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }, ExtArgs["result"]["tipoSala"]>

  export type TipoSalaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }, ExtArgs["result"]["tipoSala"]>

  export type TipoSalaSelectScalar = {
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type TipoSalaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "ativo" | "criadoEm" | "atualizadoEm", ExtArgs["result"]["tipoSala"]>
  export type TipoSalaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salas?: boolean | TipoSala$salasArgs<ExtArgs>
    _count?: boolean | TipoSalaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TipoSalaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TipoSalaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TipoSalaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TipoSala"
    objects: {
      salas: Prisma.$SalaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      ativo: boolean
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["tipoSala"]>
    composites: {}
  }

  type TipoSalaGetPayload<S extends boolean | null | undefined | TipoSalaDefaultArgs> = $Result.GetResult<Prisma.$TipoSalaPayload, S>

  type TipoSalaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TipoSalaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TipoSalaCountAggregateInputType | true
    }

  export interface TipoSalaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TipoSala'], meta: { name: 'TipoSala' } }
    /**
     * Find zero or one TipoSala that matches the filter.
     * @param {TipoSalaFindUniqueArgs} args - Arguments to find a TipoSala
     * @example
     * // Get one TipoSala
     * const tipoSala = await prisma.tipoSala.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TipoSalaFindUniqueArgs>(args: SelectSubset<T, TipoSalaFindUniqueArgs<ExtArgs>>): Prisma__TipoSalaClient<$Result.GetResult<Prisma.$TipoSalaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TipoSala that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TipoSalaFindUniqueOrThrowArgs} args - Arguments to find a TipoSala
     * @example
     * // Get one TipoSala
     * const tipoSala = await prisma.tipoSala.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TipoSalaFindUniqueOrThrowArgs>(args: SelectSubset<T, TipoSalaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TipoSalaClient<$Result.GetResult<Prisma.$TipoSalaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoSala that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoSalaFindFirstArgs} args - Arguments to find a TipoSala
     * @example
     * // Get one TipoSala
     * const tipoSala = await prisma.tipoSala.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TipoSalaFindFirstArgs>(args?: SelectSubset<T, TipoSalaFindFirstArgs<ExtArgs>>): Prisma__TipoSalaClient<$Result.GetResult<Prisma.$TipoSalaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoSala that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoSalaFindFirstOrThrowArgs} args - Arguments to find a TipoSala
     * @example
     * // Get one TipoSala
     * const tipoSala = await prisma.tipoSala.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TipoSalaFindFirstOrThrowArgs>(args?: SelectSubset<T, TipoSalaFindFirstOrThrowArgs<ExtArgs>>): Prisma__TipoSalaClient<$Result.GetResult<Prisma.$TipoSalaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TipoSalas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoSalaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoSalas
     * const tipoSalas = await prisma.tipoSala.findMany()
     * 
     * // Get first 10 TipoSalas
     * const tipoSalas = await prisma.tipoSala.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipoSalaWithIdOnly = await prisma.tipoSala.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TipoSalaFindManyArgs>(args?: SelectSubset<T, TipoSalaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoSalaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TipoSala.
     * @param {TipoSalaCreateArgs} args - Arguments to create a TipoSala.
     * @example
     * // Create one TipoSala
     * const TipoSala = await prisma.tipoSala.create({
     *   data: {
     *     // ... data to create a TipoSala
     *   }
     * })
     * 
     */
    create<T extends TipoSalaCreateArgs>(args: SelectSubset<T, TipoSalaCreateArgs<ExtArgs>>): Prisma__TipoSalaClient<$Result.GetResult<Prisma.$TipoSalaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TipoSalas.
     * @param {TipoSalaCreateManyArgs} args - Arguments to create many TipoSalas.
     * @example
     * // Create many TipoSalas
     * const tipoSala = await prisma.tipoSala.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TipoSalaCreateManyArgs>(args?: SelectSubset<T, TipoSalaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TipoSalas and returns the data saved in the database.
     * @param {TipoSalaCreateManyAndReturnArgs} args - Arguments to create many TipoSalas.
     * @example
     * // Create many TipoSalas
     * const tipoSala = await prisma.tipoSala.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TipoSalas and only return the `id`
     * const tipoSalaWithIdOnly = await prisma.tipoSala.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TipoSalaCreateManyAndReturnArgs>(args?: SelectSubset<T, TipoSalaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoSalaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TipoSala.
     * @param {TipoSalaDeleteArgs} args - Arguments to delete one TipoSala.
     * @example
     * // Delete one TipoSala
     * const TipoSala = await prisma.tipoSala.delete({
     *   where: {
     *     // ... filter to delete one TipoSala
     *   }
     * })
     * 
     */
    delete<T extends TipoSalaDeleteArgs>(args: SelectSubset<T, TipoSalaDeleteArgs<ExtArgs>>): Prisma__TipoSalaClient<$Result.GetResult<Prisma.$TipoSalaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TipoSala.
     * @param {TipoSalaUpdateArgs} args - Arguments to update one TipoSala.
     * @example
     * // Update one TipoSala
     * const tipoSala = await prisma.tipoSala.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TipoSalaUpdateArgs>(args: SelectSubset<T, TipoSalaUpdateArgs<ExtArgs>>): Prisma__TipoSalaClient<$Result.GetResult<Prisma.$TipoSalaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TipoSalas.
     * @param {TipoSalaDeleteManyArgs} args - Arguments to filter TipoSalas to delete.
     * @example
     * // Delete a few TipoSalas
     * const { count } = await prisma.tipoSala.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TipoSalaDeleteManyArgs>(args?: SelectSubset<T, TipoSalaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoSalas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoSalaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoSalas
     * const tipoSala = await prisma.tipoSala.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TipoSalaUpdateManyArgs>(args: SelectSubset<T, TipoSalaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoSalas and returns the data updated in the database.
     * @param {TipoSalaUpdateManyAndReturnArgs} args - Arguments to update many TipoSalas.
     * @example
     * // Update many TipoSalas
     * const tipoSala = await prisma.tipoSala.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TipoSalas and only return the `id`
     * const tipoSalaWithIdOnly = await prisma.tipoSala.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TipoSalaUpdateManyAndReturnArgs>(args: SelectSubset<T, TipoSalaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoSalaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TipoSala.
     * @param {TipoSalaUpsertArgs} args - Arguments to update or create a TipoSala.
     * @example
     * // Update or create a TipoSala
     * const tipoSala = await prisma.tipoSala.upsert({
     *   create: {
     *     // ... data to create a TipoSala
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoSala we want to update
     *   }
     * })
     */
    upsert<T extends TipoSalaUpsertArgs>(args: SelectSubset<T, TipoSalaUpsertArgs<ExtArgs>>): Prisma__TipoSalaClient<$Result.GetResult<Prisma.$TipoSalaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TipoSalas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoSalaCountArgs} args - Arguments to filter TipoSalas to count.
     * @example
     * // Count the number of TipoSalas
     * const count = await prisma.tipoSala.count({
     *   where: {
     *     // ... the filter for the TipoSalas we want to count
     *   }
     * })
    **/
    count<T extends TipoSalaCountArgs>(
      args?: Subset<T, TipoSalaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoSalaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoSala.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoSalaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoSalaAggregateArgs>(args: Subset<T, TipoSalaAggregateArgs>): Prisma.PrismaPromise<GetTipoSalaAggregateType<T>>

    /**
     * Group by TipoSala.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoSalaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TipoSalaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TipoSalaGroupByArgs['orderBy'] }
        : { orderBy?: TipoSalaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TipoSalaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoSalaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TipoSala model
   */
  readonly fields: TipoSalaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TipoSala.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TipoSalaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    salas<T extends TipoSala$salasArgs<ExtArgs> = {}>(args?: Subset<T, TipoSala$salasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TipoSala model
   */
  interface TipoSalaFieldRefs {
    readonly id: FieldRef<"TipoSala", 'Int'>
    readonly nome: FieldRef<"TipoSala", 'String'>
    readonly ativo: FieldRef<"TipoSala", 'Boolean'>
    readonly criadoEm: FieldRef<"TipoSala", 'DateTime'>
    readonly atualizadoEm: FieldRef<"TipoSala", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TipoSala findUnique
   */
  export type TipoSalaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSala
     */
    select?: TipoSalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSala
     */
    omit?: TipoSalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoSalaInclude<ExtArgs> | null
    /**
     * Filter, which TipoSala to fetch.
     */
    where: TipoSalaWhereUniqueInput
  }

  /**
   * TipoSala findUniqueOrThrow
   */
  export type TipoSalaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSala
     */
    select?: TipoSalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSala
     */
    omit?: TipoSalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoSalaInclude<ExtArgs> | null
    /**
     * Filter, which TipoSala to fetch.
     */
    where: TipoSalaWhereUniqueInput
  }

  /**
   * TipoSala findFirst
   */
  export type TipoSalaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSala
     */
    select?: TipoSalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSala
     */
    omit?: TipoSalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoSalaInclude<ExtArgs> | null
    /**
     * Filter, which TipoSala to fetch.
     */
    where?: TipoSalaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoSalas to fetch.
     */
    orderBy?: TipoSalaOrderByWithRelationInput | TipoSalaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoSalas.
     */
    cursor?: TipoSalaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoSalas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoSalas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoSalas.
     */
    distinct?: TipoSalaScalarFieldEnum | TipoSalaScalarFieldEnum[]
  }

  /**
   * TipoSala findFirstOrThrow
   */
  export type TipoSalaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSala
     */
    select?: TipoSalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSala
     */
    omit?: TipoSalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoSalaInclude<ExtArgs> | null
    /**
     * Filter, which TipoSala to fetch.
     */
    where?: TipoSalaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoSalas to fetch.
     */
    orderBy?: TipoSalaOrderByWithRelationInput | TipoSalaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoSalas.
     */
    cursor?: TipoSalaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoSalas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoSalas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoSalas.
     */
    distinct?: TipoSalaScalarFieldEnum | TipoSalaScalarFieldEnum[]
  }

  /**
   * TipoSala findMany
   */
  export type TipoSalaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSala
     */
    select?: TipoSalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSala
     */
    omit?: TipoSalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoSalaInclude<ExtArgs> | null
    /**
     * Filter, which TipoSalas to fetch.
     */
    where?: TipoSalaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoSalas to fetch.
     */
    orderBy?: TipoSalaOrderByWithRelationInput | TipoSalaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TipoSalas.
     */
    cursor?: TipoSalaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoSalas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoSalas.
     */
    skip?: number
    distinct?: TipoSalaScalarFieldEnum | TipoSalaScalarFieldEnum[]
  }

  /**
   * TipoSala create
   */
  export type TipoSalaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSala
     */
    select?: TipoSalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSala
     */
    omit?: TipoSalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoSalaInclude<ExtArgs> | null
    /**
     * The data needed to create a TipoSala.
     */
    data: XOR<TipoSalaCreateInput, TipoSalaUncheckedCreateInput>
  }

  /**
   * TipoSala createMany
   */
  export type TipoSalaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TipoSalas.
     */
    data: TipoSalaCreateManyInput | TipoSalaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoSala createManyAndReturn
   */
  export type TipoSalaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSala
     */
    select?: TipoSalaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSala
     */
    omit?: TipoSalaOmit<ExtArgs> | null
    /**
     * The data used to create many TipoSalas.
     */
    data: TipoSalaCreateManyInput | TipoSalaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoSala update
   */
  export type TipoSalaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSala
     */
    select?: TipoSalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSala
     */
    omit?: TipoSalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoSalaInclude<ExtArgs> | null
    /**
     * The data needed to update a TipoSala.
     */
    data: XOR<TipoSalaUpdateInput, TipoSalaUncheckedUpdateInput>
    /**
     * Choose, which TipoSala to update.
     */
    where: TipoSalaWhereUniqueInput
  }

  /**
   * TipoSala updateMany
   */
  export type TipoSalaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TipoSalas.
     */
    data: XOR<TipoSalaUpdateManyMutationInput, TipoSalaUncheckedUpdateManyInput>
    /**
     * Filter which TipoSalas to update
     */
    where?: TipoSalaWhereInput
    /**
     * Limit how many TipoSalas to update.
     */
    limit?: number
  }

  /**
   * TipoSala updateManyAndReturn
   */
  export type TipoSalaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSala
     */
    select?: TipoSalaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSala
     */
    omit?: TipoSalaOmit<ExtArgs> | null
    /**
     * The data used to update TipoSalas.
     */
    data: XOR<TipoSalaUpdateManyMutationInput, TipoSalaUncheckedUpdateManyInput>
    /**
     * Filter which TipoSalas to update
     */
    where?: TipoSalaWhereInput
    /**
     * Limit how many TipoSalas to update.
     */
    limit?: number
  }

  /**
   * TipoSala upsert
   */
  export type TipoSalaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSala
     */
    select?: TipoSalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSala
     */
    omit?: TipoSalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoSalaInclude<ExtArgs> | null
    /**
     * The filter to search for the TipoSala to update in case it exists.
     */
    where: TipoSalaWhereUniqueInput
    /**
     * In case the TipoSala found by the `where` argument doesn't exist, create a new TipoSala with this data.
     */
    create: XOR<TipoSalaCreateInput, TipoSalaUncheckedCreateInput>
    /**
     * In case the TipoSala was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TipoSalaUpdateInput, TipoSalaUncheckedUpdateInput>
  }

  /**
   * TipoSala delete
   */
  export type TipoSalaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSala
     */
    select?: TipoSalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSala
     */
    omit?: TipoSalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoSalaInclude<ExtArgs> | null
    /**
     * Filter which TipoSala to delete.
     */
    where: TipoSalaWhereUniqueInput
  }

  /**
   * TipoSala deleteMany
   */
  export type TipoSalaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoSalas to delete
     */
    where?: TipoSalaWhereInput
    /**
     * Limit how many TipoSalas to delete.
     */
    limit?: number
  }

  /**
   * TipoSala.salas
   */
  export type TipoSala$salasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sala
     */
    select?: SalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sala
     */
    omit?: SalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaInclude<ExtArgs> | null
    where?: SalaWhereInput
    orderBy?: SalaOrderByWithRelationInput | SalaOrderByWithRelationInput[]
    cursor?: SalaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalaScalarFieldEnum | SalaScalarFieldEnum[]
  }

  /**
   * TipoSala without action
   */
  export type TipoSalaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoSala
     */
    select?: TipoSalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoSala
     */
    omit?: TipoSalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoSalaInclude<ExtArgs> | null
  }


  /**
   * Model Sala
   */

  export type AggregateSala = {
    _count: SalaCountAggregateOutputType | null
    _avg: SalaAvgAggregateOutputType | null
    _sum: SalaSumAggregateOutputType | null
    _min: SalaMinAggregateOutputType | null
    _max: SalaMaxAggregateOutputType | null
  }

  export type SalaAvgAggregateOutputType = {
    id: number | null
    tipoSalaId: number | null
  }

  export type SalaSumAggregateOutputType = {
    id: number | null
    tipoSalaId: number | null
  }

  export type SalaMinAggregateOutputType = {
    id: number | null
    tipoSalaId: number | null
    nome: string | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type SalaMaxAggregateOutputType = {
    id: number | null
    tipoSalaId: number | null
    nome: string | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type SalaCountAggregateOutputType = {
    id: number
    tipoSalaId: number
    nome: number
    ativo: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type SalaAvgAggregateInputType = {
    id?: true
    tipoSalaId?: true
  }

  export type SalaSumAggregateInputType = {
    id?: true
    tipoSalaId?: true
  }

  export type SalaMinAggregateInputType = {
    id?: true
    tipoSalaId?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type SalaMaxAggregateInputType = {
    id?: true
    tipoSalaId?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type SalaCountAggregateInputType = {
    id?: true
    tipoSalaId?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type SalaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sala to aggregate.
     */
    where?: SalaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salas to fetch.
     */
    orderBy?: SalaOrderByWithRelationInput | SalaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Salas
    **/
    _count?: true | SalaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalaMaxAggregateInputType
  }

  export type GetSalaAggregateType<T extends SalaAggregateArgs> = {
        [P in keyof T & keyof AggregateSala]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSala[P]>
      : GetScalarType<T[P], AggregateSala[P]>
  }




  export type SalaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaWhereInput
    orderBy?: SalaOrderByWithAggregationInput | SalaOrderByWithAggregationInput[]
    by: SalaScalarFieldEnum[] | SalaScalarFieldEnum
    having?: SalaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalaCountAggregateInputType | true
    _avg?: SalaAvgAggregateInputType
    _sum?: SalaSumAggregateInputType
    _min?: SalaMinAggregateInputType
    _max?: SalaMaxAggregateInputType
  }

  export type SalaGroupByOutputType = {
    id: number
    tipoSalaId: number
    nome: string
    ativo: boolean
    criadoEm: Date
    atualizadoEm: Date
    _count: SalaCountAggregateOutputType | null
    _avg: SalaAvgAggregateOutputType | null
    _sum: SalaSumAggregateOutputType | null
    _min: SalaMinAggregateOutputType | null
    _max: SalaMaxAggregateOutputType | null
  }

  type GetSalaGroupByPayload<T extends SalaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalaGroupByOutputType[P]>
            : GetScalarType<T[P], SalaGroupByOutputType[P]>
        }
      >
    >


  export type SalaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipoSalaId?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    tipoSala?: boolean | TipoSalaDefaultArgs<ExtArgs>
    sessoes?: boolean | Sala$sessoesArgs<ExtArgs>
    assentos?: boolean | Sala$assentosArgs<ExtArgs>
    _count?: boolean | SalaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sala"]>

  export type SalaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipoSalaId?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    tipoSala?: boolean | TipoSalaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sala"]>

  export type SalaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipoSalaId?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    tipoSala?: boolean | TipoSalaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sala"]>

  export type SalaSelectScalar = {
    id?: boolean
    tipoSalaId?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type SalaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tipoSalaId" | "nome" | "ativo" | "criadoEm" | "atualizadoEm", ExtArgs["result"]["sala"]>
  export type SalaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tipoSala?: boolean | TipoSalaDefaultArgs<ExtArgs>
    sessoes?: boolean | Sala$sessoesArgs<ExtArgs>
    assentos?: boolean | Sala$assentosArgs<ExtArgs>
    _count?: boolean | SalaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SalaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tipoSala?: boolean | TipoSalaDefaultArgs<ExtArgs>
  }
  export type SalaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tipoSala?: boolean | TipoSalaDefaultArgs<ExtArgs>
  }

  export type $SalaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sala"
    objects: {
      tipoSala: Prisma.$TipoSalaPayload<ExtArgs>
      sessoes: Prisma.$SessaoPayload<ExtArgs>[]
      assentos: Prisma.$AssentoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tipoSalaId: number
      nome: string
      ativo: boolean
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["sala"]>
    composites: {}
  }

  type SalaGetPayload<S extends boolean | null | undefined | SalaDefaultArgs> = $Result.GetResult<Prisma.$SalaPayload, S>

  type SalaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalaCountAggregateInputType | true
    }

  export interface SalaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sala'], meta: { name: 'Sala' } }
    /**
     * Find zero or one Sala that matches the filter.
     * @param {SalaFindUniqueArgs} args - Arguments to find a Sala
     * @example
     * // Get one Sala
     * const sala = await prisma.sala.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalaFindUniqueArgs>(args: SelectSubset<T, SalaFindUniqueArgs<ExtArgs>>): Prisma__SalaClient<$Result.GetResult<Prisma.$SalaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sala that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalaFindUniqueOrThrowArgs} args - Arguments to find a Sala
     * @example
     * // Get one Sala
     * const sala = await prisma.sala.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalaFindUniqueOrThrowArgs>(args: SelectSubset<T, SalaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalaClient<$Result.GetResult<Prisma.$SalaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sala that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaFindFirstArgs} args - Arguments to find a Sala
     * @example
     * // Get one Sala
     * const sala = await prisma.sala.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalaFindFirstArgs>(args?: SelectSubset<T, SalaFindFirstArgs<ExtArgs>>): Prisma__SalaClient<$Result.GetResult<Prisma.$SalaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sala that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaFindFirstOrThrowArgs} args - Arguments to find a Sala
     * @example
     * // Get one Sala
     * const sala = await prisma.sala.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalaFindFirstOrThrowArgs>(args?: SelectSubset<T, SalaFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalaClient<$Result.GetResult<Prisma.$SalaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Salas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Salas
     * const salas = await prisma.sala.findMany()
     * 
     * // Get first 10 Salas
     * const salas = await prisma.sala.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salaWithIdOnly = await prisma.sala.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalaFindManyArgs>(args?: SelectSubset<T, SalaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sala.
     * @param {SalaCreateArgs} args - Arguments to create a Sala.
     * @example
     * // Create one Sala
     * const Sala = await prisma.sala.create({
     *   data: {
     *     // ... data to create a Sala
     *   }
     * })
     * 
     */
    create<T extends SalaCreateArgs>(args: SelectSubset<T, SalaCreateArgs<ExtArgs>>): Prisma__SalaClient<$Result.GetResult<Prisma.$SalaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Salas.
     * @param {SalaCreateManyArgs} args - Arguments to create many Salas.
     * @example
     * // Create many Salas
     * const sala = await prisma.sala.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalaCreateManyArgs>(args?: SelectSubset<T, SalaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Salas and returns the data saved in the database.
     * @param {SalaCreateManyAndReturnArgs} args - Arguments to create many Salas.
     * @example
     * // Create many Salas
     * const sala = await prisma.sala.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Salas and only return the `id`
     * const salaWithIdOnly = await prisma.sala.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalaCreateManyAndReturnArgs>(args?: SelectSubset<T, SalaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sala.
     * @param {SalaDeleteArgs} args - Arguments to delete one Sala.
     * @example
     * // Delete one Sala
     * const Sala = await prisma.sala.delete({
     *   where: {
     *     // ... filter to delete one Sala
     *   }
     * })
     * 
     */
    delete<T extends SalaDeleteArgs>(args: SelectSubset<T, SalaDeleteArgs<ExtArgs>>): Prisma__SalaClient<$Result.GetResult<Prisma.$SalaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sala.
     * @param {SalaUpdateArgs} args - Arguments to update one Sala.
     * @example
     * // Update one Sala
     * const sala = await prisma.sala.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalaUpdateArgs>(args: SelectSubset<T, SalaUpdateArgs<ExtArgs>>): Prisma__SalaClient<$Result.GetResult<Prisma.$SalaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Salas.
     * @param {SalaDeleteManyArgs} args - Arguments to filter Salas to delete.
     * @example
     * // Delete a few Salas
     * const { count } = await prisma.sala.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalaDeleteManyArgs>(args?: SelectSubset<T, SalaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Salas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Salas
     * const sala = await prisma.sala.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalaUpdateManyArgs>(args: SelectSubset<T, SalaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Salas and returns the data updated in the database.
     * @param {SalaUpdateManyAndReturnArgs} args - Arguments to update many Salas.
     * @example
     * // Update many Salas
     * const sala = await prisma.sala.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Salas and only return the `id`
     * const salaWithIdOnly = await prisma.sala.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalaUpdateManyAndReturnArgs>(args: SelectSubset<T, SalaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sala.
     * @param {SalaUpsertArgs} args - Arguments to update or create a Sala.
     * @example
     * // Update or create a Sala
     * const sala = await prisma.sala.upsert({
     *   create: {
     *     // ... data to create a Sala
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sala we want to update
     *   }
     * })
     */
    upsert<T extends SalaUpsertArgs>(args: SelectSubset<T, SalaUpsertArgs<ExtArgs>>): Prisma__SalaClient<$Result.GetResult<Prisma.$SalaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Salas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaCountArgs} args - Arguments to filter Salas to count.
     * @example
     * // Count the number of Salas
     * const count = await prisma.sala.count({
     *   where: {
     *     // ... the filter for the Salas we want to count
     *   }
     * })
    **/
    count<T extends SalaCountArgs>(
      args?: Subset<T, SalaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sala.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalaAggregateArgs>(args: Subset<T, SalaAggregateArgs>): Prisma.PrismaPromise<GetSalaAggregateType<T>>

    /**
     * Group by Sala.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalaGroupByArgs['orderBy'] }
        : { orderBy?: SalaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sala model
   */
  readonly fields: SalaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sala.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tipoSala<T extends TipoSalaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TipoSalaDefaultArgs<ExtArgs>>): Prisma__TipoSalaClient<$Result.GetResult<Prisma.$TipoSalaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sessoes<T extends Sala$sessoesArgs<ExtArgs> = {}>(args?: Subset<T, Sala$sessoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessaoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assentos<T extends Sala$assentosArgs<ExtArgs> = {}>(args?: Subset<T, Sala$assentosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssentoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sala model
   */
  interface SalaFieldRefs {
    readonly id: FieldRef<"Sala", 'Int'>
    readonly tipoSalaId: FieldRef<"Sala", 'Int'>
    readonly nome: FieldRef<"Sala", 'String'>
    readonly ativo: FieldRef<"Sala", 'Boolean'>
    readonly criadoEm: FieldRef<"Sala", 'DateTime'>
    readonly atualizadoEm: FieldRef<"Sala", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sala findUnique
   */
  export type SalaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sala
     */
    select?: SalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sala
     */
    omit?: SalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaInclude<ExtArgs> | null
    /**
     * Filter, which Sala to fetch.
     */
    where: SalaWhereUniqueInput
  }

  /**
   * Sala findUniqueOrThrow
   */
  export type SalaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sala
     */
    select?: SalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sala
     */
    omit?: SalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaInclude<ExtArgs> | null
    /**
     * Filter, which Sala to fetch.
     */
    where: SalaWhereUniqueInput
  }

  /**
   * Sala findFirst
   */
  export type SalaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sala
     */
    select?: SalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sala
     */
    omit?: SalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaInclude<ExtArgs> | null
    /**
     * Filter, which Sala to fetch.
     */
    where?: SalaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salas to fetch.
     */
    orderBy?: SalaOrderByWithRelationInput | SalaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Salas.
     */
    cursor?: SalaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Salas.
     */
    distinct?: SalaScalarFieldEnum | SalaScalarFieldEnum[]
  }

  /**
   * Sala findFirstOrThrow
   */
  export type SalaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sala
     */
    select?: SalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sala
     */
    omit?: SalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaInclude<ExtArgs> | null
    /**
     * Filter, which Sala to fetch.
     */
    where?: SalaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salas to fetch.
     */
    orderBy?: SalaOrderByWithRelationInput | SalaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Salas.
     */
    cursor?: SalaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Salas.
     */
    distinct?: SalaScalarFieldEnum | SalaScalarFieldEnum[]
  }

  /**
   * Sala findMany
   */
  export type SalaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sala
     */
    select?: SalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sala
     */
    omit?: SalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaInclude<ExtArgs> | null
    /**
     * Filter, which Salas to fetch.
     */
    where?: SalaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salas to fetch.
     */
    orderBy?: SalaOrderByWithRelationInput | SalaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Salas.
     */
    cursor?: SalaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salas.
     */
    skip?: number
    distinct?: SalaScalarFieldEnum | SalaScalarFieldEnum[]
  }

  /**
   * Sala create
   */
  export type SalaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sala
     */
    select?: SalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sala
     */
    omit?: SalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaInclude<ExtArgs> | null
    /**
     * The data needed to create a Sala.
     */
    data: XOR<SalaCreateInput, SalaUncheckedCreateInput>
  }

  /**
   * Sala createMany
   */
  export type SalaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Salas.
     */
    data: SalaCreateManyInput | SalaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sala createManyAndReturn
   */
  export type SalaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sala
     */
    select?: SalaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sala
     */
    omit?: SalaOmit<ExtArgs> | null
    /**
     * The data used to create many Salas.
     */
    data: SalaCreateManyInput | SalaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sala update
   */
  export type SalaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sala
     */
    select?: SalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sala
     */
    omit?: SalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaInclude<ExtArgs> | null
    /**
     * The data needed to update a Sala.
     */
    data: XOR<SalaUpdateInput, SalaUncheckedUpdateInput>
    /**
     * Choose, which Sala to update.
     */
    where: SalaWhereUniqueInput
  }

  /**
   * Sala updateMany
   */
  export type SalaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Salas.
     */
    data: XOR<SalaUpdateManyMutationInput, SalaUncheckedUpdateManyInput>
    /**
     * Filter which Salas to update
     */
    where?: SalaWhereInput
    /**
     * Limit how many Salas to update.
     */
    limit?: number
  }

  /**
   * Sala updateManyAndReturn
   */
  export type SalaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sala
     */
    select?: SalaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sala
     */
    omit?: SalaOmit<ExtArgs> | null
    /**
     * The data used to update Salas.
     */
    data: XOR<SalaUpdateManyMutationInput, SalaUncheckedUpdateManyInput>
    /**
     * Filter which Salas to update
     */
    where?: SalaWhereInput
    /**
     * Limit how many Salas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sala upsert
   */
  export type SalaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sala
     */
    select?: SalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sala
     */
    omit?: SalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaInclude<ExtArgs> | null
    /**
     * The filter to search for the Sala to update in case it exists.
     */
    where: SalaWhereUniqueInput
    /**
     * In case the Sala found by the `where` argument doesn't exist, create a new Sala with this data.
     */
    create: XOR<SalaCreateInput, SalaUncheckedCreateInput>
    /**
     * In case the Sala was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalaUpdateInput, SalaUncheckedUpdateInput>
  }

  /**
   * Sala delete
   */
  export type SalaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sala
     */
    select?: SalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sala
     */
    omit?: SalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaInclude<ExtArgs> | null
    /**
     * Filter which Sala to delete.
     */
    where: SalaWhereUniqueInput
  }

  /**
   * Sala deleteMany
   */
  export type SalaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Salas to delete
     */
    where?: SalaWhereInput
    /**
     * Limit how many Salas to delete.
     */
    limit?: number
  }

  /**
   * Sala.sessoes
   */
  export type Sala$sessoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sessao
     */
    select?: SessaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sessao
     */
    omit?: SessaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoInclude<ExtArgs> | null
    where?: SessaoWhereInput
    orderBy?: SessaoOrderByWithRelationInput | SessaoOrderByWithRelationInput[]
    cursor?: SessaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessaoScalarFieldEnum | SessaoScalarFieldEnum[]
  }

  /**
   * Sala.assentos
   */
  export type Sala$assentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assento
     */
    select?: AssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assento
     */
    omit?: AssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssentoInclude<ExtArgs> | null
    where?: AssentoWhereInput
    orderBy?: AssentoOrderByWithRelationInput | AssentoOrderByWithRelationInput[]
    cursor?: AssentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssentoScalarFieldEnum | AssentoScalarFieldEnum[]
  }

  /**
   * Sala without action
   */
  export type SalaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sala
     */
    select?: SalaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sala
     */
    omit?: SalaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaInclude<ExtArgs> | null
  }


  /**
   * Model TipoAssento
   */

  export type AggregateTipoAssento = {
    _count: TipoAssentoCountAggregateOutputType | null
    _avg: TipoAssentoAvgAggregateOutputType | null
    _sum: TipoAssentoSumAggregateOutputType | null
    _min: TipoAssentoMinAggregateOutputType | null
    _max: TipoAssentoMaxAggregateOutputType | null
  }

  export type TipoAssentoAvgAggregateOutputType = {
    id: number | null
  }

  export type TipoAssentoSumAggregateOutputType = {
    id: number | null
  }

  export type TipoAssentoMinAggregateOutputType = {
    id: number | null
    nome: string | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type TipoAssentoMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type TipoAssentoCountAggregateOutputType = {
    id: number
    nome: number
    ativo: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type TipoAssentoAvgAggregateInputType = {
    id?: true
  }

  export type TipoAssentoSumAggregateInputType = {
    id?: true
  }

  export type TipoAssentoMinAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type TipoAssentoMaxAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type TipoAssentoCountAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type TipoAssentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoAssento to aggregate.
     */
    where?: TipoAssentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoAssentos to fetch.
     */
    orderBy?: TipoAssentoOrderByWithRelationInput | TipoAssentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TipoAssentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoAssentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoAssentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TipoAssentos
    **/
    _count?: true | TipoAssentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoAssentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoAssentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoAssentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoAssentoMaxAggregateInputType
  }

  export type GetTipoAssentoAggregateType<T extends TipoAssentoAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoAssento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoAssento[P]>
      : GetScalarType<T[P], AggregateTipoAssento[P]>
  }




  export type TipoAssentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TipoAssentoWhereInput
    orderBy?: TipoAssentoOrderByWithAggregationInput | TipoAssentoOrderByWithAggregationInput[]
    by: TipoAssentoScalarFieldEnum[] | TipoAssentoScalarFieldEnum
    having?: TipoAssentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoAssentoCountAggregateInputType | true
    _avg?: TipoAssentoAvgAggregateInputType
    _sum?: TipoAssentoSumAggregateInputType
    _min?: TipoAssentoMinAggregateInputType
    _max?: TipoAssentoMaxAggregateInputType
  }

  export type TipoAssentoGroupByOutputType = {
    id: number
    nome: string
    ativo: boolean
    criadoEm: Date
    atualizadoEm: Date
    _count: TipoAssentoCountAggregateOutputType | null
    _avg: TipoAssentoAvgAggregateOutputType | null
    _sum: TipoAssentoSumAggregateOutputType | null
    _min: TipoAssentoMinAggregateOutputType | null
    _max: TipoAssentoMaxAggregateOutputType | null
  }

  type GetTipoAssentoGroupByPayload<T extends TipoAssentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TipoAssentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoAssentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoAssentoGroupByOutputType[P]>
            : GetScalarType<T[P], TipoAssentoGroupByOutputType[P]>
        }
      >
    >


  export type TipoAssentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    assentos?: boolean | TipoAssento$assentosArgs<ExtArgs>
    _count?: boolean | TipoAssentoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipoAssento"]>

  export type TipoAssentoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }, ExtArgs["result"]["tipoAssento"]>

  export type TipoAssentoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }, ExtArgs["result"]["tipoAssento"]>

  export type TipoAssentoSelectScalar = {
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type TipoAssentoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "ativo" | "criadoEm" | "atualizadoEm", ExtArgs["result"]["tipoAssento"]>
  export type TipoAssentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assentos?: boolean | TipoAssento$assentosArgs<ExtArgs>
    _count?: boolean | TipoAssentoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TipoAssentoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TipoAssentoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TipoAssentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TipoAssento"
    objects: {
      assentos: Prisma.$AssentoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      ativo: boolean
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["tipoAssento"]>
    composites: {}
  }

  type TipoAssentoGetPayload<S extends boolean | null | undefined | TipoAssentoDefaultArgs> = $Result.GetResult<Prisma.$TipoAssentoPayload, S>

  type TipoAssentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TipoAssentoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TipoAssentoCountAggregateInputType | true
    }

  export interface TipoAssentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TipoAssento'], meta: { name: 'TipoAssento' } }
    /**
     * Find zero or one TipoAssento that matches the filter.
     * @param {TipoAssentoFindUniqueArgs} args - Arguments to find a TipoAssento
     * @example
     * // Get one TipoAssento
     * const tipoAssento = await prisma.tipoAssento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TipoAssentoFindUniqueArgs>(args: SelectSubset<T, TipoAssentoFindUniqueArgs<ExtArgs>>): Prisma__TipoAssentoClient<$Result.GetResult<Prisma.$TipoAssentoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TipoAssento that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TipoAssentoFindUniqueOrThrowArgs} args - Arguments to find a TipoAssento
     * @example
     * // Get one TipoAssento
     * const tipoAssento = await prisma.tipoAssento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TipoAssentoFindUniqueOrThrowArgs>(args: SelectSubset<T, TipoAssentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TipoAssentoClient<$Result.GetResult<Prisma.$TipoAssentoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoAssento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoAssentoFindFirstArgs} args - Arguments to find a TipoAssento
     * @example
     * // Get one TipoAssento
     * const tipoAssento = await prisma.tipoAssento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TipoAssentoFindFirstArgs>(args?: SelectSubset<T, TipoAssentoFindFirstArgs<ExtArgs>>): Prisma__TipoAssentoClient<$Result.GetResult<Prisma.$TipoAssentoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoAssento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoAssentoFindFirstOrThrowArgs} args - Arguments to find a TipoAssento
     * @example
     * // Get one TipoAssento
     * const tipoAssento = await prisma.tipoAssento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TipoAssentoFindFirstOrThrowArgs>(args?: SelectSubset<T, TipoAssentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__TipoAssentoClient<$Result.GetResult<Prisma.$TipoAssentoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TipoAssentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoAssentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoAssentos
     * const tipoAssentos = await prisma.tipoAssento.findMany()
     * 
     * // Get first 10 TipoAssentos
     * const tipoAssentos = await prisma.tipoAssento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipoAssentoWithIdOnly = await prisma.tipoAssento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TipoAssentoFindManyArgs>(args?: SelectSubset<T, TipoAssentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoAssentoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TipoAssento.
     * @param {TipoAssentoCreateArgs} args - Arguments to create a TipoAssento.
     * @example
     * // Create one TipoAssento
     * const TipoAssento = await prisma.tipoAssento.create({
     *   data: {
     *     // ... data to create a TipoAssento
     *   }
     * })
     * 
     */
    create<T extends TipoAssentoCreateArgs>(args: SelectSubset<T, TipoAssentoCreateArgs<ExtArgs>>): Prisma__TipoAssentoClient<$Result.GetResult<Prisma.$TipoAssentoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TipoAssentos.
     * @param {TipoAssentoCreateManyArgs} args - Arguments to create many TipoAssentos.
     * @example
     * // Create many TipoAssentos
     * const tipoAssento = await prisma.tipoAssento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TipoAssentoCreateManyArgs>(args?: SelectSubset<T, TipoAssentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TipoAssentos and returns the data saved in the database.
     * @param {TipoAssentoCreateManyAndReturnArgs} args - Arguments to create many TipoAssentos.
     * @example
     * // Create many TipoAssentos
     * const tipoAssento = await prisma.tipoAssento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TipoAssentos and only return the `id`
     * const tipoAssentoWithIdOnly = await prisma.tipoAssento.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TipoAssentoCreateManyAndReturnArgs>(args?: SelectSubset<T, TipoAssentoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoAssentoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TipoAssento.
     * @param {TipoAssentoDeleteArgs} args - Arguments to delete one TipoAssento.
     * @example
     * // Delete one TipoAssento
     * const TipoAssento = await prisma.tipoAssento.delete({
     *   where: {
     *     // ... filter to delete one TipoAssento
     *   }
     * })
     * 
     */
    delete<T extends TipoAssentoDeleteArgs>(args: SelectSubset<T, TipoAssentoDeleteArgs<ExtArgs>>): Prisma__TipoAssentoClient<$Result.GetResult<Prisma.$TipoAssentoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TipoAssento.
     * @param {TipoAssentoUpdateArgs} args - Arguments to update one TipoAssento.
     * @example
     * // Update one TipoAssento
     * const tipoAssento = await prisma.tipoAssento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TipoAssentoUpdateArgs>(args: SelectSubset<T, TipoAssentoUpdateArgs<ExtArgs>>): Prisma__TipoAssentoClient<$Result.GetResult<Prisma.$TipoAssentoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TipoAssentos.
     * @param {TipoAssentoDeleteManyArgs} args - Arguments to filter TipoAssentos to delete.
     * @example
     * // Delete a few TipoAssentos
     * const { count } = await prisma.tipoAssento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TipoAssentoDeleteManyArgs>(args?: SelectSubset<T, TipoAssentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoAssentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoAssentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoAssentos
     * const tipoAssento = await prisma.tipoAssento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TipoAssentoUpdateManyArgs>(args: SelectSubset<T, TipoAssentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoAssentos and returns the data updated in the database.
     * @param {TipoAssentoUpdateManyAndReturnArgs} args - Arguments to update many TipoAssentos.
     * @example
     * // Update many TipoAssentos
     * const tipoAssento = await prisma.tipoAssento.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TipoAssentos and only return the `id`
     * const tipoAssentoWithIdOnly = await prisma.tipoAssento.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TipoAssentoUpdateManyAndReturnArgs>(args: SelectSubset<T, TipoAssentoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoAssentoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TipoAssento.
     * @param {TipoAssentoUpsertArgs} args - Arguments to update or create a TipoAssento.
     * @example
     * // Update or create a TipoAssento
     * const tipoAssento = await prisma.tipoAssento.upsert({
     *   create: {
     *     // ... data to create a TipoAssento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoAssento we want to update
     *   }
     * })
     */
    upsert<T extends TipoAssentoUpsertArgs>(args: SelectSubset<T, TipoAssentoUpsertArgs<ExtArgs>>): Prisma__TipoAssentoClient<$Result.GetResult<Prisma.$TipoAssentoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TipoAssentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoAssentoCountArgs} args - Arguments to filter TipoAssentos to count.
     * @example
     * // Count the number of TipoAssentos
     * const count = await prisma.tipoAssento.count({
     *   where: {
     *     // ... the filter for the TipoAssentos we want to count
     *   }
     * })
    **/
    count<T extends TipoAssentoCountArgs>(
      args?: Subset<T, TipoAssentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoAssentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoAssento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoAssentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoAssentoAggregateArgs>(args: Subset<T, TipoAssentoAggregateArgs>): Prisma.PrismaPromise<GetTipoAssentoAggregateType<T>>

    /**
     * Group by TipoAssento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoAssentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TipoAssentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TipoAssentoGroupByArgs['orderBy'] }
        : { orderBy?: TipoAssentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TipoAssentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoAssentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TipoAssento model
   */
  readonly fields: TipoAssentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TipoAssento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TipoAssentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assentos<T extends TipoAssento$assentosArgs<ExtArgs> = {}>(args?: Subset<T, TipoAssento$assentosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssentoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TipoAssento model
   */
  interface TipoAssentoFieldRefs {
    readonly id: FieldRef<"TipoAssento", 'Int'>
    readonly nome: FieldRef<"TipoAssento", 'String'>
    readonly ativo: FieldRef<"TipoAssento", 'Boolean'>
    readonly criadoEm: FieldRef<"TipoAssento", 'DateTime'>
    readonly atualizadoEm: FieldRef<"TipoAssento", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TipoAssento findUnique
   */
  export type TipoAssentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAssento
     */
    select?: TipoAssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAssento
     */
    omit?: TipoAssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoAssentoInclude<ExtArgs> | null
    /**
     * Filter, which TipoAssento to fetch.
     */
    where: TipoAssentoWhereUniqueInput
  }

  /**
   * TipoAssento findUniqueOrThrow
   */
  export type TipoAssentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAssento
     */
    select?: TipoAssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAssento
     */
    omit?: TipoAssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoAssentoInclude<ExtArgs> | null
    /**
     * Filter, which TipoAssento to fetch.
     */
    where: TipoAssentoWhereUniqueInput
  }

  /**
   * TipoAssento findFirst
   */
  export type TipoAssentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAssento
     */
    select?: TipoAssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAssento
     */
    omit?: TipoAssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoAssentoInclude<ExtArgs> | null
    /**
     * Filter, which TipoAssento to fetch.
     */
    where?: TipoAssentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoAssentos to fetch.
     */
    orderBy?: TipoAssentoOrderByWithRelationInput | TipoAssentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoAssentos.
     */
    cursor?: TipoAssentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoAssentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoAssentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoAssentos.
     */
    distinct?: TipoAssentoScalarFieldEnum | TipoAssentoScalarFieldEnum[]
  }

  /**
   * TipoAssento findFirstOrThrow
   */
  export type TipoAssentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAssento
     */
    select?: TipoAssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAssento
     */
    omit?: TipoAssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoAssentoInclude<ExtArgs> | null
    /**
     * Filter, which TipoAssento to fetch.
     */
    where?: TipoAssentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoAssentos to fetch.
     */
    orderBy?: TipoAssentoOrderByWithRelationInput | TipoAssentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoAssentos.
     */
    cursor?: TipoAssentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoAssentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoAssentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoAssentos.
     */
    distinct?: TipoAssentoScalarFieldEnum | TipoAssentoScalarFieldEnum[]
  }

  /**
   * TipoAssento findMany
   */
  export type TipoAssentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAssento
     */
    select?: TipoAssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAssento
     */
    omit?: TipoAssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoAssentoInclude<ExtArgs> | null
    /**
     * Filter, which TipoAssentos to fetch.
     */
    where?: TipoAssentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoAssentos to fetch.
     */
    orderBy?: TipoAssentoOrderByWithRelationInput | TipoAssentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TipoAssentos.
     */
    cursor?: TipoAssentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoAssentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoAssentos.
     */
    skip?: number
    distinct?: TipoAssentoScalarFieldEnum | TipoAssentoScalarFieldEnum[]
  }

  /**
   * TipoAssento create
   */
  export type TipoAssentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAssento
     */
    select?: TipoAssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAssento
     */
    omit?: TipoAssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoAssentoInclude<ExtArgs> | null
    /**
     * The data needed to create a TipoAssento.
     */
    data: XOR<TipoAssentoCreateInput, TipoAssentoUncheckedCreateInput>
  }

  /**
   * TipoAssento createMany
   */
  export type TipoAssentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TipoAssentos.
     */
    data: TipoAssentoCreateManyInput | TipoAssentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoAssento createManyAndReturn
   */
  export type TipoAssentoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAssento
     */
    select?: TipoAssentoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAssento
     */
    omit?: TipoAssentoOmit<ExtArgs> | null
    /**
     * The data used to create many TipoAssentos.
     */
    data: TipoAssentoCreateManyInput | TipoAssentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoAssento update
   */
  export type TipoAssentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAssento
     */
    select?: TipoAssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAssento
     */
    omit?: TipoAssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoAssentoInclude<ExtArgs> | null
    /**
     * The data needed to update a TipoAssento.
     */
    data: XOR<TipoAssentoUpdateInput, TipoAssentoUncheckedUpdateInput>
    /**
     * Choose, which TipoAssento to update.
     */
    where: TipoAssentoWhereUniqueInput
  }

  /**
   * TipoAssento updateMany
   */
  export type TipoAssentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TipoAssentos.
     */
    data: XOR<TipoAssentoUpdateManyMutationInput, TipoAssentoUncheckedUpdateManyInput>
    /**
     * Filter which TipoAssentos to update
     */
    where?: TipoAssentoWhereInput
    /**
     * Limit how many TipoAssentos to update.
     */
    limit?: number
  }

  /**
   * TipoAssento updateManyAndReturn
   */
  export type TipoAssentoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAssento
     */
    select?: TipoAssentoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAssento
     */
    omit?: TipoAssentoOmit<ExtArgs> | null
    /**
     * The data used to update TipoAssentos.
     */
    data: XOR<TipoAssentoUpdateManyMutationInput, TipoAssentoUncheckedUpdateManyInput>
    /**
     * Filter which TipoAssentos to update
     */
    where?: TipoAssentoWhereInput
    /**
     * Limit how many TipoAssentos to update.
     */
    limit?: number
  }

  /**
   * TipoAssento upsert
   */
  export type TipoAssentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAssento
     */
    select?: TipoAssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAssento
     */
    omit?: TipoAssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoAssentoInclude<ExtArgs> | null
    /**
     * The filter to search for the TipoAssento to update in case it exists.
     */
    where: TipoAssentoWhereUniqueInput
    /**
     * In case the TipoAssento found by the `where` argument doesn't exist, create a new TipoAssento with this data.
     */
    create: XOR<TipoAssentoCreateInput, TipoAssentoUncheckedCreateInput>
    /**
     * In case the TipoAssento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TipoAssentoUpdateInput, TipoAssentoUncheckedUpdateInput>
  }

  /**
   * TipoAssento delete
   */
  export type TipoAssentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAssento
     */
    select?: TipoAssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAssento
     */
    omit?: TipoAssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoAssentoInclude<ExtArgs> | null
    /**
     * Filter which TipoAssento to delete.
     */
    where: TipoAssentoWhereUniqueInput
  }

  /**
   * TipoAssento deleteMany
   */
  export type TipoAssentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoAssentos to delete
     */
    where?: TipoAssentoWhereInput
    /**
     * Limit how many TipoAssentos to delete.
     */
    limit?: number
  }

  /**
   * TipoAssento.assentos
   */
  export type TipoAssento$assentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assento
     */
    select?: AssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assento
     */
    omit?: AssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssentoInclude<ExtArgs> | null
    where?: AssentoWhereInput
    orderBy?: AssentoOrderByWithRelationInput | AssentoOrderByWithRelationInput[]
    cursor?: AssentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AssentoScalarFieldEnum | AssentoScalarFieldEnum[]
  }

  /**
   * TipoAssento without action
   */
  export type TipoAssentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoAssento
     */
    select?: TipoAssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoAssento
     */
    omit?: TipoAssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoAssentoInclude<ExtArgs> | null
  }


  /**
   * Model Assento
   */

  export type AggregateAssento = {
    _count: AssentoCountAggregateOutputType | null
    _avg: AssentoAvgAggregateOutputType | null
    _sum: AssentoSumAggregateOutputType | null
    _min: AssentoMinAggregateOutputType | null
    _max: AssentoMaxAggregateOutputType | null
  }

  export type AssentoAvgAggregateOutputType = {
    id: number | null
    salaId: number | null
    tipoAssentoId: number | null
    coluna: number | null
  }

  export type AssentoSumAggregateOutputType = {
    id: number | null
    salaId: number | null
    tipoAssentoId: number | null
    coluna: number | null
  }

  export type AssentoMinAggregateOutputType = {
    id: number | null
    salaId: number | null
    tipoAssentoId: number | null
    fileira: string | null
    coluna: number | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type AssentoMaxAggregateOutputType = {
    id: number | null
    salaId: number | null
    tipoAssentoId: number | null
    fileira: string | null
    coluna: number | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type AssentoCountAggregateOutputType = {
    id: number
    salaId: number
    tipoAssentoId: number
    fileira: number
    coluna: number
    ativo: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type AssentoAvgAggregateInputType = {
    id?: true
    salaId?: true
    tipoAssentoId?: true
    coluna?: true
  }

  export type AssentoSumAggregateInputType = {
    id?: true
    salaId?: true
    tipoAssentoId?: true
    coluna?: true
  }

  export type AssentoMinAggregateInputType = {
    id?: true
    salaId?: true
    tipoAssentoId?: true
    fileira?: true
    coluna?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type AssentoMaxAggregateInputType = {
    id?: true
    salaId?: true
    tipoAssentoId?: true
    fileira?: true
    coluna?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type AssentoCountAggregateInputType = {
    id?: true
    salaId?: true
    tipoAssentoId?: true
    fileira?: true
    coluna?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type AssentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assento to aggregate.
     */
    where?: AssentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assentos to fetch.
     */
    orderBy?: AssentoOrderByWithRelationInput | AssentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AssentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Assentos
    **/
    _count?: true | AssentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AssentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AssentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AssentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AssentoMaxAggregateInputType
  }

  export type GetAssentoAggregateType<T extends AssentoAggregateArgs> = {
        [P in keyof T & keyof AggregateAssento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAssento[P]>
      : GetScalarType<T[P], AggregateAssento[P]>
  }




  export type AssentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AssentoWhereInput
    orderBy?: AssentoOrderByWithAggregationInput | AssentoOrderByWithAggregationInput[]
    by: AssentoScalarFieldEnum[] | AssentoScalarFieldEnum
    having?: AssentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AssentoCountAggregateInputType | true
    _avg?: AssentoAvgAggregateInputType
    _sum?: AssentoSumAggregateInputType
    _min?: AssentoMinAggregateInputType
    _max?: AssentoMaxAggregateInputType
  }

  export type AssentoGroupByOutputType = {
    id: number
    salaId: number
    tipoAssentoId: number
    fileira: string
    coluna: number
    ativo: boolean
    criadoEm: Date
    atualizadoEm: Date
    _count: AssentoCountAggregateOutputType | null
    _avg: AssentoAvgAggregateOutputType | null
    _sum: AssentoSumAggregateOutputType | null
    _min: AssentoMinAggregateOutputType | null
    _max: AssentoMaxAggregateOutputType | null
  }

  type GetAssentoGroupByPayload<T extends AssentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AssentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AssentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AssentoGroupByOutputType[P]>
            : GetScalarType<T[P], AssentoGroupByOutputType[P]>
        }
      >
    >


  export type AssentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salaId?: boolean
    tipoAssentoId?: boolean
    fileira?: boolean
    coluna?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    sala?: boolean | SalaDefaultArgs<ExtArgs>
    tipoAssento?: boolean | TipoAssentoDefaultArgs<ExtArgs>
    sessoesAssentos?: boolean | Assento$sessoesAssentosArgs<ExtArgs>
    _count?: boolean | AssentoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assento"]>

  export type AssentoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salaId?: boolean
    tipoAssentoId?: boolean
    fileira?: boolean
    coluna?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    sala?: boolean | SalaDefaultArgs<ExtArgs>
    tipoAssento?: boolean | TipoAssentoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assento"]>

  export type AssentoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salaId?: boolean
    tipoAssentoId?: boolean
    fileira?: boolean
    coluna?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    sala?: boolean | SalaDefaultArgs<ExtArgs>
    tipoAssento?: boolean | TipoAssentoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["assento"]>

  export type AssentoSelectScalar = {
    id?: boolean
    salaId?: boolean
    tipoAssentoId?: boolean
    fileira?: boolean
    coluna?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type AssentoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "salaId" | "tipoAssentoId" | "fileira" | "coluna" | "ativo" | "criadoEm" | "atualizadoEm", ExtArgs["result"]["assento"]>
  export type AssentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sala?: boolean | SalaDefaultArgs<ExtArgs>
    tipoAssento?: boolean | TipoAssentoDefaultArgs<ExtArgs>
    sessoesAssentos?: boolean | Assento$sessoesAssentosArgs<ExtArgs>
    _count?: boolean | AssentoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AssentoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sala?: boolean | SalaDefaultArgs<ExtArgs>
    tipoAssento?: boolean | TipoAssentoDefaultArgs<ExtArgs>
  }
  export type AssentoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sala?: boolean | SalaDefaultArgs<ExtArgs>
    tipoAssento?: boolean | TipoAssentoDefaultArgs<ExtArgs>
  }

  export type $AssentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Assento"
    objects: {
      sala: Prisma.$SalaPayload<ExtArgs>
      tipoAssento: Prisma.$TipoAssentoPayload<ExtArgs>
      sessoesAssentos: Prisma.$SessaoAssentoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      salaId: number
      tipoAssentoId: number
      fileira: string
      coluna: number
      ativo: boolean
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["assento"]>
    composites: {}
  }

  type AssentoGetPayload<S extends boolean | null | undefined | AssentoDefaultArgs> = $Result.GetResult<Prisma.$AssentoPayload, S>

  type AssentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AssentoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AssentoCountAggregateInputType | true
    }

  export interface AssentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Assento'], meta: { name: 'Assento' } }
    /**
     * Find zero or one Assento that matches the filter.
     * @param {AssentoFindUniqueArgs} args - Arguments to find a Assento
     * @example
     * // Get one Assento
     * const assento = await prisma.assento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AssentoFindUniqueArgs>(args: SelectSubset<T, AssentoFindUniqueArgs<ExtArgs>>): Prisma__AssentoClient<$Result.GetResult<Prisma.$AssentoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Assento that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AssentoFindUniqueOrThrowArgs} args - Arguments to find a Assento
     * @example
     * // Get one Assento
     * const assento = await prisma.assento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AssentoFindUniqueOrThrowArgs>(args: SelectSubset<T, AssentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AssentoClient<$Result.GetResult<Prisma.$AssentoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssentoFindFirstArgs} args - Arguments to find a Assento
     * @example
     * // Get one Assento
     * const assento = await prisma.assento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AssentoFindFirstArgs>(args?: SelectSubset<T, AssentoFindFirstArgs<ExtArgs>>): Prisma__AssentoClient<$Result.GetResult<Prisma.$AssentoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Assento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssentoFindFirstOrThrowArgs} args - Arguments to find a Assento
     * @example
     * // Get one Assento
     * const assento = await prisma.assento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AssentoFindFirstOrThrowArgs>(args?: SelectSubset<T, AssentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__AssentoClient<$Result.GetResult<Prisma.$AssentoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Assentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Assentos
     * const assentos = await prisma.assento.findMany()
     * 
     * // Get first 10 Assentos
     * const assentos = await prisma.assento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const assentoWithIdOnly = await prisma.assento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AssentoFindManyArgs>(args?: SelectSubset<T, AssentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssentoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Assento.
     * @param {AssentoCreateArgs} args - Arguments to create a Assento.
     * @example
     * // Create one Assento
     * const Assento = await prisma.assento.create({
     *   data: {
     *     // ... data to create a Assento
     *   }
     * })
     * 
     */
    create<T extends AssentoCreateArgs>(args: SelectSubset<T, AssentoCreateArgs<ExtArgs>>): Prisma__AssentoClient<$Result.GetResult<Prisma.$AssentoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Assentos.
     * @param {AssentoCreateManyArgs} args - Arguments to create many Assentos.
     * @example
     * // Create many Assentos
     * const assento = await prisma.assento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AssentoCreateManyArgs>(args?: SelectSubset<T, AssentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Assentos and returns the data saved in the database.
     * @param {AssentoCreateManyAndReturnArgs} args - Arguments to create many Assentos.
     * @example
     * // Create many Assentos
     * const assento = await prisma.assento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Assentos and only return the `id`
     * const assentoWithIdOnly = await prisma.assento.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AssentoCreateManyAndReturnArgs>(args?: SelectSubset<T, AssentoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssentoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Assento.
     * @param {AssentoDeleteArgs} args - Arguments to delete one Assento.
     * @example
     * // Delete one Assento
     * const Assento = await prisma.assento.delete({
     *   where: {
     *     // ... filter to delete one Assento
     *   }
     * })
     * 
     */
    delete<T extends AssentoDeleteArgs>(args: SelectSubset<T, AssentoDeleteArgs<ExtArgs>>): Prisma__AssentoClient<$Result.GetResult<Prisma.$AssentoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Assento.
     * @param {AssentoUpdateArgs} args - Arguments to update one Assento.
     * @example
     * // Update one Assento
     * const assento = await prisma.assento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AssentoUpdateArgs>(args: SelectSubset<T, AssentoUpdateArgs<ExtArgs>>): Prisma__AssentoClient<$Result.GetResult<Prisma.$AssentoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Assentos.
     * @param {AssentoDeleteManyArgs} args - Arguments to filter Assentos to delete.
     * @example
     * // Delete a few Assentos
     * const { count } = await prisma.assento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AssentoDeleteManyArgs>(args?: SelectSubset<T, AssentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Assentos
     * const assento = await prisma.assento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AssentoUpdateManyArgs>(args: SelectSubset<T, AssentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Assentos and returns the data updated in the database.
     * @param {AssentoUpdateManyAndReturnArgs} args - Arguments to update many Assentos.
     * @example
     * // Update many Assentos
     * const assento = await prisma.assento.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Assentos and only return the `id`
     * const assentoWithIdOnly = await prisma.assento.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AssentoUpdateManyAndReturnArgs>(args: SelectSubset<T, AssentoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AssentoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Assento.
     * @param {AssentoUpsertArgs} args - Arguments to update or create a Assento.
     * @example
     * // Update or create a Assento
     * const assento = await prisma.assento.upsert({
     *   create: {
     *     // ... data to create a Assento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Assento we want to update
     *   }
     * })
     */
    upsert<T extends AssentoUpsertArgs>(args: SelectSubset<T, AssentoUpsertArgs<ExtArgs>>): Prisma__AssentoClient<$Result.GetResult<Prisma.$AssentoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Assentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssentoCountArgs} args - Arguments to filter Assentos to count.
     * @example
     * // Count the number of Assentos
     * const count = await prisma.assento.count({
     *   where: {
     *     // ... the filter for the Assentos we want to count
     *   }
     * })
    **/
    count<T extends AssentoCountArgs>(
      args?: Subset<T, AssentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AssentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Assento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AssentoAggregateArgs>(args: Subset<T, AssentoAggregateArgs>): Prisma.PrismaPromise<GetAssentoAggregateType<T>>

    /**
     * Group by Assento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AssentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AssentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AssentoGroupByArgs['orderBy'] }
        : { orderBy?: AssentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AssentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAssentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Assento model
   */
  readonly fields: AssentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Assento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AssentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sala<T extends SalaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalaDefaultArgs<ExtArgs>>): Prisma__SalaClient<$Result.GetResult<Prisma.$SalaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tipoAssento<T extends TipoAssentoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TipoAssentoDefaultArgs<ExtArgs>>): Prisma__TipoAssentoClient<$Result.GetResult<Prisma.$TipoAssentoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sessoesAssentos<T extends Assento$sessoesAssentosArgs<ExtArgs> = {}>(args?: Subset<T, Assento$sessoesAssentosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessaoAssentoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Assento model
   */
  interface AssentoFieldRefs {
    readonly id: FieldRef<"Assento", 'Int'>
    readonly salaId: FieldRef<"Assento", 'Int'>
    readonly tipoAssentoId: FieldRef<"Assento", 'Int'>
    readonly fileira: FieldRef<"Assento", 'String'>
    readonly coluna: FieldRef<"Assento", 'Int'>
    readonly ativo: FieldRef<"Assento", 'Boolean'>
    readonly criadoEm: FieldRef<"Assento", 'DateTime'>
    readonly atualizadoEm: FieldRef<"Assento", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Assento findUnique
   */
  export type AssentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assento
     */
    select?: AssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assento
     */
    omit?: AssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssentoInclude<ExtArgs> | null
    /**
     * Filter, which Assento to fetch.
     */
    where: AssentoWhereUniqueInput
  }

  /**
   * Assento findUniqueOrThrow
   */
  export type AssentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assento
     */
    select?: AssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assento
     */
    omit?: AssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssentoInclude<ExtArgs> | null
    /**
     * Filter, which Assento to fetch.
     */
    where: AssentoWhereUniqueInput
  }

  /**
   * Assento findFirst
   */
  export type AssentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assento
     */
    select?: AssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assento
     */
    omit?: AssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssentoInclude<ExtArgs> | null
    /**
     * Filter, which Assento to fetch.
     */
    where?: AssentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assentos to fetch.
     */
    orderBy?: AssentoOrderByWithRelationInput | AssentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assentos.
     */
    cursor?: AssentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assentos.
     */
    distinct?: AssentoScalarFieldEnum | AssentoScalarFieldEnum[]
  }

  /**
   * Assento findFirstOrThrow
   */
  export type AssentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assento
     */
    select?: AssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assento
     */
    omit?: AssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssentoInclude<ExtArgs> | null
    /**
     * Filter, which Assento to fetch.
     */
    where?: AssentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assentos to fetch.
     */
    orderBy?: AssentoOrderByWithRelationInput | AssentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Assentos.
     */
    cursor?: AssentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Assentos.
     */
    distinct?: AssentoScalarFieldEnum | AssentoScalarFieldEnum[]
  }

  /**
   * Assento findMany
   */
  export type AssentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assento
     */
    select?: AssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assento
     */
    omit?: AssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssentoInclude<ExtArgs> | null
    /**
     * Filter, which Assentos to fetch.
     */
    where?: AssentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Assentos to fetch.
     */
    orderBy?: AssentoOrderByWithRelationInput | AssentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Assentos.
     */
    cursor?: AssentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Assentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Assentos.
     */
    skip?: number
    distinct?: AssentoScalarFieldEnum | AssentoScalarFieldEnum[]
  }

  /**
   * Assento create
   */
  export type AssentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assento
     */
    select?: AssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assento
     */
    omit?: AssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssentoInclude<ExtArgs> | null
    /**
     * The data needed to create a Assento.
     */
    data: XOR<AssentoCreateInput, AssentoUncheckedCreateInput>
  }

  /**
   * Assento createMany
   */
  export type AssentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Assentos.
     */
    data: AssentoCreateManyInput | AssentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Assento createManyAndReturn
   */
  export type AssentoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assento
     */
    select?: AssentoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Assento
     */
    omit?: AssentoOmit<ExtArgs> | null
    /**
     * The data used to create many Assentos.
     */
    data: AssentoCreateManyInput | AssentoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssentoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Assento update
   */
  export type AssentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assento
     */
    select?: AssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assento
     */
    omit?: AssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssentoInclude<ExtArgs> | null
    /**
     * The data needed to update a Assento.
     */
    data: XOR<AssentoUpdateInput, AssentoUncheckedUpdateInput>
    /**
     * Choose, which Assento to update.
     */
    where: AssentoWhereUniqueInput
  }

  /**
   * Assento updateMany
   */
  export type AssentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Assentos.
     */
    data: XOR<AssentoUpdateManyMutationInput, AssentoUncheckedUpdateManyInput>
    /**
     * Filter which Assentos to update
     */
    where?: AssentoWhereInput
    /**
     * Limit how many Assentos to update.
     */
    limit?: number
  }

  /**
   * Assento updateManyAndReturn
   */
  export type AssentoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assento
     */
    select?: AssentoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Assento
     */
    omit?: AssentoOmit<ExtArgs> | null
    /**
     * The data used to update Assentos.
     */
    data: XOR<AssentoUpdateManyMutationInput, AssentoUncheckedUpdateManyInput>
    /**
     * Filter which Assentos to update
     */
    where?: AssentoWhereInput
    /**
     * Limit how many Assentos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssentoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Assento upsert
   */
  export type AssentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assento
     */
    select?: AssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assento
     */
    omit?: AssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssentoInclude<ExtArgs> | null
    /**
     * The filter to search for the Assento to update in case it exists.
     */
    where: AssentoWhereUniqueInput
    /**
     * In case the Assento found by the `where` argument doesn't exist, create a new Assento with this data.
     */
    create: XOR<AssentoCreateInput, AssentoUncheckedCreateInput>
    /**
     * In case the Assento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AssentoUpdateInput, AssentoUncheckedUpdateInput>
  }

  /**
   * Assento delete
   */
  export type AssentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assento
     */
    select?: AssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assento
     */
    omit?: AssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssentoInclude<ExtArgs> | null
    /**
     * Filter which Assento to delete.
     */
    where: AssentoWhereUniqueInput
  }

  /**
   * Assento deleteMany
   */
  export type AssentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Assentos to delete
     */
    where?: AssentoWhereInput
    /**
     * Limit how many Assentos to delete.
     */
    limit?: number
  }

  /**
   * Assento.sessoesAssentos
   */
  export type Assento$sessoesAssentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessaoAssento
     */
    select?: SessaoAssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessaoAssento
     */
    omit?: SessaoAssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoAssentoInclude<ExtArgs> | null
    where?: SessaoAssentoWhereInput
    orderBy?: SessaoAssentoOrderByWithRelationInput | SessaoAssentoOrderByWithRelationInput[]
    cursor?: SessaoAssentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessaoAssentoScalarFieldEnum | SessaoAssentoScalarFieldEnum[]
  }

  /**
   * Assento without action
   */
  export type AssentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Assento
     */
    select?: AssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Assento
     */
    omit?: AssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AssentoInclude<ExtArgs> | null
  }


  /**
   * Model SessaoAssentoStatus
   */

  export type AggregateSessaoAssentoStatus = {
    _count: SessaoAssentoStatusCountAggregateOutputType | null
    _avg: SessaoAssentoStatusAvgAggregateOutputType | null
    _sum: SessaoAssentoStatusSumAggregateOutputType | null
    _min: SessaoAssentoStatusMinAggregateOutputType | null
    _max: SessaoAssentoStatusMaxAggregateOutputType | null
  }

  export type SessaoAssentoStatusAvgAggregateOutputType = {
    id: number | null
  }

  export type SessaoAssentoStatusSumAggregateOutputType = {
    id: number | null
  }

  export type SessaoAssentoStatusMinAggregateOutputType = {
    id: number | null
    nome: string | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type SessaoAssentoStatusMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type SessaoAssentoStatusCountAggregateOutputType = {
    id: number
    nome: number
    ativo: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type SessaoAssentoStatusAvgAggregateInputType = {
    id?: true
  }

  export type SessaoAssentoStatusSumAggregateInputType = {
    id?: true
  }

  export type SessaoAssentoStatusMinAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type SessaoAssentoStatusMaxAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type SessaoAssentoStatusCountAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type SessaoAssentoStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessaoAssentoStatus to aggregate.
     */
    where?: SessaoAssentoStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessaoAssentoStatuses to fetch.
     */
    orderBy?: SessaoAssentoStatusOrderByWithRelationInput | SessaoAssentoStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessaoAssentoStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessaoAssentoStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessaoAssentoStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessaoAssentoStatuses
    **/
    _count?: true | SessaoAssentoStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessaoAssentoStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessaoAssentoStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessaoAssentoStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessaoAssentoStatusMaxAggregateInputType
  }

  export type GetSessaoAssentoStatusAggregateType<T extends SessaoAssentoStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateSessaoAssentoStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessaoAssentoStatus[P]>
      : GetScalarType<T[P], AggregateSessaoAssentoStatus[P]>
  }




  export type SessaoAssentoStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessaoAssentoStatusWhereInput
    orderBy?: SessaoAssentoStatusOrderByWithAggregationInput | SessaoAssentoStatusOrderByWithAggregationInput[]
    by: SessaoAssentoStatusScalarFieldEnum[] | SessaoAssentoStatusScalarFieldEnum
    having?: SessaoAssentoStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessaoAssentoStatusCountAggregateInputType | true
    _avg?: SessaoAssentoStatusAvgAggregateInputType
    _sum?: SessaoAssentoStatusSumAggregateInputType
    _min?: SessaoAssentoStatusMinAggregateInputType
    _max?: SessaoAssentoStatusMaxAggregateInputType
  }

  export type SessaoAssentoStatusGroupByOutputType = {
    id: number
    nome: string
    ativo: boolean
    criadoEm: Date
    atualizadoEm: Date
    _count: SessaoAssentoStatusCountAggregateOutputType | null
    _avg: SessaoAssentoStatusAvgAggregateOutputType | null
    _sum: SessaoAssentoStatusSumAggregateOutputType | null
    _min: SessaoAssentoStatusMinAggregateOutputType | null
    _max: SessaoAssentoStatusMaxAggregateOutputType | null
  }

  type GetSessaoAssentoStatusGroupByPayload<T extends SessaoAssentoStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessaoAssentoStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessaoAssentoStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessaoAssentoStatusGroupByOutputType[P]>
            : GetScalarType<T[P], SessaoAssentoStatusGroupByOutputType[P]>
        }
      >
    >


  export type SessaoAssentoStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    sessoesAssentos?: boolean | SessaoAssentoStatus$sessoesAssentosArgs<ExtArgs>
    _count?: boolean | SessaoAssentoStatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessaoAssentoStatus"]>

  export type SessaoAssentoStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }, ExtArgs["result"]["sessaoAssentoStatus"]>

  export type SessaoAssentoStatusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }, ExtArgs["result"]["sessaoAssentoStatus"]>

  export type SessaoAssentoStatusSelectScalar = {
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type SessaoAssentoStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "ativo" | "criadoEm" | "atualizadoEm", ExtArgs["result"]["sessaoAssentoStatus"]>
  export type SessaoAssentoStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessoesAssentos?: boolean | SessaoAssentoStatus$sessoesAssentosArgs<ExtArgs>
    _count?: boolean | SessaoAssentoStatusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SessaoAssentoStatusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SessaoAssentoStatusIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SessaoAssentoStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessaoAssentoStatus"
    objects: {
      sessoesAssentos: Prisma.$SessaoAssentoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      ativo: boolean
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["sessaoAssentoStatus"]>
    composites: {}
  }

  type SessaoAssentoStatusGetPayload<S extends boolean | null | undefined | SessaoAssentoStatusDefaultArgs> = $Result.GetResult<Prisma.$SessaoAssentoStatusPayload, S>

  type SessaoAssentoStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessaoAssentoStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessaoAssentoStatusCountAggregateInputType | true
    }

  export interface SessaoAssentoStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessaoAssentoStatus'], meta: { name: 'SessaoAssentoStatus' } }
    /**
     * Find zero or one SessaoAssentoStatus that matches the filter.
     * @param {SessaoAssentoStatusFindUniqueArgs} args - Arguments to find a SessaoAssentoStatus
     * @example
     * // Get one SessaoAssentoStatus
     * const sessaoAssentoStatus = await prisma.sessaoAssentoStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessaoAssentoStatusFindUniqueArgs>(args: SelectSubset<T, SessaoAssentoStatusFindUniqueArgs<ExtArgs>>): Prisma__SessaoAssentoStatusClient<$Result.GetResult<Prisma.$SessaoAssentoStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SessaoAssentoStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessaoAssentoStatusFindUniqueOrThrowArgs} args - Arguments to find a SessaoAssentoStatus
     * @example
     * // Get one SessaoAssentoStatus
     * const sessaoAssentoStatus = await prisma.sessaoAssentoStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessaoAssentoStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, SessaoAssentoStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessaoAssentoStatusClient<$Result.GetResult<Prisma.$SessaoAssentoStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessaoAssentoStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessaoAssentoStatusFindFirstArgs} args - Arguments to find a SessaoAssentoStatus
     * @example
     * // Get one SessaoAssentoStatus
     * const sessaoAssentoStatus = await prisma.sessaoAssentoStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessaoAssentoStatusFindFirstArgs>(args?: SelectSubset<T, SessaoAssentoStatusFindFirstArgs<ExtArgs>>): Prisma__SessaoAssentoStatusClient<$Result.GetResult<Prisma.$SessaoAssentoStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessaoAssentoStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessaoAssentoStatusFindFirstOrThrowArgs} args - Arguments to find a SessaoAssentoStatus
     * @example
     * // Get one SessaoAssentoStatus
     * const sessaoAssentoStatus = await prisma.sessaoAssentoStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessaoAssentoStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, SessaoAssentoStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessaoAssentoStatusClient<$Result.GetResult<Prisma.$SessaoAssentoStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SessaoAssentoStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessaoAssentoStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessaoAssentoStatuses
     * const sessaoAssentoStatuses = await prisma.sessaoAssentoStatus.findMany()
     * 
     * // Get first 10 SessaoAssentoStatuses
     * const sessaoAssentoStatuses = await prisma.sessaoAssentoStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessaoAssentoStatusWithIdOnly = await prisma.sessaoAssentoStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessaoAssentoStatusFindManyArgs>(args?: SelectSubset<T, SessaoAssentoStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessaoAssentoStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SessaoAssentoStatus.
     * @param {SessaoAssentoStatusCreateArgs} args - Arguments to create a SessaoAssentoStatus.
     * @example
     * // Create one SessaoAssentoStatus
     * const SessaoAssentoStatus = await prisma.sessaoAssentoStatus.create({
     *   data: {
     *     // ... data to create a SessaoAssentoStatus
     *   }
     * })
     * 
     */
    create<T extends SessaoAssentoStatusCreateArgs>(args: SelectSubset<T, SessaoAssentoStatusCreateArgs<ExtArgs>>): Prisma__SessaoAssentoStatusClient<$Result.GetResult<Prisma.$SessaoAssentoStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SessaoAssentoStatuses.
     * @param {SessaoAssentoStatusCreateManyArgs} args - Arguments to create many SessaoAssentoStatuses.
     * @example
     * // Create many SessaoAssentoStatuses
     * const sessaoAssentoStatus = await prisma.sessaoAssentoStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessaoAssentoStatusCreateManyArgs>(args?: SelectSubset<T, SessaoAssentoStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessaoAssentoStatuses and returns the data saved in the database.
     * @param {SessaoAssentoStatusCreateManyAndReturnArgs} args - Arguments to create many SessaoAssentoStatuses.
     * @example
     * // Create many SessaoAssentoStatuses
     * const sessaoAssentoStatus = await prisma.sessaoAssentoStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessaoAssentoStatuses and only return the `id`
     * const sessaoAssentoStatusWithIdOnly = await prisma.sessaoAssentoStatus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessaoAssentoStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, SessaoAssentoStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessaoAssentoStatusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SessaoAssentoStatus.
     * @param {SessaoAssentoStatusDeleteArgs} args - Arguments to delete one SessaoAssentoStatus.
     * @example
     * // Delete one SessaoAssentoStatus
     * const SessaoAssentoStatus = await prisma.sessaoAssentoStatus.delete({
     *   where: {
     *     // ... filter to delete one SessaoAssentoStatus
     *   }
     * })
     * 
     */
    delete<T extends SessaoAssentoStatusDeleteArgs>(args: SelectSubset<T, SessaoAssentoStatusDeleteArgs<ExtArgs>>): Prisma__SessaoAssentoStatusClient<$Result.GetResult<Prisma.$SessaoAssentoStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SessaoAssentoStatus.
     * @param {SessaoAssentoStatusUpdateArgs} args - Arguments to update one SessaoAssentoStatus.
     * @example
     * // Update one SessaoAssentoStatus
     * const sessaoAssentoStatus = await prisma.sessaoAssentoStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessaoAssentoStatusUpdateArgs>(args: SelectSubset<T, SessaoAssentoStatusUpdateArgs<ExtArgs>>): Prisma__SessaoAssentoStatusClient<$Result.GetResult<Prisma.$SessaoAssentoStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SessaoAssentoStatuses.
     * @param {SessaoAssentoStatusDeleteManyArgs} args - Arguments to filter SessaoAssentoStatuses to delete.
     * @example
     * // Delete a few SessaoAssentoStatuses
     * const { count } = await prisma.sessaoAssentoStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessaoAssentoStatusDeleteManyArgs>(args?: SelectSubset<T, SessaoAssentoStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessaoAssentoStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessaoAssentoStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessaoAssentoStatuses
     * const sessaoAssentoStatus = await prisma.sessaoAssentoStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessaoAssentoStatusUpdateManyArgs>(args: SelectSubset<T, SessaoAssentoStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessaoAssentoStatuses and returns the data updated in the database.
     * @param {SessaoAssentoStatusUpdateManyAndReturnArgs} args - Arguments to update many SessaoAssentoStatuses.
     * @example
     * // Update many SessaoAssentoStatuses
     * const sessaoAssentoStatus = await prisma.sessaoAssentoStatus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SessaoAssentoStatuses and only return the `id`
     * const sessaoAssentoStatusWithIdOnly = await prisma.sessaoAssentoStatus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessaoAssentoStatusUpdateManyAndReturnArgs>(args: SelectSubset<T, SessaoAssentoStatusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessaoAssentoStatusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SessaoAssentoStatus.
     * @param {SessaoAssentoStatusUpsertArgs} args - Arguments to update or create a SessaoAssentoStatus.
     * @example
     * // Update or create a SessaoAssentoStatus
     * const sessaoAssentoStatus = await prisma.sessaoAssentoStatus.upsert({
     *   create: {
     *     // ... data to create a SessaoAssentoStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessaoAssentoStatus we want to update
     *   }
     * })
     */
    upsert<T extends SessaoAssentoStatusUpsertArgs>(args: SelectSubset<T, SessaoAssentoStatusUpsertArgs<ExtArgs>>): Prisma__SessaoAssentoStatusClient<$Result.GetResult<Prisma.$SessaoAssentoStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SessaoAssentoStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessaoAssentoStatusCountArgs} args - Arguments to filter SessaoAssentoStatuses to count.
     * @example
     * // Count the number of SessaoAssentoStatuses
     * const count = await prisma.sessaoAssentoStatus.count({
     *   where: {
     *     // ... the filter for the SessaoAssentoStatuses we want to count
     *   }
     * })
    **/
    count<T extends SessaoAssentoStatusCountArgs>(
      args?: Subset<T, SessaoAssentoStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessaoAssentoStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessaoAssentoStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessaoAssentoStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessaoAssentoStatusAggregateArgs>(args: Subset<T, SessaoAssentoStatusAggregateArgs>): Prisma.PrismaPromise<GetSessaoAssentoStatusAggregateType<T>>

    /**
     * Group by SessaoAssentoStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessaoAssentoStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessaoAssentoStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessaoAssentoStatusGroupByArgs['orderBy'] }
        : { orderBy?: SessaoAssentoStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessaoAssentoStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessaoAssentoStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessaoAssentoStatus model
   */
  readonly fields: SessaoAssentoStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessaoAssentoStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessaoAssentoStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessoesAssentos<T extends SessaoAssentoStatus$sessoesAssentosArgs<ExtArgs> = {}>(args?: Subset<T, SessaoAssentoStatus$sessoesAssentosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessaoAssentoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessaoAssentoStatus model
   */
  interface SessaoAssentoStatusFieldRefs {
    readonly id: FieldRef<"SessaoAssentoStatus", 'Int'>
    readonly nome: FieldRef<"SessaoAssentoStatus", 'String'>
    readonly ativo: FieldRef<"SessaoAssentoStatus", 'Boolean'>
    readonly criadoEm: FieldRef<"SessaoAssentoStatus", 'DateTime'>
    readonly atualizadoEm: FieldRef<"SessaoAssentoStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SessaoAssentoStatus findUnique
   */
  export type SessaoAssentoStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessaoAssentoStatus
     */
    select?: SessaoAssentoStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessaoAssentoStatus
     */
    omit?: SessaoAssentoStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoAssentoStatusInclude<ExtArgs> | null
    /**
     * Filter, which SessaoAssentoStatus to fetch.
     */
    where: SessaoAssentoStatusWhereUniqueInput
  }

  /**
   * SessaoAssentoStatus findUniqueOrThrow
   */
  export type SessaoAssentoStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessaoAssentoStatus
     */
    select?: SessaoAssentoStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessaoAssentoStatus
     */
    omit?: SessaoAssentoStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoAssentoStatusInclude<ExtArgs> | null
    /**
     * Filter, which SessaoAssentoStatus to fetch.
     */
    where: SessaoAssentoStatusWhereUniqueInput
  }

  /**
   * SessaoAssentoStatus findFirst
   */
  export type SessaoAssentoStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessaoAssentoStatus
     */
    select?: SessaoAssentoStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessaoAssentoStatus
     */
    omit?: SessaoAssentoStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoAssentoStatusInclude<ExtArgs> | null
    /**
     * Filter, which SessaoAssentoStatus to fetch.
     */
    where?: SessaoAssentoStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessaoAssentoStatuses to fetch.
     */
    orderBy?: SessaoAssentoStatusOrderByWithRelationInput | SessaoAssentoStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessaoAssentoStatuses.
     */
    cursor?: SessaoAssentoStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessaoAssentoStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessaoAssentoStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessaoAssentoStatuses.
     */
    distinct?: SessaoAssentoStatusScalarFieldEnum | SessaoAssentoStatusScalarFieldEnum[]
  }

  /**
   * SessaoAssentoStatus findFirstOrThrow
   */
  export type SessaoAssentoStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessaoAssentoStatus
     */
    select?: SessaoAssentoStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessaoAssentoStatus
     */
    omit?: SessaoAssentoStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoAssentoStatusInclude<ExtArgs> | null
    /**
     * Filter, which SessaoAssentoStatus to fetch.
     */
    where?: SessaoAssentoStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessaoAssentoStatuses to fetch.
     */
    orderBy?: SessaoAssentoStatusOrderByWithRelationInput | SessaoAssentoStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessaoAssentoStatuses.
     */
    cursor?: SessaoAssentoStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessaoAssentoStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessaoAssentoStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessaoAssentoStatuses.
     */
    distinct?: SessaoAssentoStatusScalarFieldEnum | SessaoAssentoStatusScalarFieldEnum[]
  }

  /**
   * SessaoAssentoStatus findMany
   */
  export type SessaoAssentoStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessaoAssentoStatus
     */
    select?: SessaoAssentoStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessaoAssentoStatus
     */
    omit?: SessaoAssentoStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoAssentoStatusInclude<ExtArgs> | null
    /**
     * Filter, which SessaoAssentoStatuses to fetch.
     */
    where?: SessaoAssentoStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessaoAssentoStatuses to fetch.
     */
    orderBy?: SessaoAssentoStatusOrderByWithRelationInput | SessaoAssentoStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessaoAssentoStatuses.
     */
    cursor?: SessaoAssentoStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessaoAssentoStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessaoAssentoStatuses.
     */
    skip?: number
    distinct?: SessaoAssentoStatusScalarFieldEnum | SessaoAssentoStatusScalarFieldEnum[]
  }

  /**
   * SessaoAssentoStatus create
   */
  export type SessaoAssentoStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessaoAssentoStatus
     */
    select?: SessaoAssentoStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessaoAssentoStatus
     */
    omit?: SessaoAssentoStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoAssentoStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a SessaoAssentoStatus.
     */
    data: XOR<SessaoAssentoStatusCreateInput, SessaoAssentoStatusUncheckedCreateInput>
  }

  /**
   * SessaoAssentoStatus createMany
   */
  export type SessaoAssentoStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessaoAssentoStatuses.
     */
    data: SessaoAssentoStatusCreateManyInput | SessaoAssentoStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessaoAssentoStatus createManyAndReturn
   */
  export type SessaoAssentoStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessaoAssentoStatus
     */
    select?: SessaoAssentoStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessaoAssentoStatus
     */
    omit?: SessaoAssentoStatusOmit<ExtArgs> | null
    /**
     * The data used to create many SessaoAssentoStatuses.
     */
    data: SessaoAssentoStatusCreateManyInput | SessaoAssentoStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessaoAssentoStatus update
   */
  export type SessaoAssentoStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessaoAssentoStatus
     */
    select?: SessaoAssentoStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessaoAssentoStatus
     */
    omit?: SessaoAssentoStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoAssentoStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a SessaoAssentoStatus.
     */
    data: XOR<SessaoAssentoStatusUpdateInput, SessaoAssentoStatusUncheckedUpdateInput>
    /**
     * Choose, which SessaoAssentoStatus to update.
     */
    where: SessaoAssentoStatusWhereUniqueInput
  }

  /**
   * SessaoAssentoStatus updateMany
   */
  export type SessaoAssentoStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessaoAssentoStatuses.
     */
    data: XOR<SessaoAssentoStatusUpdateManyMutationInput, SessaoAssentoStatusUncheckedUpdateManyInput>
    /**
     * Filter which SessaoAssentoStatuses to update
     */
    where?: SessaoAssentoStatusWhereInput
    /**
     * Limit how many SessaoAssentoStatuses to update.
     */
    limit?: number
  }

  /**
   * SessaoAssentoStatus updateManyAndReturn
   */
  export type SessaoAssentoStatusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessaoAssentoStatus
     */
    select?: SessaoAssentoStatusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessaoAssentoStatus
     */
    omit?: SessaoAssentoStatusOmit<ExtArgs> | null
    /**
     * The data used to update SessaoAssentoStatuses.
     */
    data: XOR<SessaoAssentoStatusUpdateManyMutationInput, SessaoAssentoStatusUncheckedUpdateManyInput>
    /**
     * Filter which SessaoAssentoStatuses to update
     */
    where?: SessaoAssentoStatusWhereInput
    /**
     * Limit how many SessaoAssentoStatuses to update.
     */
    limit?: number
  }

  /**
   * SessaoAssentoStatus upsert
   */
  export type SessaoAssentoStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessaoAssentoStatus
     */
    select?: SessaoAssentoStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessaoAssentoStatus
     */
    omit?: SessaoAssentoStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoAssentoStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the SessaoAssentoStatus to update in case it exists.
     */
    where: SessaoAssentoStatusWhereUniqueInput
    /**
     * In case the SessaoAssentoStatus found by the `where` argument doesn't exist, create a new SessaoAssentoStatus with this data.
     */
    create: XOR<SessaoAssentoStatusCreateInput, SessaoAssentoStatusUncheckedCreateInput>
    /**
     * In case the SessaoAssentoStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessaoAssentoStatusUpdateInput, SessaoAssentoStatusUncheckedUpdateInput>
  }

  /**
   * SessaoAssentoStatus delete
   */
  export type SessaoAssentoStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessaoAssentoStatus
     */
    select?: SessaoAssentoStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessaoAssentoStatus
     */
    omit?: SessaoAssentoStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoAssentoStatusInclude<ExtArgs> | null
    /**
     * Filter which SessaoAssentoStatus to delete.
     */
    where: SessaoAssentoStatusWhereUniqueInput
  }

  /**
   * SessaoAssentoStatus deleteMany
   */
  export type SessaoAssentoStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessaoAssentoStatuses to delete
     */
    where?: SessaoAssentoStatusWhereInput
    /**
     * Limit how many SessaoAssentoStatuses to delete.
     */
    limit?: number
  }

  /**
   * SessaoAssentoStatus.sessoesAssentos
   */
  export type SessaoAssentoStatus$sessoesAssentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessaoAssento
     */
    select?: SessaoAssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessaoAssento
     */
    omit?: SessaoAssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoAssentoInclude<ExtArgs> | null
    where?: SessaoAssentoWhereInput
    orderBy?: SessaoAssentoOrderByWithRelationInput | SessaoAssentoOrderByWithRelationInput[]
    cursor?: SessaoAssentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessaoAssentoScalarFieldEnum | SessaoAssentoScalarFieldEnum[]
  }

  /**
   * SessaoAssentoStatus without action
   */
  export type SessaoAssentoStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessaoAssentoStatus
     */
    select?: SessaoAssentoStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessaoAssentoStatus
     */
    omit?: SessaoAssentoStatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoAssentoStatusInclude<ExtArgs> | null
  }


  /**
   * Model SessaoAssento
   */

  export type AggregateSessaoAssento = {
    _count: SessaoAssentoCountAggregateOutputType | null
    _avg: SessaoAssentoAvgAggregateOutputType | null
    _sum: SessaoAssentoSumAggregateOutputType | null
    _min: SessaoAssentoMinAggregateOutputType | null
    _max: SessaoAssentoMaxAggregateOutputType | null
  }

  export type SessaoAssentoAvgAggregateOutputType = {
    id: number | null
    sessaoId: number | null
    assentoId: number | null
    ingressoId: number | null
    sessaoAssentoStatusId: number | null
    tipoEntradaId: number | null
  }

  export type SessaoAssentoSumAggregateOutputType = {
    id: number | null
    sessaoId: number | null
    assentoId: number | null
    ingressoId: number | null
    sessaoAssentoStatusId: number | null
    tipoEntradaId: number | null
  }

  export type SessaoAssentoMinAggregateOutputType = {
    id: number | null
    sessaoId: number | null
    assentoId: number | null
    ingressoId: number | null
    sessaoAssentoStatusId: number | null
    tipoEntradaId: number | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type SessaoAssentoMaxAggregateOutputType = {
    id: number | null
    sessaoId: number | null
    assentoId: number | null
    ingressoId: number | null
    sessaoAssentoStatusId: number | null
    tipoEntradaId: number | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type SessaoAssentoCountAggregateOutputType = {
    id: number
    sessaoId: number
    assentoId: number
    ingressoId: number
    sessaoAssentoStatusId: number
    tipoEntradaId: number
    ativo: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type SessaoAssentoAvgAggregateInputType = {
    id?: true
    sessaoId?: true
    assentoId?: true
    ingressoId?: true
    sessaoAssentoStatusId?: true
    tipoEntradaId?: true
  }

  export type SessaoAssentoSumAggregateInputType = {
    id?: true
    sessaoId?: true
    assentoId?: true
    ingressoId?: true
    sessaoAssentoStatusId?: true
    tipoEntradaId?: true
  }

  export type SessaoAssentoMinAggregateInputType = {
    id?: true
    sessaoId?: true
    assentoId?: true
    ingressoId?: true
    sessaoAssentoStatusId?: true
    tipoEntradaId?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type SessaoAssentoMaxAggregateInputType = {
    id?: true
    sessaoId?: true
    assentoId?: true
    ingressoId?: true
    sessaoAssentoStatusId?: true
    tipoEntradaId?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type SessaoAssentoCountAggregateInputType = {
    id?: true
    sessaoId?: true
    assentoId?: true
    ingressoId?: true
    sessaoAssentoStatusId?: true
    tipoEntradaId?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type SessaoAssentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessaoAssento to aggregate.
     */
    where?: SessaoAssentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessaoAssentos to fetch.
     */
    orderBy?: SessaoAssentoOrderByWithRelationInput | SessaoAssentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessaoAssentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessaoAssentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessaoAssentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SessaoAssentos
    **/
    _count?: true | SessaoAssentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessaoAssentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessaoAssentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessaoAssentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessaoAssentoMaxAggregateInputType
  }

  export type GetSessaoAssentoAggregateType<T extends SessaoAssentoAggregateArgs> = {
        [P in keyof T & keyof AggregateSessaoAssento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessaoAssento[P]>
      : GetScalarType<T[P], AggregateSessaoAssento[P]>
  }




  export type SessaoAssentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessaoAssentoWhereInput
    orderBy?: SessaoAssentoOrderByWithAggregationInput | SessaoAssentoOrderByWithAggregationInput[]
    by: SessaoAssentoScalarFieldEnum[] | SessaoAssentoScalarFieldEnum
    having?: SessaoAssentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessaoAssentoCountAggregateInputType | true
    _avg?: SessaoAssentoAvgAggregateInputType
    _sum?: SessaoAssentoSumAggregateInputType
    _min?: SessaoAssentoMinAggregateInputType
    _max?: SessaoAssentoMaxAggregateInputType
  }

  export type SessaoAssentoGroupByOutputType = {
    id: number
    sessaoId: number
    assentoId: number
    ingressoId: number
    sessaoAssentoStatusId: number
    tipoEntradaId: number
    ativo: boolean
    criadoEm: Date
    atualizadoEm: Date
    _count: SessaoAssentoCountAggregateOutputType | null
    _avg: SessaoAssentoAvgAggregateOutputType | null
    _sum: SessaoAssentoSumAggregateOutputType | null
    _min: SessaoAssentoMinAggregateOutputType | null
    _max: SessaoAssentoMaxAggregateOutputType | null
  }

  type GetSessaoAssentoGroupByPayload<T extends SessaoAssentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessaoAssentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessaoAssentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessaoAssentoGroupByOutputType[P]>
            : GetScalarType<T[P], SessaoAssentoGroupByOutputType[P]>
        }
      >
    >


  export type SessaoAssentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessaoId?: boolean
    assentoId?: boolean
    ingressoId?: boolean
    sessaoAssentoStatusId?: boolean
    tipoEntradaId?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    sessao?: boolean | SessaoDefaultArgs<ExtArgs>
    assento?: boolean | AssentoDefaultArgs<ExtArgs>
    ingresso?: boolean | IngressoDefaultArgs<ExtArgs>
    sessaoAssentoStatus?: boolean | SessaoAssentoStatusDefaultArgs<ExtArgs>
    tipoEntrada?: boolean | TipoEntradaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessaoAssento"]>

  export type SessaoAssentoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessaoId?: boolean
    assentoId?: boolean
    ingressoId?: boolean
    sessaoAssentoStatusId?: boolean
    tipoEntradaId?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    sessao?: boolean | SessaoDefaultArgs<ExtArgs>
    assento?: boolean | AssentoDefaultArgs<ExtArgs>
    ingresso?: boolean | IngressoDefaultArgs<ExtArgs>
    sessaoAssentoStatus?: boolean | SessaoAssentoStatusDefaultArgs<ExtArgs>
    tipoEntrada?: boolean | TipoEntradaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessaoAssento"]>

  export type SessaoAssentoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessaoId?: boolean
    assentoId?: boolean
    ingressoId?: boolean
    sessaoAssentoStatusId?: boolean
    tipoEntradaId?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    sessao?: boolean | SessaoDefaultArgs<ExtArgs>
    assento?: boolean | AssentoDefaultArgs<ExtArgs>
    ingresso?: boolean | IngressoDefaultArgs<ExtArgs>
    sessaoAssentoStatus?: boolean | SessaoAssentoStatusDefaultArgs<ExtArgs>
    tipoEntrada?: boolean | TipoEntradaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sessaoAssento"]>

  export type SessaoAssentoSelectScalar = {
    id?: boolean
    sessaoId?: boolean
    assentoId?: boolean
    ingressoId?: boolean
    sessaoAssentoStatusId?: boolean
    tipoEntradaId?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type SessaoAssentoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessaoId" | "assentoId" | "ingressoId" | "sessaoAssentoStatusId" | "tipoEntradaId" | "ativo" | "criadoEm" | "atualizadoEm", ExtArgs["result"]["sessaoAssento"]>
  export type SessaoAssentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessao?: boolean | SessaoDefaultArgs<ExtArgs>
    assento?: boolean | AssentoDefaultArgs<ExtArgs>
    ingresso?: boolean | IngressoDefaultArgs<ExtArgs>
    sessaoAssentoStatus?: boolean | SessaoAssentoStatusDefaultArgs<ExtArgs>
    tipoEntrada?: boolean | TipoEntradaDefaultArgs<ExtArgs>
  }
  export type SessaoAssentoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessao?: boolean | SessaoDefaultArgs<ExtArgs>
    assento?: boolean | AssentoDefaultArgs<ExtArgs>
    ingresso?: boolean | IngressoDefaultArgs<ExtArgs>
    sessaoAssentoStatus?: boolean | SessaoAssentoStatusDefaultArgs<ExtArgs>
    tipoEntrada?: boolean | TipoEntradaDefaultArgs<ExtArgs>
  }
  export type SessaoAssentoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessao?: boolean | SessaoDefaultArgs<ExtArgs>
    assento?: boolean | AssentoDefaultArgs<ExtArgs>
    ingresso?: boolean | IngressoDefaultArgs<ExtArgs>
    sessaoAssentoStatus?: boolean | SessaoAssentoStatusDefaultArgs<ExtArgs>
    tipoEntrada?: boolean | TipoEntradaDefaultArgs<ExtArgs>
  }

  export type $SessaoAssentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SessaoAssento"
    objects: {
      sessao: Prisma.$SessaoPayload<ExtArgs>
      assento: Prisma.$AssentoPayload<ExtArgs>
      ingresso: Prisma.$IngressoPayload<ExtArgs>
      sessaoAssentoStatus: Prisma.$SessaoAssentoStatusPayload<ExtArgs>
      tipoEntrada: Prisma.$TipoEntradaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      sessaoId: number
      assentoId: number
      ingressoId: number
      sessaoAssentoStatusId: number
      tipoEntradaId: number
      ativo: boolean
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["sessaoAssento"]>
    composites: {}
  }

  type SessaoAssentoGetPayload<S extends boolean | null | undefined | SessaoAssentoDefaultArgs> = $Result.GetResult<Prisma.$SessaoAssentoPayload, S>

  type SessaoAssentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessaoAssentoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessaoAssentoCountAggregateInputType | true
    }

  export interface SessaoAssentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SessaoAssento'], meta: { name: 'SessaoAssento' } }
    /**
     * Find zero or one SessaoAssento that matches the filter.
     * @param {SessaoAssentoFindUniqueArgs} args - Arguments to find a SessaoAssento
     * @example
     * // Get one SessaoAssento
     * const sessaoAssento = await prisma.sessaoAssento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessaoAssentoFindUniqueArgs>(args: SelectSubset<T, SessaoAssentoFindUniqueArgs<ExtArgs>>): Prisma__SessaoAssentoClient<$Result.GetResult<Prisma.$SessaoAssentoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SessaoAssento that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessaoAssentoFindUniqueOrThrowArgs} args - Arguments to find a SessaoAssento
     * @example
     * // Get one SessaoAssento
     * const sessaoAssento = await prisma.sessaoAssento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessaoAssentoFindUniqueOrThrowArgs>(args: SelectSubset<T, SessaoAssentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessaoAssentoClient<$Result.GetResult<Prisma.$SessaoAssentoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessaoAssento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessaoAssentoFindFirstArgs} args - Arguments to find a SessaoAssento
     * @example
     * // Get one SessaoAssento
     * const sessaoAssento = await prisma.sessaoAssento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessaoAssentoFindFirstArgs>(args?: SelectSubset<T, SessaoAssentoFindFirstArgs<ExtArgs>>): Prisma__SessaoAssentoClient<$Result.GetResult<Prisma.$SessaoAssentoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SessaoAssento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessaoAssentoFindFirstOrThrowArgs} args - Arguments to find a SessaoAssento
     * @example
     * // Get one SessaoAssento
     * const sessaoAssento = await prisma.sessaoAssento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessaoAssentoFindFirstOrThrowArgs>(args?: SelectSubset<T, SessaoAssentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessaoAssentoClient<$Result.GetResult<Prisma.$SessaoAssentoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SessaoAssentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessaoAssentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SessaoAssentos
     * const sessaoAssentos = await prisma.sessaoAssento.findMany()
     * 
     * // Get first 10 SessaoAssentos
     * const sessaoAssentos = await prisma.sessaoAssento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessaoAssentoWithIdOnly = await prisma.sessaoAssento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessaoAssentoFindManyArgs>(args?: SelectSubset<T, SessaoAssentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessaoAssentoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SessaoAssento.
     * @param {SessaoAssentoCreateArgs} args - Arguments to create a SessaoAssento.
     * @example
     * // Create one SessaoAssento
     * const SessaoAssento = await prisma.sessaoAssento.create({
     *   data: {
     *     // ... data to create a SessaoAssento
     *   }
     * })
     * 
     */
    create<T extends SessaoAssentoCreateArgs>(args: SelectSubset<T, SessaoAssentoCreateArgs<ExtArgs>>): Prisma__SessaoAssentoClient<$Result.GetResult<Prisma.$SessaoAssentoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SessaoAssentos.
     * @param {SessaoAssentoCreateManyArgs} args - Arguments to create many SessaoAssentos.
     * @example
     * // Create many SessaoAssentos
     * const sessaoAssento = await prisma.sessaoAssento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessaoAssentoCreateManyArgs>(args?: SelectSubset<T, SessaoAssentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SessaoAssentos and returns the data saved in the database.
     * @param {SessaoAssentoCreateManyAndReturnArgs} args - Arguments to create many SessaoAssentos.
     * @example
     * // Create many SessaoAssentos
     * const sessaoAssento = await prisma.sessaoAssento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SessaoAssentos and only return the `id`
     * const sessaoAssentoWithIdOnly = await prisma.sessaoAssento.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessaoAssentoCreateManyAndReturnArgs>(args?: SelectSubset<T, SessaoAssentoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessaoAssentoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SessaoAssento.
     * @param {SessaoAssentoDeleteArgs} args - Arguments to delete one SessaoAssento.
     * @example
     * // Delete one SessaoAssento
     * const SessaoAssento = await prisma.sessaoAssento.delete({
     *   where: {
     *     // ... filter to delete one SessaoAssento
     *   }
     * })
     * 
     */
    delete<T extends SessaoAssentoDeleteArgs>(args: SelectSubset<T, SessaoAssentoDeleteArgs<ExtArgs>>): Prisma__SessaoAssentoClient<$Result.GetResult<Prisma.$SessaoAssentoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SessaoAssento.
     * @param {SessaoAssentoUpdateArgs} args - Arguments to update one SessaoAssento.
     * @example
     * // Update one SessaoAssento
     * const sessaoAssento = await prisma.sessaoAssento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessaoAssentoUpdateArgs>(args: SelectSubset<T, SessaoAssentoUpdateArgs<ExtArgs>>): Prisma__SessaoAssentoClient<$Result.GetResult<Prisma.$SessaoAssentoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SessaoAssentos.
     * @param {SessaoAssentoDeleteManyArgs} args - Arguments to filter SessaoAssentos to delete.
     * @example
     * // Delete a few SessaoAssentos
     * const { count } = await prisma.sessaoAssento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessaoAssentoDeleteManyArgs>(args?: SelectSubset<T, SessaoAssentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessaoAssentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessaoAssentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SessaoAssentos
     * const sessaoAssento = await prisma.sessaoAssento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessaoAssentoUpdateManyArgs>(args: SelectSubset<T, SessaoAssentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SessaoAssentos and returns the data updated in the database.
     * @param {SessaoAssentoUpdateManyAndReturnArgs} args - Arguments to update many SessaoAssentos.
     * @example
     * // Update many SessaoAssentos
     * const sessaoAssento = await prisma.sessaoAssento.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SessaoAssentos and only return the `id`
     * const sessaoAssentoWithIdOnly = await prisma.sessaoAssento.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessaoAssentoUpdateManyAndReturnArgs>(args: SelectSubset<T, SessaoAssentoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessaoAssentoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SessaoAssento.
     * @param {SessaoAssentoUpsertArgs} args - Arguments to update or create a SessaoAssento.
     * @example
     * // Update or create a SessaoAssento
     * const sessaoAssento = await prisma.sessaoAssento.upsert({
     *   create: {
     *     // ... data to create a SessaoAssento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SessaoAssento we want to update
     *   }
     * })
     */
    upsert<T extends SessaoAssentoUpsertArgs>(args: SelectSubset<T, SessaoAssentoUpsertArgs<ExtArgs>>): Prisma__SessaoAssentoClient<$Result.GetResult<Prisma.$SessaoAssentoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SessaoAssentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessaoAssentoCountArgs} args - Arguments to filter SessaoAssentos to count.
     * @example
     * // Count the number of SessaoAssentos
     * const count = await prisma.sessaoAssento.count({
     *   where: {
     *     // ... the filter for the SessaoAssentos we want to count
     *   }
     * })
    **/
    count<T extends SessaoAssentoCountArgs>(
      args?: Subset<T, SessaoAssentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessaoAssentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SessaoAssento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessaoAssentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessaoAssentoAggregateArgs>(args: Subset<T, SessaoAssentoAggregateArgs>): Prisma.PrismaPromise<GetSessaoAssentoAggregateType<T>>

    /**
     * Group by SessaoAssento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessaoAssentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessaoAssentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessaoAssentoGroupByArgs['orderBy'] }
        : { orderBy?: SessaoAssentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessaoAssentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessaoAssentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SessaoAssento model
   */
  readonly fields: SessaoAssentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SessaoAssento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessaoAssentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessao<T extends SessaoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessaoDefaultArgs<ExtArgs>>): Prisma__SessaoClient<$Result.GetResult<Prisma.$SessaoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assento<T extends AssentoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AssentoDefaultArgs<ExtArgs>>): Prisma__AssentoClient<$Result.GetResult<Prisma.$AssentoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    ingresso<T extends IngressoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IngressoDefaultArgs<ExtArgs>>): Prisma__IngressoClient<$Result.GetResult<Prisma.$IngressoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sessaoAssentoStatus<T extends SessaoAssentoStatusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SessaoAssentoStatusDefaultArgs<ExtArgs>>): Prisma__SessaoAssentoStatusClient<$Result.GetResult<Prisma.$SessaoAssentoStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tipoEntrada<T extends TipoEntradaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TipoEntradaDefaultArgs<ExtArgs>>): Prisma__TipoEntradaClient<$Result.GetResult<Prisma.$TipoEntradaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SessaoAssento model
   */
  interface SessaoAssentoFieldRefs {
    readonly id: FieldRef<"SessaoAssento", 'Int'>
    readonly sessaoId: FieldRef<"SessaoAssento", 'Int'>
    readonly assentoId: FieldRef<"SessaoAssento", 'Int'>
    readonly ingressoId: FieldRef<"SessaoAssento", 'Int'>
    readonly sessaoAssentoStatusId: FieldRef<"SessaoAssento", 'Int'>
    readonly tipoEntradaId: FieldRef<"SessaoAssento", 'Int'>
    readonly ativo: FieldRef<"SessaoAssento", 'Boolean'>
    readonly criadoEm: FieldRef<"SessaoAssento", 'DateTime'>
    readonly atualizadoEm: FieldRef<"SessaoAssento", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SessaoAssento findUnique
   */
  export type SessaoAssentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessaoAssento
     */
    select?: SessaoAssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessaoAssento
     */
    omit?: SessaoAssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoAssentoInclude<ExtArgs> | null
    /**
     * Filter, which SessaoAssento to fetch.
     */
    where: SessaoAssentoWhereUniqueInput
  }

  /**
   * SessaoAssento findUniqueOrThrow
   */
  export type SessaoAssentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessaoAssento
     */
    select?: SessaoAssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessaoAssento
     */
    omit?: SessaoAssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoAssentoInclude<ExtArgs> | null
    /**
     * Filter, which SessaoAssento to fetch.
     */
    where: SessaoAssentoWhereUniqueInput
  }

  /**
   * SessaoAssento findFirst
   */
  export type SessaoAssentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessaoAssento
     */
    select?: SessaoAssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessaoAssento
     */
    omit?: SessaoAssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoAssentoInclude<ExtArgs> | null
    /**
     * Filter, which SessaoAssento to fetch.
     */
    where?: SessaoAssentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessaoAssentos to fetch.
     */
    orderBy?: SessaoAssentoOrderByWithRelationInput | SessaoAssentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessaoAssentos.
     */
    cursor?: SessaoAssentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessaoAssentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessaoAssentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessaoAssentos.
     */
    distinct?: SessaoAssentoScalarFieldEnum | SessaoAssentoScalarFieldEnum[]
  }

  /**
   * SessaoAssento findFirstOrThrow
   */
  export type SessaoAssentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessaoAssento
     */
    select?: SessaoAssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessaoAssento
     */
    omit?: SessaoAssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoAssentoInclude<ExtArgs> | null
    /**
     * Filter, which SessaoAssento to fetch.
     */
    where?: SessaoAssentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessaoAssentos to fetch.
     */
    orderBy?: SessaoAssentoOrderByWithRelationInput | SessaoAssentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SessaoAssentos.
     */
    cursor?: SessaoAssentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessaoAssentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessaoAssentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SessaoAssentos.
     */
    distinct?: SessaoAssentoScalarFieldEnum | SessaoAssentoScalarFieldEnum[]
  }

  /**
   * SessaoAssento findMany
   */
  export type SessaoAssentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessaoAssento
     */
    select?: SessaoAssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessaoAssento
     */
    omit?: SessaoAssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoAssentoInclude<ExtArgs> | null
    /**
     * Filter, which SessaoAssentos to fetch.
     */
    where?: SessaoAssentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SessaoAssentos to fetch.
     */
    orderBy?: SessaoAssentoOrderByWithRelationInput | SessaoAssentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SessaoAssentos.
     */
    cursor?: SessaoAssentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SessaoAssentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SessaoAssentos.
     */
    skip?: number
    distinct?: SessaoAssentoScalarFieldEnum | SessaoAssentoScalarFieldEnum[]
  }

  /**
   * SessaoAssento create
   */
  export type SessaoAssentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessaoAssento
     */
    select?: SessaoAssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessaoAssento
     */
    omit?: SessaoAssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoAssentoInclude<ExtArgs> | null
    /**
     * The data needed to create a SessaoAssento.
     */
    data: XOR<SessaoAssentoCreateInput, SessaoAssentoUncheckedCreateInput>
  }

  /**
   * SessaoAssento createMany
   */
  export type SessaoAssentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SessaoAssentos.
     */
    data: SessaoAssentoCreateManyInput | SessaoAssentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SessaoAssento createManyAndReturn
   */
  export type SessaoAssentoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessaoAssento
     */
    select?: SessaoAssentoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessaoAssento
     */
    omit?: SessaoAssentoOmit<ExtArgs> | null
    /**
     * The data used to create many SessaoAssentos.
     */
    data: SessaoAssentoCreateManyInput | SessaoAssentoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoAssentoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessaoAssento update
   */
  export type SessaoAssentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessaoAssento
     */
    select?: SessaoAssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessaoAssento
     */
    omit?: SessaoAssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoAssentoInclude<ExtArgs> | null
    /**
     * The data needed to update a SessaoAssento.
     */
    data: XOR<SessaoAssentoUpdateInput, SessaoAssentoUncheckedUpdateInput>
    /**
     * Choose, which SessaoAssento to update.
     */
    where: SessaoAssentoWhereUniqueInput
  }

  /**
   * SessaoAssento updateMany
   */
  export type SessaoAssentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SessaoAssentos.
     */
    data: XOR<SessaoAssentoUpdateManyMutationInput, SessaoAssentoUncheckedUpdateManyInput>
    /**
     * Filter which SessaoAssentos to update
     */
    where?: SessaoAssentoWhereInput
    /**
     * Limit how many SessaoAssentos to update.
     */
    limit?: number
  }

  /**
   * SessaoAssento updateManyAndReturn
   */
  export type SessaoAssentoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessaoAssento
     */
    select?: SessaoAssentoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SessaoAssento
     */
    omit?: SessaoAssentoOmit<ExtArgs> | null
    /**
     * The data used to update SessaoAssentos.
     */
    data: XOR<SessaoAssentoUpdateManyMutationInput, SessaoAssentoUncheckedUpdateManyInput>
    /**
     * Filter which SessaoAssentos to update
     */
    where?: SessaoAssentoWhereInput
    /**
     * Limit how many SessaoAssentos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoAssentoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SessaoAssento upsert
   */
  export type SessaoAssentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessaoAssento
     */
    select?: SessaoAssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessaoAssento
     */
    omit?: SessaoAssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoAssentoInclude<ExtArgs> | null
    /**
     * The filter to search for the SessaoAssento to update in case it exists.
     */
    where: SessaoAssentoWhereUniqueInput
    /**
     * In case the SessaoAssento found by the `where` argument doesn't exist, create a new SessaoAssento with this data.
     */
    create: XOR<SessaoAssentoCreateInput, SessaoAssentoUncheckedCreateInput>
    /**
     * In case the SessaoAssento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessaoAssentoUpdateInput, SessaoAssentoUncheckedUpdateInput>
  }

  /**
   * SessaoAssento delete
   */
  export type SessaoAssentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessaoAssento
     */
    select?: SessaoAssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessaoAssento
     */
    omit?: SessaoAssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoAssentoInclude<ExtArgs> | null
    /**
     * Filter which SessaoAssento to delete.
     */
    where: SessaoAssentoWhereUniqueInput
  }

  /**
   * SessaoAssento deleteMany
   */
  export type SessaoAssentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SessaoAssentos to delete
     */
    where?: SessaoAssentoWhereInput
    /**
     * Limit how many SessaoAssentos to delete.
     */
    limit?: number
  }

  /**
   * SessaoAssento without action
   */
  export type SessaoAssentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessaoAssento
     */
    select?: SessaoAssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessaoAssento
     */
    omit?: SessaoAssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoAssentoInclude<ExtArgs> | null
  }


  /**
   * Model TipoEntrada
   */

  export type AggregateTipoEntrada = {
    _count: TipoEntradaCountAggregateOutputType | null
    _avg: TipoEntradaAvgAggregateOutputType | null
    _sum: TipoEntradaSumAggregateOutputType | null
    _min: TipoEntradaMinAggregateOutputType | null
    _max: TipoEntradaMaxAggregateOutputType | null
  }

  export type TipoEntradaAvgAggregateOutputType = {
    id: number | null
  }

  export type TipoEntradaSumAggregateOutputType = {
    id: number | null
  }

  export type TipoEntradaMinAggregateOutputType = {
    id: number | null
    nome: string | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type TipoEntradaMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type TipoEntradaCountAggregateOutputType = {
    id: number
    nome: number
    ativo: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type TipoEntradaAvgAggregateInputType = {
    id?: true
  }

  export type TipoEntradaSumAggregateInputType = {
    id?: true
  }

  export type TipoEntradaMinAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type TipoEntradaMaxAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type TipoEntradaCountAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type TipoEntradaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoEntrada to aggregate.
     */
    where?: TipoEntradaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoEntradas to fetch.
     */
    orderBy?: TipoEntradaOrderByWithRelationInput | TipoEntradaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TipoEntradaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoEntradas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoEntradas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TipoEntradas
    **/
    _count?: true | TipoEntradaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TipoEntradaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TipoEntradaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TipoEntradaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TipoEntradaMaxAggregateInputType
  }

  export type GetTipoEntradaAggregateType<T extends TipoEntradaAggregateArgs> = {
        [P in keyof T & keyof AggregateTipoEntrada]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTipoEntrada[P]>
      : GetScalarType<T[P], AggregateTipoEntrada[P]>
  }




  export type TipoEntradaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TipoEntradaWhereInput
    orderBy?: TipoEntradaOrderByWithAggregationInput | TipoEntradaOrderByWithAggregationInput[]
    by: TipoEntradaScalarFieldEnum[] | TipoEntradaScalarFieldEnum
    having?: TipoEntradaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TipoEntradaCountAggregateInputType | true
    _avg?: TipoEntradaAvgAggregateInputType
    _sum?: TipoEntradaSumAggregateInputType
    _min?: TipoEntradaMinAggregateInputType
    _max?: TipoEntradaMaxAggregateInputType
  }

  export type TipoEntradaGroupByOutputType = {
    id: number
    nome: string
    ativo: boolean
    criadoEm: Date
    atualizadoEm: Date
    _count: TipoEntradaCountAggregateOutputType | null
    _avg: TipoEntradaAvgAggregateOutputType | null
    _sum: TipoEntradaSumAggregateOutputType | null
    _min: TipoEntradaMinAggregateOutputType | null
    _max: TipoEntradaMaxAggregateOutputType | null
  }

  type GetTipoEntradaGroupByPayload<T extends TipoEntradaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TipoEntradaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TipoEntradaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TipoEntradaGroupByOutputType[P]>
            : GetScalarType<T[P], TipoEntradaGroupByOutputType[P]>
        }
      >
    >


  export type TipoEntradaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    sessoesAssentos?: boolean | TipoEntrada$sessoesAssentosArgs<ExtArgs>
    _count?: boolean | TipoEntradaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tipoEntrada"]>

  export type TipoEntradaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }, ExtArgs["result"]["tipoEntrada"]>

  export type TipoEntradaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }, ExtArgs["result"]["tipoEntrada"]>

  export type TipoEntradaSelectScalar = {
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type TipoEntradaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "ativo" | "criadoEm" | "atualizadoEm", ExtArgs["result"]["tipoEntrada"]>
  export type TipoEntradaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessoesAssentos?: boolean | TipoEntrada$sessoesAssentosArgs<ExtArgs>
    _count?: boolean | TipoEntradaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TipoEntradaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TipoEntradaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TipoEntradaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TipoEntrada"
    objects: {
      sessoesAssentos: Prisma.$SessaoAssentoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      ativo: boolean
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["tipoEntrada"]>
    composites: {}
  }

  type TipoEntradaGetPayload<S extends boolean | null | undefined | TipoEntradaDefaultArgs> = $Result.GetResult<Prisma.$TipoEntradaPayload, S>

  type TipoEntradaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TipoEntradaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TipoEntradaCountAggregateInputType | true
    }

  export interface TipoEntradaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TipoEntrada'], meta: { name: 'TipoEntrada' } }
    /**
     * Find zero or one TipoEntrada that matches the filter.
     * @param {TipoEntradaFindUniqueArgs} args - Arguments to find a TipoEntrada
     * @example
     * // Get one TipoEntrada
     * const tipoEntrada = await prisma.tipoEntrada.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TipoEntradaFindUniqueArgs>(args: SelectSubset<T, TipoEntradaFindUniqueArgs<ExtArgs>>): Prisma__TipoEntradaClient<$Result.GetResult<Prisma.$TipoEntradaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TipoEntrada that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TipoEntradaFindUniqueOrThrowArgs} args - Arguments to find a TipoEntrada
     * @example
     * // Get one TipoEntrada
     * const tipoEntrada = await prisma.tipoEntrada.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TipoEntradaFindUniqueOrThrowArgs>(args: SelectSubset<T, TipoEntradaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TipoEntradaClient<$Result.GetResult<Prisma.$TipoEntradaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoEntrada that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoEntradaFindFirstArgs} args - Arguments to find a TipoEntrada
     * @example
     * // Get one TipoEntrada
     * const tipoEntrada = await prisma.tipoEntrada.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TipoEntradaFindFirstArgs>(args?: SelectSubset<T, TipoEntradaFindFirstArgs<ExtArgs>>): Prisma__TipoEntradaClient<$Result.GetResult<Prisma.$TipoEntradaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TipoEntrada that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoEntradaFindFirstOrThrowArgs} args - Arguments to find a TipoEntrada
     * @example
     * // Get one TipoEntrada
     * const tipoEntrada = await prisma.tipoEntrada.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TipoEntradaFindFirstOrThrowArgs>(args?: SelectSubset<T, TipoEntradaFindFirstOrThrowArgs<ExtArgs>>): Prisma__TipoEntradaClient<$Result.GetResult<Prisma.$TipoEntradaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TipoEntradas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoEntradaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TipoEntradas
     * const tipoEntradas = await prisma.tipoEntrada.findMany()
     * 
     * // Get first 10 TipoEntradas
     * const tipoEntradas = await prisma.tipoEntrada.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tipoEntradaWithIdOnly = await prisma.tipoEntrada.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TipoEntradaFindManyArgs>(args?: SelectSubset<T, TipoEntradaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoEntradaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TipoEntrada.
     * @param {TipoEntradaCreateArgs} args - Arguments to create a TipoEntrada.
     * @example
     * // Create one TipoEntrada
     * const TipoEntrada = await prisma.tipoEntrada.create({
     *   data: {
     *     // ... data to create a TipoEntrada
     *   }
     * })
     * 
     */
    create<T extends TipoEntradaCreateArgs>(args: SelectSubset<T, TipoEntradaCreateArgs<ExtArgs>>): Prisma__TipoEntradaClient<$Result.GetResult<Prisma.$TipoEntradaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TipoEntradas.
     * @param {TipoEntradaCreateManyArgs} args - Arguments to create many TipoEntradas.
     * @example
     * // Create many TipoEntradas
     * const tipoEntrada = await prisma.tipoEntrada.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TipoEntradaCreateManyArgs>(args?: SelectSubset<T, TipoEntradaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TipoEntradas and returns the data saved in the database.
     * @param {TipoEntradaCreateManyAndReturnArgs} args - Arguments to create many TipoEntradas.
     * @example
     * // Create many TipoEntradas
     * const tipoEntrada = await prisma.tipoEntrada.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TipoEntradas and only return the `id`
     * const tipoEntradaWithIdOnly = await prisma.tipoEntrada.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TipoEntradaCreateManyAndReturnArgs>(args?: SelectSubset<T, TipoEntradaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoEntradaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TipoEntrada.
     * @param {TipoEntradaDeleteArgs} args - Arguments to delete one TipoEntrada.
     * @example
     * // Delete one TipoEntrada
     * const TipoEntrada = await prisma.tipoEntrada.delete({
     *   where: {
     *     // ... filter to delete one TipoEntrada
     *   }
     * })
     * 
     */
    delete<T extends TipoEntradaDeleteArgs>(args: SelectSubset<T, TipoEntradaDeleteArgs<ExtArgs>>): Prisma__TipoEntradaClient<$Result.GetResult<Prisma.$TipoEntradaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TipoEntrada.
     * @param {TipoEntradaUpdateArgs} args - Arguments to update one TipoEntrada.
     * @example
     * // Update one TipoEntrada
     * const tipoEntrada = await prisma.tipoEntrada.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TipoEntradaUpdateArgs>(args: SelectSubset<T, TipoEntradaUpdateArgs<ExtArgs>>): Prisma__TipoEntradaClient<$Result.GetResult<Prisma.$TipoEntradaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TipoEntradas.
     * @param {TipoEntradaDeleteManyArgs} args - Arguments to filter TipoEntradas to delete.
     * @example
     * // Delete a few TipoEntradas
     * const { count } = await prisma.tipoEntrada.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TipoEntradaDeleteManyArgs>(args?: SelectSubset<T, TipoEntradaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoEntradas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoEntradaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TipoEntradas
     * const tipoEntrada = await prisma.tipoEntrada.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TipoEntradaUpdateManyArgs>(args: SelectSubset<T, TipoEntradaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TipoEntradas and returns the data updated in the database.
     * @param {TipoEntradaUpdateManyAndReturnArgs} args - Arguments to update many TipoEntradas.
     * @example
     * // Update many TipoEntradas
     * const tipoEntrada = await prisma.tipoEntrada.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TipoEntradas and only return the `id`
     * const tipoEntradaWithIdOnly = await prisma.tipoEntrada.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TipoEntradaUpdateManyAndReturnArgs>(args: SelectSubset<T, TipoEntradaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TipoEntradaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TipoEntrada.
     * @param {TipoEntradaUpsertArgs} args - Arguments to update or create a TipoEntrada.
     * @example
     * // Update or create a TipoEntrada
     * const tipoEntrada = await prisma.tipoEntrada.upsert({
     *   create: {
     *     // ... data to create a TipoEntrada
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TipoEntrada we want to update
     *   }
     * })
     */
    upsert<T extends TipoEntradaUpsertArgs>(args: SelectSubset<T, TipoEntradaUpsertArgs<ExtArgs>>): Prisma__TipoEntradaClient<$Result.GetResult<Prisma.$TipoEntradaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TipoEntradas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoEntradaCountArgs} args - Arguments to filter TipoEntradas to count.
     * @example
     * // Count the number of TipoEntradas
     * const count = await prisma.tipoEntrada.count({
     *   where: {
     *     // ... the filter for the TipoEntradas we want to count
     *   }
     * })
    **/
    count<T extends TipoEntradaCountArgs>(
      args?: Subset<T, TipoEntradaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TipoEntradaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TipoEntrada.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoEntradaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TipoEntradaAggregateArgs>(args: Subset<T, TipoEntradaAggregateArgs>): Prisma.PrismaPromise<GetTipoEntradaAggregateType<T>>

    /**
     * Group by TipoEntrada.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TipoEntradaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TipoEntradaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TipoEntradaGroupByArgs['orderBy'] }
        : { orderBy?: TipoEntradaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TipoEntradaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTipoEntradaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TipoEntrada model
   */
  readonly fields: TipoEntradaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TipoEntrada.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TipoEntradaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessoesAssentos<T extends TipoEntrada$sessoesAssentosArgs<ExtArgs> = {}>(args?: Subset<T, TipoEntrada$sessoesAssentosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessaoAssentoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TipoEntrada model
   */
  interface TipoEntradaFieldRefs {
    readonly id: FieldRef<"TipoEntrada", 'Int'>
    readonly nome: FieldRef<"TipoEntrada", 'String'>
    readonly ativo: FieldRef<"TipoEntrada", 'Boolean'>
    readonly criadoEm: FieldRef<"TipoEntrada", 'DateTime'>
    readonly atualizadoEm: FieldRef<"TipoEntrada", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TipoEntrada findUnique
   */
  export type TipoEntradaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEntrada
     */
    select?: TipoEntradaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEntrada
     */
    omit?: TipoEntradaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoEntradaInclude<ExtArgs> | null
    /**
     * Filter, which TipoEntrada to fetch.
     */
    where: TipoEntradaWhereUniqueInput
  }

  /**
   * TipoEntrada findUniqueOrThrow
   */
  export type TipoEntradaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEntrada
     */
    select?: TipoEntradaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEntrada
     */
    omit?: TipoEntradaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoEntradaInclude<ExtArgs> | null
    /**
     * Filter, which TipoEntrada to fetch.
     */
    where: TipoEntradaWhereUniqueInput
  }

  /**
   * TipoEntrada findFirst
   */
  export type TipoEntradaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEntrada
     */
    select?: TipoEntradaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEntrada
     */
    omit?: TipoEntradaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoEntradaInclude<ExtArgs> | null
    /**
     * Filter, which TipoEntrada to fetch.
     */
    where?: TipoEntradaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoEntradas to fetch.
     */
    orderBy?: TipoEntradaOrderByWithRelationInput | TipoEntradaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoEntradas.
     */
    cursor?: TipoEntradaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoEntradas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoEntradas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoEntradas.
     */
    distinct?: TipoEntradaScalarFieldEnum | TipoEntradaScalarFieldEnum[]
  }

  /**
   * TipoEntrada findFirstOrThrow
   */
  export type TipoEntradaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEntrada
     */
    select?: TipoEntradaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEntrada
     */
    omit?: TipoEntradaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoEntradaInclude<ExtArgs> | null
    /**
     * Filter, which TipoEntrada to fetch.
     */
    where?: TipoEntradaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoEntradas to fetch.
     */
    orderBy?: TipoEntradaOrderByWithRelationInput | TipoEntradaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TipoEntradas.
     */
    cursor?: TipoEntradaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoEntradas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoEntradas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TipoEntradas.
     */
    distinct?: TipoEntradaScalarFieldEnum | TipoEntradaScalarFieldEnum[]
  }

  /**
   * TipoEntrada findMany
   */
  export type TipoEntradaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEntrada
     */
    select?: TipoEntradaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEntrada
     */
    omit?: TipoEntradaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoEntradaInclude<ExtArgs> | null
    /**
     * Filter, which TipoEntradas to fetch.
     */
    where?: TipoEntradaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TipoEntradas to fetch.
     */
    orderBy?: TipoEntradaOrderByWithRelationInput | TipoEntradaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TipoEntradas.
     */
    cursor?: TipoEntradaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TipoEntradas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TipoEntradas.
     */
    skip?: number
    distinct?: TipoEntradaScalarFieldEnum | TipoEntradaScalarFieldEnum[]
  }

  /**
   * TipoEntrada create
   */
  export type TipoEntradaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEntrada
     */
    select?: TipoEntradaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEntrada
     */
    omit?: TipoEntradaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoEntradaInclude<ExtArgs> | null
    /**
     * The data needed to create a TipoEntrada.
     */
    data: XOR<TipoEntradaCreateInput, TipoEntradaUncheckedCreateInput>
  }

  /**
   * TipoEntrada createMany
   */
  export type TipoEntradaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TipoEntradas.
     */
    data: TipoEntradaCreateManyInput | TipoEntradaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoEntrada createManyAndReturn
   */
  export type TipoEntradaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEntrada
     */
    select?: TipoEntradaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEntrada
     */
    omit?: TipoEntradaOmit<ExtArgs> | null
    /**
     * The data used to create many TipoEntradas.
     */
    data: TipoEntradaCreateManyInput | TipoEntradaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TipoEntrada update
   */
  export type TipoEntradaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEntrada
     */
    select?: TipoEntradaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEntrada
     */
    omit?: TipoEntradaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoEntradaInclude<ExtArgs> | null
    /**
     * The data needed to update a TipoEntrada.
     */
    data: XOR<TipoEntradaUpdateInput, TipoEntradaUncheckedUpdateInput>
    /**
     * Choose, which TipoEntrada to update.
     */
    where: TipoEntradaWhereUniqueInput
  }

  /**
   * TipoEntrada updateMany
   */
  export type TipoEntradaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TipoEntradas.
     */
    data: XOR<TipoEntradaUpdateManyMutationInput, TipoEntradaUncheckedUpdateManyInput>
    /**
     * Filter which TipoEntradas to update
     */
    where?: TipoEntradaWhereInput
    /**
     * Limit how many TipoEntradas to update.
     */
    limit?: number
  }

  /**
   * TipoEntrada updateManyAndReturn
   */
  export type TipoEntradaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEntrada
     */
    select?: TipoEntradaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEntrada
     */
    omit?: TipoEntradaOmit<ExtArgs> | null
    /**
     * The data used to update TipoEntradas.
     */
    data: XOR<TipoEntradaUpdateManyMutationInput, TipoEntradaUncheckedUpdateManyInput>
    /**
     * Filter which TipoEntradas to update
     */
    where?: TipoEntradaWhereInput
    /**
     * Limit how many TipoEntradas to update.
     */
    limit?: number
  }

  /**
   * TipoEntrada upsert
   */
  export type TipoEntradaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEntrada
     */
    select?: TipoEntradaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEntrada
     */
    omit?: TipoEntradaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoEntradaInclude<ExtArgs> | null
    /**
     * The filter to search for the TipoEntrada to update in case it exists.
     */
    where: TipoEntradaWhereUniqueInput
    /**
     * In case the TipoEntrada found by the `where` argument doesn't exist, create a new TipoEntrada with this data.
     */
    create: XOR<TipoEntradaCreateInput, TipoEntradaUncheckedCreateInput>
    /**
     * In case the TipoEntrada was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TipoEntradaUpdateInput, TipoEntradaUncheckedUpdateInput>
  }

  /**
   * TipoEntrada delete
   */
  export type TipoEntradaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEntrada
     */
    select?: TipoEntradaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEntrada
     */
    omit?: TipoEntradaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoEntradaInclude<ExtArgs> | null
    /**
     * Filter which TipoEntrada to delete.
     */
    where: TipoEntradaWhereUniqueInput
  }

  /**
   * TipoEntrada deleteMany
   */
  export type TipoEntradaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TipoEntradas to delete
     */
    where?: TipoEntradaWhereInput
    /**
     * Limit how many TipoEntradas to delete.
     */
    limit?: number
  }

  /**
   * TipoEntrada.sessoesAssentos
   */
  export type TipoEntrada$sessoesAssentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessaoAssento
     */
    select?: SessaoAssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessaoAssento
     */
    omit?: SessaoAssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoAssentoInclude<ExtArgs> | null
    where?: SessaoAssentoWhereInput
    orderBy?: SessaoAssentoOrderByWithRelationInput | SessaoAssentoOrderByWithRelationInput[]
    cursor?: SessaoAssentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessaoAssentoScalarFieldEnum | SessaoAssentoScalarFieldEnum[]
  }

  /**
   * TipoEntrada without action
   */
  export type TipoEntradaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TipoEntrada
     */
    select?: TipoEntradaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TipoEntrada
     */
    omit?: TipoEntradaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TipoEntradaInclude<ExtArgs> | null
  }


  /**
   * Model Ingresso
   */

  export type AggregateIngresso = {
    _count: IngressoCountAggregateOutputType | null
    _avg: IngressoAvgAggregateOutputType | null
    _sum: IngressoSumAggregateOutputType | null
    _min: IngressoMinAggregateOutputType | null
    _max: IngressoMaxAggregateOutputType | null
  }

  export type IngressoAvgAggregateOutputType = {
    id: number | null
    documentoResponsavel: number | null
  }

  export type IngressoSumAggregateOutputType = {
    id: number | null
    documentoResponsavel: number | null
  }

  export type IngressoMinAggregateOutputType = {
    id: number | null
    documentoResponsavel: number | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type IngressoMaxAggregateOutputType = {
    id: number | null
    documentoResponsavel: number | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type IngressoCountAggregateOutputType = {
    id: number
    documentoResponsavel: number
    ativo: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type IngressoAvgAggregateInputType = {
    id?: true
    documentoResponsavel?: true
  }

  export type IngressoSumAggregateInputType = {
    id?: true
    documentoResponsavel?: true
  }

  export type IngressoMinAggregateInputType = {
    id?: true
    documentoResponsavel?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type IngressoMaxAggregateInputType = {
    id?: true
    documentoResponsavel?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type IngressoCountAggregateInputType = {
    id?: true
    documentoResponsavel?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type IngressoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ingresso to aggregate.
     */
    where?: IngressoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ingressos to fetch.
     */
    orderBy?: IngressoOrderByWithRelationInput | IngressoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IngressoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ingressos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ingressos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ingressos
    **/
    _count?: true | IngressoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IngressoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IngressoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IngressoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IngressoMaxAggregateInputType
  }

  export type GetIngressoAggregateType<T extends IngressoAggregateArgs> = {
        [P in keyof T & keyof AggregateIngresso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIngresso[P]>
      : GetScalarType<T[P], AggregateIngresso[P]>
  }




  export type IngressoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IngressoWhereInput
    orderBy?: IngressoOrderByWithAggregationInput | IngressoOrderByWithAggregationInput[]
    by: IngressoScalarFieldEnum[] | IngressoScalarFieldEnum
    having?: IngressoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IngressoCountAggregateInputType | true
    _avg?: IngressoAvgAggregateInputType
    _sum?: IngressoSumAggregateInputType
    _min?: IngressoMinAggregateInputType
    _max?: IngressoMaxAggregateInputType
  }

  export type IngressoGroupByOutputType = {
    id: number
    documentoResponsavel: number
    ativo: boolean
    criadoEm: Date
    atualizadoEm: Date
    _count: IngressoCountAggregateOutputType | null
    _avg: IngressoAvgAggregateOutputType | null
    _sum: IngressoSumAggregateOutputType | null
    _min: IngressoMinAggregateOutputType | null
    _max: IngressoMaxAggregateOutputType | null
  }

  type GetIngressoGroupByPayload<T extends IngressoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IngressoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IngressoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IngressoGroupByOutputType[P]>
            : GetScalarType<T[P], IngressoGroupByOutputType[P]>
        }
      >
    >


  export type IngressoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentoResponsavel?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    sessoesAssentos?: boolean | Ingresso$sessoesAssentosArgs<ExtArgs>
    pagamento?: boolean | Ingresso$pagamentoArgs<ExtArgs>
    _count?: boolean | IngressoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ingresso"]>

  export type IngressoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentoResponsavel?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }, ExtArgs["result"]["ingresso"]>

  export type IngressoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentoResponsavel?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }, ExtArgs["result"]["ingresso"]>

  export type IngressoSelectScalar = {
    id?: boolean
    documentoResponsavel?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type IngressoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "documentoResponsavel" | "ativo" | "criadoEm" | "atualizadoEm", ExtArgs["result"]["ingresso"]>
  export type IngressoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessoesAssentos?: boolean | Ingresso$sessoesAssentosArgs<ExtArgs>
    pagamento?: boolean | Ingresso$pagamentoArgs<ExtArgs>
    _count?: boolean | IngressoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type IngressoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type IngressoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $IngressoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ingresso"
    objects: {
      sessoesAssentos: Prisma.$SessaoAssentoPayload<ExtArgs>[]
      pagamento: Prisma.$PagamentoPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      documentoResponsavel: number
      ativo: boolean
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["ingresso"]>
    composites: {}
  }

  type IngressoGetPayload<S extends boolean | null | undefined | IngressoDefaultArgs> = $Result.GetResult<Prisma.$IngressoPayload, S>

  type IngressoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IngressoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IngressoCountAggregateInputType | true
    }

  export interface IngressoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ingresso'], meta: { name: 'Ingresso' } }
    /**
     * Find zero or one Ingresso that matches the filter.
     * @param {IngressoFindUniqueArgs} args - Arguments to find a Ingresso
     * @example
     * // Get one Ingresso
     * const ingresso = await prisma.ingresso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IngressoFindUniqueArgs>(args: SelectSubset<T, IngressoFindUniqueArgs<ExtArgs>>): Prisma__IngressoClient<$Result.GetResult<Prisma.$IngressoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ingresso that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IngressoFindUniqueOrThrowArgs} args - Arguments to find a Ingresso
     * @example
     * // Get one Ingresso
     * const ingresso = await prisma.ingresso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IngressoFindUniqueOrThrowArgs>(args: SelectSubset<T, IngressoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IngressoClient<$Result.GetResult<Prisma.$IngressoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ingresso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngressoFindFirstArgs} args - Arguments to find a Ingresso
     * @example
     * // Get one Ingresso
     * const ingresso = await prisma.ingresso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IngressoFindFirstArgs>(args?: SelectSubset<T, IngressoFindFirstArgs<ExtArgs>>): Prisma__IngressoClient<$Result.GetResult<Prisma.$IngressoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ingresso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngressoFindFirstOrThrowArgs} args - Arguments to find a Ingresso
     * @example
     * // Get one Ingresso
     * const ingresso = await prisma.ingresso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IngressoFindFirstOrThrowArgs>(args?: SelectSubset<T, IngressoFindFirstOrThrowArgs<ExtArgs>>): Prisma__IngressoClient<$Result.GetResult<Prisma.$IngressoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Ingressos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngressoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ingressos
     * const ingressos = await prisma.ingresso.findMany()
     * 
     * // Get first 10 Ingressos
     * const ingressos = await prisma.ingresso.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ingressoWithIdOnly = await prisma.ingresso.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IngressoFindManyArgs>(args?: SelectSubset<T, IngressoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngressoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ingresso.
     * @param {IngressoCreateArgs} args - Arguments to create a Ingresso.
     * @example
     * // Create one Ingresso
     * const Ingresso = await prisma.ingresso.create({
     *   data: {
     *     // ... data to create a Ingresso
     *   }
     * })
     * 
     */
    create<T extends IngressoCreateArgs>(args: SelectSubset<T, IngressoCreateArgs<ExtArgs>>): Prisma__IngressoClient<$Result.GetResult<Prisma.$IngressoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Ingressos.
     * @param {IngressoCreateManyArgs} args - Arguments to create many Ingressos.
     * @example
     * // Create many Ingressos
     * const ingresso = await prisma.ingresso.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IngressoCreateManyArgs>(args?: SelectSubset<T, IngressoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Ingressos and returns the data saved in the database.
     * @param {IngressoCreateManyAndReturnArgs} args - Arguments to create many Ingressos.
     * @example
     * // Create many Ingressos
     * const ingresso = await prisma.ingresso.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Ingressos and only return the `id`
     * const ingressoWithIdOnly = await prisma.ingresso.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IngressoCreateManyAndReturnArgs>(args?: SelectSubset<T, IngressoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngressoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ingresso.
     * @param {IngressoDeleteArgs} args - Arguments to delete one Ingresso.
     * @example
     * // Delete one Ingresso
     * const Ingresso = await prisma.ingresso.delete({
     *   where: {
     *     // ... filter to delete one Ingresso
     *   }
     * })
     * 
     */
    delete<T extends IngressoDeleteArgs>(args: SelectSubset<T, IngressoDeleteArgs<ExtArgs>>): Prisma__IngressoClient<$Result.GetResult<Prisma.$IngressoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ingresso.
     * @param {IngressoUpdateArgs} args - Arguments to update one Ingresso.
     * @example
     * // Update one Ingresso
     * const ingresso = await prisma.ingresso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IngressoUpdateArgs>(args: SelectSubset<T, IngressoUpdateArgs<ExtArgs>>): Prisma__IngressoClient<$Result.GetResult<Prisma.$IngressoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Ingressos.
     * @param {IngressoDeleteManyArgs} args - Arguments to filter Ingressos to delete.
     * @example
     * // Delete a few Ingressos
     * const { count } = await prisma.ingresso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IngressoDeleteManyArgs>(args?: SelectSubset<T, IngressoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ingressos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngressoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ingressos
     * const ingresso = await prisma.ingresso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IngressoUpdateManyArgs>(args: SelectSubset<T, IngressoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ingressos and returns the data updated in the database.
     * @param {IngressoUpdateManyAndReturnArgs} args - Arguments to update many Ingressos.
     * @example
     * // Update many Ingressos
     * const ingresso = await prisma.ingresso.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Ingressos and only return the `id`
     * const ingressoWithIdOnly = await prisma.ingresso.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IngressoUpdateManyAndReturnArgs>(args: SelectSubset<T, IngressoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IngressoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ingresso.
     * @param {IngressoUpsertArgs} args - Arguments to update or create a Ingresso.
     * @example
     * // Update or create a Ingresso
     * const ingresso = await prisma.ingresso.upsert({
     *   create: {
     *     // ... data to create a Ingresso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ingresso we want to update
     *   }
     * })
     */
    upsert<T extends IngressoUpsertArgs>(args: SelectSubset<T, IngressoUpsertArgs<ExtArgs>>): Prisma__IngressoClient<$Result.GetResult<Prisma.$IngressoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Ingressos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngressoCountArgs} args - Arguments to filter Ingressos to count.
     * @example
     * // Count the number of Ingressos
     * const count = await prisma.ingresso.count({
     *   where: {
     *     // ... the filter for the Ingressos we want to count
     *   }
     * })
    **/
    count<T extends IngressoCountArgs>(
      args?: Subset<T, IngressoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IngressoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ingresso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngressoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IngressoAggregateArgs>(args: Subset<T, IngressoAggregateArgs>): Prisma.PrismaPromise<GetIngressoAggregateType<T>>

    /**
     * Group by Ingresso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IngressoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IngressoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IngressoGroupByArgs['orderBy'] }
        : { orderBy?: IngressoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IngressoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIngressoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ingresso model
   */
  readonly fields: IngressoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ingresso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IngressoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessoesAssentos<T extends Ingresso$sessoesAssentosArgs<ExtArgs> = {}>(args?: Subset<T, Ingresso$sessoesAssentosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessaoAssentoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pagamento<T extends Ingresso$pagamentoArgs<ExtArgs> = {}>(args?: Subset<T, Ingresso$pagamentoArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ingresso model
   */
  interface IngressoFieldRefs {
    readonly id: FieldRef<"Ingresso", 'Int'>
    readonly documentoResponsavel: FieldRef<"Ingresso", 'Int'>
    readonly ativo: FieldRef<"Ingresso", 'Boolean'>
    readonly criadoEm: FieldRef<"Ingresso", 'DateTime'>
    readonly atualizadoEm: FieldRef<"Ingresso", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ingresso findUnique
   */
  export type IngressoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingresso
     */
    select?: IngressoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ingresso
     */
    omit?: IngressoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngressoInclude<ExtArgs> | null
    /**
     * Filter, which Ingresso to fetch.
     */
    where: IngressoWhereUniqueInput
  }

  /**
   * Ingresso findUniqueOrThrow
   */
  export type IngressoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingresso
     */
    select?: IngressoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ingresso
     */
    omit?: IngressoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngressoInclude<ExtArgs> | null
    /**
     * Filter, which Ingresso to fetch.
     */
    where: IngressoWhereUniqueInput
  }

  /**
   * Ingresso findFirst
   */
  export type IngressoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingresso
     */
    select?: IngressoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ingresso
     */
    omit?: IngressoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngressoInclude<ExtArgs> | null
    /**
     * Filter, which Ingresso to fetch.
     */
    where?: IngressoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ingressos to fetch.
     */
    orderBy?: IngressoOrderByWithRelationInput | IngressoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ingressos.
     */
    cursor?: IngressoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ingressos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ingressos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ingressos.
     */
    distinct?: IngressoScalarFieldEnum | IngressoScalarFieldEnum[]
  }

  /**
   * Ingresso findFirstOrThrow
   */
  export type IngressoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingresso
     */
    select?: IngressoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ingresso
     */
    omit?: IngressoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngressoInclude<ExtArgs> | null
    /**
     * Filter, which Ingresso to fetch.
     */
    where?: IngressoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ingressos to fetch.
     */
    orderBy?: IngressoOrderByWithRelationInput | IngressoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ingressos.
     */
    cursor?: IngressoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ingressos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ingressos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ingressos.
     */
    distinct?: IngressoScalarFieldEnum | IngressoScalarFieldEnum[]
  }

  /**
   * Ingresso findMany
   */
  export type IngressoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingresso
     */
    select?: IngressoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ingresso
     */
    omit?: IngressoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngressoInclude<ExtArgs> | null
    /**
     * Filter, which Ingressos to fetch.
     */
    where?: IngressoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ingressos to fetch.
     */
    orderBy?: IngressoOrderByWithRelationInput | IngressoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ingressos.
     */
    cursor?: IngressoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ingressos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ingressos.
     */
    skip?: number
    distinct?: IngressoScalarFieldEnum | IngressoScalarFieldEnum[]
  }

  /**
   * Ingresso create
   */
  export type IngressoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingresso
     */
    select?: IngressoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ingresso
     */
    omit?: IngressoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngressoInclude<ExtArgs> | null
    /**
     * The data needed to create a Ingresso.
     */
    data: XOR<IngressoCreateInput, IngressoUncheckedCreateInput>
  }

  /**
   * Ingresso createMany
   */
  export type IngressoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ingressos.
     */
    data: IngressoCreateManyInput | IngressoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ingresso createManyAndReturn
   */
  export type IngressoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingresso
     */
    select?: IngressoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ingresso
     */
    omit?: IngressoOmit<ExtArgs> | null
    /**
     * The data used to create many Ingressos.
     */
    data: IngressoCreateManyInput | IngressoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ingresso update
   */
  export type IngressoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingresso
     */
    select?: IngressoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ingresso
     */
    omit?: IngressoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngressoInclude<ExtArgs> | null
    /**
     * The data needed to update a Ingresso.
     */
    data: XOR<IngressoUpdateInput, IngressoUncheckedUpdateInput>
    /**
     * Choose, which Ingresso to update.
     */
    where: IngressoWhereUniqueInput
  }

  /**
   * Ingresso updateMany
   */
  export type IngressoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ingressos.
     */
    data: XOR<IngressoUpdateManyMutationInput, IngressoUncheckedUpdateManyInput>
    /**
     * Filter which Ingressos to update
     */
    where?: IngressoWhereInput
    /**
     * Limit how many Ingressos to update.
     */
    limit?: number
  }

  /**
   * Ingresso updateManyAndReturn
   */
  export type IngressoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingresso
     */
    select?: IngressoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ingresso
     */
    omit?: IngressoOmit<ExtArgs> | null
    /**
     * The data used to update Ingressos.
     */
    data: XOR<IngressoUpdateManyMutationInput, IngressoUncheckedUpdateManyInput>
    /**
     * Filter which Ingressos to update
     */
    where?: IngressoWhereInput
    /**
     * Limit how many Ingressos to update.
     */
    limit?: number
  }

  /**
   * Ingresso upsert
   */
  export type IngressoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingresso
     */
    select?: IngressoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ingresso
     */
    omit?: IngressoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngressoInclude<ExtArgs> | null
    /**
     * The filter to search for the Ingresso to update in case it exists.
     */
    where: IngressoWhereUniqueInput
    /**
     * In case the Ingresso found by the `where` argument doesn't exist, create a new Ingresso with this data.
     */
    create: XOR<IngressoCreateInput, IngressoUncheckedCreateInput>
    /**
     * In case the Ingresso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IngressoUpdateInput, IngressoUncheckedUpdateInput>
  }

  /**
   * Ingresso delete
   */
  export type IngressoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingresso
     */
    select?: IngressoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ingresso
     */
    omit?: IngressoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngressoInclude<ExtArgs> | null
    /**
     * Filter which Ingresso to delete.
     */
    where: IngressoWhereUniqueInput
  }

  /**
   * Ingresso deleteMany
   */
  export type IngressoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ingressos to delete
     */
    where?: IngressoWhereInput
    /**
     * Limit how many Ingressos to delete.
     */
    limit?: number
  }

  /**
   * Ingresso.sessoesAssentos
   */
  export type Ingresso$sessoesAssentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SessaoAssento
     */
    select?: SessaoAssentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SessaoAssento
     */
    omit?: SessaoAssentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessaoAssentoInclude<ExtArgs> | null
    where?: SessaoAssentoWhereInput
    orderBy?: SessaoAssentoOrderByWithRelationInput | SessaoAssentoOrderByWithRelationInput[]
    cursor?: SessaoAssentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessaoAssentoScalarFieldEnum | SessaoAssentoScalarFieldEnum[]
  }

  /**
   * Ingresso.pagamento
   */
  export type Ingresso$pagamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pagamento
     */
    omit?: PagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    where?: PagamentoWhereInput
  }

  /**
   * Ingresso without action
   */
  export type IngressoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ingresso
     */
    select?: IngressoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ingresso
     */
    omit?: IngressoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IngressoInclude<ExtArgs> | null
  }


  /**
   * Model FormaPagamento
   */

  export type AggregateFormaPagamento = {
    _count: FormaPagamentoCountAggregateOutputType | null
    _avg: FormaPagamentoAvgAggregateOutputType | null
    _sum: FormaPagamentoSumAggregateOutputType | null
    _min: FormaPagamentoMinAggregateOutputType | null
    _max: FormaPagamentoMaxAggregateOutputType | null
  }

  export type FormaPagamentoAvgAggregateOutputType = {
    id: number | null
  }

  export type FormaPagamentoSumAggregateOutputType = {
    id: number | null
  }

  export type FormaPagamentoMinAggregateOutputType = {
    id: number | null
    nome: string | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type FormaPagamentoMaxAggregateOutputType = {
    id: number | null
    nome: string | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type FormaPagamentoCountAggregateOutputType = {
    id: number
    nome: number
    ativo: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type FormaPagamentoAvgAggregateInputType = {
    id?: true
  }

  export type FormaPagamentoSumAggregateInputType = {
    id?: true
  }

  export type FormaPagamentoMinAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type FormaPagamentoMaxAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type FormaPagamentoCountAggregateInputType = {
    id?: true
    nome?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type FormaPagamentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormaPagamento to aggregate.
     */
    where?: FormaPagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormaPagamentos to fetch.
     */
    orderBy?: FormaPagamentoOrderByWithRelationInput | FormaPagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FormaPagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormaPagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormaPagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FormaPagamentos
    **/
    _count?: true | FormaPagamentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FormaPagamentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FormaPagamentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormaPagamentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormaPagamentoMaxAggregateInputType
  }

  export type GetFormaPagamentoAggregateType<T extends FormaPagamentoAggregateArgs> = {
        [P in keyof T & keyof AggregateFormaPagamento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormaPagamento[P]>
      : GetScalarType<T[P], AggregateFormaPagamento[P]>
  }




  export type FormaPagamentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FormaPagamentoWhereInput
    orderBy?: FormaPagamentoOrderByWithAggregationInput | FormaPagamentoOrderByWithAggregationInput[]
    by: FormaPagamentoScalarFieldEnum[] | FormaPagamentoScalarFieldEnum
    having?: FormaPagamentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormaPagamentoCountAggregateInputType | true
    _avg?: FormaPagamentoAvgAggregateInputType
    _sum?: FormaPagamentoSumAggregateInputType
    _min?: FormaPagamentoMinAggregateInputType
    _max?: FormaPagamentoMaxAggregateInputType
  }

  export type FormaPagamentoGroupByOutputType = {
    id: number
    nome: string
    ativo: boolean
    criadoEm: Date
    atualizadoEm: Date
    _count: FormaPagamentoCountAggregateOutputType | null
    _avg: FormaPagamentoAvgAggregateOutputType | null
    _sum: FormaPagamentoSumAggregateOutputType | null
    _min: FormaPagamentoMinAggregateOutputType | null
    _max: FormaPagamentoMaxAggregateOutputType | null
  }

  type GetFormaPagamentoGroupByPayload<T extends FormaPagamentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormaPagamentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormaPagamentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormaPagamentoGroupByOutputType[P]>
            : GetScalarType<T[P], FormaPagamentoGroupByOutputType[P]>
        }
      >
    >


  export type FormaPagamentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    pagamentos?: boolean | FormaPagamento$pagamentosArgs<ExtArgs>
    _count?: boolean | FormaPagamentoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formaPagamento"]>

  export type FormaPagamentoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }, ExtArgs["result"]["formaPagamento"]>

  export type FormaPagamentoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }, ExtArgs["result"]["formaPagamento"]>

  export type FormaPagamentoSelectScalar = {
    id?: boolean
    nome?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type FormaPagamentoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nome" | "ativo" | "criadoEm" | "atualizadoEm", ExtArgs["result"]["formaPagamento"]>
  export type FormaPagamentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pagamentos?: boolean | FormaPagamento$pagamentosArgs<ExtArgs>
    _count?: boolean | FormaPagamentoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FormaPagamentoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FormaPagamentoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FormaPagamentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FormaPagamento"
    objects: {
      pagamentos: Prisma.$PagamentoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nome: string
      ativo: boolean
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["formaPagamento"]>
    composites: {}
  }

  type FormaPagamentoGetPayload<S extends boolean | null | undefined | FormaPagamentoDefaultArgs> = $Result.GetResult<Prisma.$FormaPagamentoPayload, S>

  type FormaPagamentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FormaPagamentoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FormaPagamentoCountAggregateInputType | true
    }

  export interface FormaPagamentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FormaPagamento'], meta: { name: 'FormaPagamento' } }
    /**
     * Find zero or one FormaPagamento that matches the filter.
     * @param {FormaPagamentoFindUniqueArgs} args - Arguments to find a FormaPagamento
     * @example
     * // Get one FormaPagamento
     * const formaPagamento = await prisma.formaPagamento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FormaPagamentoFindUniqueArgs>(args: SelectSubset<T, FormaPagamentoFindUniqueArgs<ExtArgs>>): Prisma__FormaPagamentoClient<$Result.GetResult<Prisma.$FormaPagamentoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FormaPagamento that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FormaPagamentoFindUniqueOrThrowArgs} args - Arguments to find a FormaPagamento
     * @example
     * // Get one FormaPagamento
     * const formaPagamento = await prisma.formaPagamento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FormaPagamentoFindUniqueOrThrowArgs>(args: SelectSubset<T, FormaPagamentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FormaPagamentoClient<$Result.GetResult<Prisma.$FormaPagamentoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormaPagamento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormaPagamentoFindFirstArgs} args - Arguments to find a FormaPagamento
     * @example
     * // Get one FormaPagamento
     * const formaPagamento = await prisma.formaPagamento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FormaPagamentoFindFirstArgs>(args?: SelectSubset<T, FormaPagamentoFindFirstArgs<ExtArgs>>): Prisma__FormaPagamentoClient<$Result.GetResult<Prisma.$FormaPagamentoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FormaPagamento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormaPagamentoFindFirstOrThrowArgs} args - Arguments to find a FormaPagamento
     * @example
     * // Get one FormaPagamento
     * const formaPagamento = await prisma.formaPagamento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FormaPagamentoFindFirstOrThrowArgs>(args?: SelectSubset<T, FormaPagamentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__FormaPagamentoClient<$Result.GetResult<Prisma.$FormaPagamentoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FormaPagamentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormaPagamentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FormaPagamentos
     * const formaPagamentos = await prisma.formaPagamento.findMany()
     * 
     * // Get first 10 FormaPagamentos
     * const formaPagamentos = await prisma.formaPagamento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const formaPagamentoWithIdOnly = await prisma.formaPagamento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FormaPagamentoFindManyArgs>(args?: SelectSubset<T, FormaPagamentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormaPagamentoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FormaPagamento.
     * @param {FormaPagamentoCreateArgs} args - Arguments to create a FormaPagamento.
     * @example
     * // Create one FormaPagamento
     * const FormaPagamento = await prisma.formaPagamento.create({
     *   data: {
     *     // ... data to create a FormaPagamento
     *   }
     * })
     * 
     */
    create<T extends FormaPagamentoCreateArgs>(args: SelectSubset<T, FormaPagamentoCreateArgs<ExtArgs>>): Prisma__FormaPagamentoClient<$Result.GetResult<Prisma.$FormaPagamentoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FormaPagamentos.
     * @param {FormaPagamentoCreateManyArgs} args - Arguments to create many FormaPagamentos.
     * @example
     * // Create many FormaPagamentos
     * const formaPagamento = await prisma.formaPagamento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FormaPagamentoCreateManyArgs>(args?: SelectSubset<T, FormaPagamentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FormaPagamentos and returns the data saved in the database.
     * @param {FormaPagamentoCreateManyAndReturnArgs} args - Arguments to create many FormaPagamentos.
     * @example
     * // Create many FormaPagamentos
     * const formaPagamento = await prisma.formaPagamento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FormaPagamentos and only return the `id`
     * const formaPagamentoWithIdOnly = await prisma.formaPagamento.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FormaPagamentoCreateManyAndReturnArgs>(args?: SelectSubset<T, FormaPagamentoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormaPagamentoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FormaPagamento.
     * @param {FormaPagamentoDeleteArgs} args - Arguments to delete one FormaPagamento.
     * @example
     * // Delete one FormaPagamento
     * const FormaPagamento = await prisma.formaPagamento.delete({
     *   where: {
     *     // ... filter to delete one FormaPagamento
     *   }
     * })
     * 
     */
    delete<T extends FormaPagamentoDeleteArgs>(args: SelectSubset<T, FormaPagamentoDeleteArgs<ExtArgs>>): Prisma__FormaPagamentoClient<$Result.GetResult<Prisma.$FormaPagamentoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FormaPagamento.
     * @param {FormaPagamentoUpdateArgs} args - Arguments to update one FormaPagamento.
     * @example
     * // Update one FormaPagamento
     * const formaPagamento = await prisma.formaPagamento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FormaPagamentoUpdateArgs>(args: SelectSubset<T, FormaPagamentoUpdateArgs<ExtArgs>>): Prisma__FormaPagamentoClient<$Result.GetResult<Prisma.$FormaPagamentoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FormaPagamentos.
     * @param {FormaPagamentoDeleteManyArgs} args - Arguments to filter FormaPagamentos to delete.
     * @example
     * // Delete a few FormaPagamentos
     * const { count } = await prisma.formaPagamento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FormaPagamentoDeleteManyArgs>(args?: SelectSubset<T, FormaPagamentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormaPagamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormaPagamentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FormaPagamentos
     * const formaPagamento = await prisma.formaPagamento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FormaPagamentoUpdateManyArgs>(args: SelectSubset<T, FormaPagamentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FormaPagamentos and returns the data updated in the database.
     * @param {FormaPagamentoUpdateManyAndReturnArgs} args - Arguments to update many FormaPagamentos.
     * @example
     * // Update many FormaPagamentos
     * const formaPagamento = await prisma.formaPagamento.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FormaPagamentos and only return the `id`
     * const formaPagamentoWithIdOnly = await prisma.formaPagamento.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FormaPagamentoUpdateManyAndReturnArgs>(args: SelectSubset<T, FormaPagamentoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FormaPagamentoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FormaPagamento.
     * @param {FormaPagamentoUpsertArgs} args - Arguments to update or create a FormaPagamento.
     * @example
     * // Update or create a FormaPagamento
     * const formaPagamento = await prisma.formaPagamento.upsert({
     *   create: {
     *     // ... data to create a FormaPagamento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FormaPagamento we want to update
     *   }
     * })
     */
    upsert<T extends FormaPagamentoUpsertArgs>(args: SelectSubset<T, FormaPagamentoUpsertArgs<ExtArgs>>): Prisma__FormaPagamentoClient<$Result.GetResult<Prisma.$FormaPagamentoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FormaPagamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormaPagamentoCountArgs} args - Arguments to filter FormaPagamentos to count.
     * @example
     * // Count the number of FormaPagamentos
     * const count = await prisma.formaPagamento.count({
     *   where: {
     *     // ... the filter for the FormaPagamentos we want to count
     *   }
     * })
    **/
    count<T extends FormaPagamentoCountArgs>(
      args?: Subset<T, FormaPagamentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormaPagamentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FormaPagamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormaPagamentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormaPagamentoAggregateArgs>(args: Subset<T, FormaPagamentoAggregateArgs>): Prisma.PrismaPromise<GetFormaPagamentoAggregateType<T>>

    /**
     * Group by FormaPagamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormaPagamentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FormaPagamentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FormaPagamentoGroupByArgs['orderBy'] }
        : { orderBy?: FormaPagamentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FormaPagamentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormaPagamentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FormaPagamento model
   */
  readonly fields: FormaPagamentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FormaPagamento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FormaPagamentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pagamentos<T extends FormaPagamento$pagamentosArgs<ExtArgs> = {}>(args?: Subset<T, FormaPagamento$pagamentosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FormaPagamento model
   */
  interface FormaPagamentoFieldRefs {
    readonly id: FieldRef<"FormaPagamento", 'Int'>
    readonly nome: FieldRef<"FormaPagamento", 'String'>
    readonly ativo: FieldRef<"FormaPagamento", 'Boolean'>
    readonly criadoEm: FieldRef<"FormaPagamento", 'DateTime'>
    readonly atualizadoEm: FieldRef<"FormaPagamento", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FormaPagamento findUnique
   */
  export type FormaPagamentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormaPagamento
     */
    select?: FormaPagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormaPagamento
     */
    omit?: FormaPagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormaPagamentoInclude<ExtArgs> | null
    /**
     * Filter, which FormaPagamento to fetch.
     */
    where: FormaPagamentoWhereUniqueInput
  }

  /**
   * FormaPagamento findUniqueOrThrow
   */
  export type FormaPagamentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormaPagamento
     */
    select?: FormaPagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormaPagamento
     */
    omit?: FormaPagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormaPagamentoInclude<ExtArgs> | null
    /**
     * Filter, which FormaPagamento to fetch.
     */
    where: FormaPagamentoWhereUniqueInput
  }

  /**
   * FormaPagamento findFirst
   */
  export type FormaPagamentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormaPagamento
     */
    select?: FormaPagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormaPagamento
     */
    omit?: FormaPagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormaPagamentoInclude<ExtArgs> | null
    /**
     * Filter, which FormaPagamento to fetch.
     */
    where?: FormaPagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormaPagamentos to fetch.
     */
    orderBy?: FormaPagamentoOrderByWithRelationInput | FormaPagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormaPagamentos.
     */
    cursor?: FormaPagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormaPagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormaPagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormaPagamentos.
     */
    distinct?: FormaPagamentoScalarFieldEnum | FormaPagamentoScalarFieldEnum[]
  }

  /**
   * FormaPagamento findFirstOrThrow
   */
  export type FormaPagamentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormaPagamento
     */
    select?: FormaPagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormaPagamento
     */
    omit?: FormaPagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormaPagamentoInclude<ExtArgs> | null
    /**
     * Filter, which FormaPagamento to fetch.
     */
    where?: FormaPagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormaPagamentos to fetch.
     */
    orderBy?: FormaPagamentoOrderByWithRelationInput | FormaPagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FormaPagamentos.
     */
    cursor?: FormaPagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormaPagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormaPagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FormaPagamentos.
     */
    distinct?: FormaPagamentoScalarFieldEnum | FormaPagamentoScalarFieldEnum[]
  }

  /**
   * FormaPagamento findMany
   */
  export type FormaPagamentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormaPagamento
     */
    select?: FormaPagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormaPagamento
     */
    omit?: FormaPagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormaPagamentoInclude<ExtArgs> | null
    /**
     * Filter, which FormaPagamentos to fetch.
     */
    where?: FormaPagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FormaPagamentos to fetch.
     */
    orderBy?: FormaPagamentoOrderByWithRelationInput | FormaPagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FormaPagamentos.
     */
    cursor?: FormaPagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FormaPagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FormaPagamentos.
     */
    skip?: number
    distinct?: FormaPagamentoScalarFieldEnum | FormaPagamentoScalarFieldEnum[]
  }

  /**
   * FormaPagamento create
   */
  export type FormaPagamentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormaPagamento
     */
    select?: FormaPagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormaPagamento
     */
    omit?: FormaPagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormaPagamentoInclude<ExtArgs> | null
    /**
     * The data needed to create a FormaPagamento.
     */
    data: XOR<FormaPagamentoCreateInput, FormaPagamentoUncheckedCreateInput>
  }

  /**
   * FormaPagamento createMany
   */
  export type FormaPagamentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FormaPagamentos.
     */
    data: FormaPagamentoCreateManyInput | FormaPagamentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormaPagamento createManyAndReturn
   */
  export type FormaPagamentoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormaPagamento
     */
    select?: FormaPagamentoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FormaPagamento
     */
    omit?: FormaPagamentoOmit<ExtArgs> | null
    /**
     * The data used to create many FormaPagamentos.
     */
    data: FormaPagamentoCreateManyInput | FormaPagamentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FormaPagamento update
   */
  export type FormaPagamentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormaPagamento
     */
    select?: FormaPagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormaPagamento
     */
    omit?: FormaPagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormaPagamentoInclude<ExtArgs> | null
    /**
     * The data needed to update a FormaPagamento.
     */
    data: XOR<FormaPagamentoUpdateInput, FormaPagamentoUncheckedUpdateInput>
    /**
     * Choose, which FormaPagamento to update.
     */
    where: FormaPagamentoWhereUniqueInput
  }

  /**
   * FormaPagamento updateMany
   */
  export type FormaPagamentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FormaPagamentos.
     */
    data: XOR<FormaPagamentoUpdateManyMutationInput, FormaPagamentoUncheckedUpdateManyInput>
    /**
     * Filter which FormaPagamentos to update
     */
    where?: FormaPagamentoWhereInput
    /**
     * Limit how many FormaPagamentos to update.
     */
    limit?: number
  }

  /**
   * FormaPagamento updateManyAndReturn
   */
  export type FormaPagamentoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormaPagamento
     */
    select?: FormaPagamentoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FormaPagamento
     */
    omit?: FormaPagamentoOmit<ExtArgs> | null
    /**
     * The data used to update FormaPagamentos.
     */
    data: XOR<FormaPagamentoUpdateManyMutationInput, FormaPagamentoUncheckedUpdateManyInput>
    /**
     * Filter which FormaPagamentos to update
     */
    where?: FormaPagamentoWhereInput
    /**
     * Limit how many FormaPagamentos to update.
     */
    limit?: number
  }

  /**
   * FormaPagamento upsert
   */
  export type FormaPagamentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormaPagamento
     */
    select?: FormaPagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormaPagamento
     */
    omit?: FormaPagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormaPagamentoInclude<ExtArgs> | null
    /**
     * The filter to search for the FormaPagamento to update in case it exists.
     */
    where: FormaPagamentoWhereUniqueInput
    /**
     * In case the FormaPagamento found by the `where` argument doesn't exist, create a new FormaPagamento with this data.
     */
    create: XOR<FormaPagamentoCreateInput, FormaPagamentoUncheckedCreateInput>
    /**
     * In case the FormaPagamento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FormaPagamentoUpdateInput, FormaPagamentoUncheckedUpdateInput>
  }

  /**
   * FormaPagamento delete
   */
  export type FormaPagamentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormaPagamento
     */
    select?: FormaPagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormaPagamento
     */
    omit?: FormaPagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormaPagamentoInclude<ExtArgs> | null
    /**
     * Filter which FormaPagamento to delete.
     */
    where: FormaPagamentoWhereUniqueInput
  }

  /**
   * FormaPagamento deleteMany
   */
  export type FormaPagamentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FormaPagamentos to delete
     */
    where?: FormaPagamentoWhereInput
    /**
     * Limit how many FormaPagamentos to delete.
     */
    limit?: number
  }

  /**
   * FormaPagamento.pagamentos
   */
  export type FormaPagamento$pagamentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pagamento
     */
    omit?: PagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    where?: PagamentoWhereInput
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    cursor?: PagamentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PagamentoScalarFieldEnum | PagamentoScalarFieldEnum[]
  }

  /**
   * FormaPagamento without action
   */
  export type FormaPagamentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FormaPagamento
     */
    select?: FormaPagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FormaPagamento
     */
    omit?: FormaPagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FormaPagamentoInclude<ExtArgs> | null
  }


  /**
   * Model Pagamento
   */

  export type AggregatePagamento = {
    _count: PagamentoCountAggregateOutputType | null
    _avg: PagamentoAvgAggregateOutputType | null
    _sum: PagamentoSumAggregateOutputType | null
    _min: PagamentoMinAggregateOutputType | null
    _max: PagamentoMaxAggregateOutputType | null
  }

  export type PagamentoAvgAggregateOutputType = {
    id: number | null
    ingressoId: number | null
    formaPagamentoId: number | null
    valorTotal: number | null
  }

  export type PagamentoSumAggregateOutputType = {
    id: number | null
    ingressoId: number | null
    formaPagamentoId: number | null
    valorTotal: number | null
  }

  export type PagamentoMinAggregateOutputType = {
    id: number | null
    ingressoId: number | null
    formaPagamentoId: number | null
    valorTotal: number | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type PagamentoMaxAggregateOutputType = {
    id: number | null
    ingressoId: number | null
    formaPagamentoId: number | null
    valorTotal: number | null
    ativo: boolean | null
    criadoEm: Date | null
    atualizadoEm: Date | null
  }

  export type PagamentoCountAggregateOutputType = {
    id: number
    ingressoId: number
    formaPagamentoId: number
    valorTotal: number
    ativo: number
    criadoEm: number
    atualizadoEm: number
    _all: number
  }


  export type PagamentoAvgAggregateInputType = {
    id?: true
    ingressoId?: true
    formaPagamentoId?: true
    valorTotal?: true
  }

  export type PagamentoSumAggregateInputType = {
    id?: true
    ingressoId?: true
    formaPagamentoId?: true
    valorTotal?: true
  }

  export type PagamentoMinAggregateInputType = {
    id?: true
    ingressoId?: true
    formaPagamentoId?: true
    valorTotal?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type PagamentoMaxAggregateInputType = {
    id?: true
    ingressoId?: true
    formaPagamentoId?: true
    valorTotal?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
  }

  export type PagamentoCountAggregateInputType = {
    id?: true
    ingressoId?: true
    formaPagamentoId?: true
    valorTotal?: true
    ativo?: true
    criadoEm?: true
    atualizadoEm?: true
    _all?: true
  }

  export type PagamentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pagamento to aggregate.
     */
    where?: PagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagamentos to fetch.
     */
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pagamentos
    **/
    _count?: true | PagamentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PagamentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PagamentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PagamentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PagamentoMaxAggregateInputType
  }

  export type GetPagamentoAggregateType<T extends PagamentoAggregateArgs> = {
        [P in keyof T & keyof AggregatePagamento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePagamento[P]>
      : GetScalarType<T[P], AggregatePagamento[P]>
  }




  export type PagamentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PagamentoWhereInput
    orderBy?: PagamentoOrderByWithAggregationInput | PagamentoOrderByWithAggregationInput[]
    by: PagamentoScalarFieldEnum[] | PagamentoScalarFieldEnum
    having?: PagamentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PagamentoCountAggregateInputType | true
    _avg?: PagamentoAvgAggregateInputType
    _sum?: PagamentoSumAggregateInputType
    _min?: PagamentoMinAggregateInputType
    _max?: PagamentoMaxAggregateInputType
  }

  export type PagamentoGroupByOutputType = {
    id: number
    ingressoId: number
    formaPagamentoId: number
    valorTotal: number
    ativo: boolean
    criadoEm: Date
    atualizadoEm: Date
    _count: PagamentoCountAggregateOutputType | null
    _avg: PagamentoAvgAggregateOutputType | null
    _sum: PagamentoSumAggregateOutputType | null
    _min: PagamentoMinAggregateOutputType | null
    _max: PagamentoMaxAggregateOutputType | null
  }

  type GetPagamentoGroupByPayload<T extends PagamentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PagamentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PagamentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PagamentoGroupByOutputType[P]>
            : GetScalarType<T[P], PagamentoGroupByOutputType[P]>
        }
      >
    >


  export type PagamentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ingressoId?: boolean
    formaPagamentoId?: boolean
    valorTotal?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    ingresso?: boolean | IngressoDefaultArgs<ExtArgs>
    formaPagamento?: boolean | FormaPagamentoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pagamento"]>

  export type PagamentoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ingressoId?: boolean
    formaPagamentoId?: boolean
    valorTotal?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    ingresso?: boolean | IngressoDefaultArgs<ExtArgs>
    formaPagamento?: boolean | FormaPagamentoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pagamento"]>

  export type PagamentoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ingressoId?: boolean
    formaPagamentoId?: boolean
    valorTotal?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
    ingresso?: boolean | IngressoDefaultArgs<ExtArgs>
    formaPagamento?: boolean | FormaPagamentoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pagamento"]>

  export type PagamentoSelectScalar = {
    id?: boolean
    ingressoId?: boolean
    formaPagamentoId?: boolean
    valorTotal?: boolean
    ativo?: boolean
    criadoEm?: boolean
    atualizadoEm?: boolean
  }

  export type PagamentoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ingressoId" | "formaPagamentoId" | "valorTotal" | "ativo" | "criadoEm" | "atualizadoEm", ExtArgs["result"]["pagamento"]>
  export type PagamentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ingresso?: boolean | IngressoDefaultArgs<ExtArgs>
    formaPagamento?: boolean | FormaPagamentoDefaultArgs<ExtArgs>
  }
  export type PagamentoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ingresso?: boolean | IngressoDefaultArgs<ExtArgs>
    formaPagamento?: boolean | FormaPagamentoDefaultArgs<ExtArgs>
  }
  export type PagamentoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ingresso?: boolean | IngressoDefaultArgs<ExtArgs>
    formaPagamento?: boolean | FormaPagamentoDefaultArgs<ExtArgs>
  }

  export type $PagamentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pagamento"
    objects: {
      ingresso: Prisma.$IngressoPayload<ExtArgs>
      formaPagamento: Prisma.$FormaPagamentoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      ingressoId: number
      formaPagamentoId: number
      valorTotal: number
      ativo: boolean
      criadoEm: Date
      atualizadoEm: Date
    }, ExtArgs["result"]["pagamento"]>
    composites: {}
  }

  type PagamentoGetPayload<S extends boolean | null | undefined | PagamentoDefaultArgs> = $Result.GetResult<Prisma.$PagamentoPayload, S>

  type PagamentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PagamentoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PagamentoCountAggregateInputType | true
    }

  export interface PagamentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pagamento'], meta: { name: 'Pagamento' } }
    /**
     * Find zero or one Pagamento that matches the filter.
     * @param {PagamentoFindUniqueArgs} args - Arguments to find a Pagamento
     * @example
     * // Get one Pagamento
     * const pagamento = await prisma.pagamento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PagamentoFindUniqueArgs>(args: SelectSubset<T, PagamentoFindUniqueArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pagamento that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PagamentoFindUniqueOrThrowArgs} args - Arguments to find a Pagamento
     * @example
     * // Get one Pagamento
     * const pagamento = await prisma.pagamento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PagamentoFindUniqueOrThrowArgs>(args: SelectSubset<T, PagamentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pagamento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoFindFirstArgs} args - Arguments to find a Pagamento
     * @example
     * // Get one Pagamento
     * const pagamento = await prisma.pagamento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PagamentoFindFirstArgs>(args?: SelectSubset<T, PagamentoFindFirstArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pagamento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoFindFirstOrThrowArgs} args - Arguments to find a Pagamento
     * @example
     * // Get one Pagamento
     * const pagamento = await prisma.pagamento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PagamentoFindFirstOrThrowArgs>(args?: SelectSubset<T, PagamentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pagamentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pagamentos
     * const pagamentos = await prisma.pagamento.findMany()
     * 
     * // Get first 10 Pagamentos
     * const pagamentos = await prisma.pagamento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pagamentoWithIdOnly = await prisma.pagamento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PagamentoFindManyArgs>(args?: SelectSubset<T, PagamentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pagamento.
     * @param {PagamentoCreateArgs} args - Arguments to create a Pagamento.
     * @example
     * // Create one Pagamento
     * const Pagamento = await prisma.pagamento.create({
     *   data: {
     *     // ... data to create a Pagamento
     *   }
     * })
     * 
     */
    create<T extends PagamentoCreateArgs>(args: SelectSubset<T, PagamentoCreateArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pagamentos.
     * @param {PagamentoCreateManyArgs} args - Arguments to create many Pagamentos.
     * @example
     * // Create many Pagamentos
     * const pagamento = await prisma.pagamento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PagamentoCreateManyArgs>(args?: SelectSubset<T, PagamentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pagamentos and returns the data saved in the database.
     * @param {PagamentoCreateManyAndReturnArgs} args - Arguments to create many Pagamentos.
     * @example
     * // Create many Pagamentos
     * const pagamento = await prisma.pagamento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pagamentos and only return the `id`
     * const pagamentoWithIdOnly = await prisma.pagamento.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PagamentoCreateManyAndReturnArgs>(args?: SelectSubset<T, PagamentoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pagamento.
     * @param {PagamentoDeleteArgs} args - Arguments to delete one Pagamento.
     * @example
     * // Delete one Pagamento
     * const Pagamento = await prisma.pagamento.delete({
     *   where: {
     *     // ... filter to delete one Pagamento
     *   }
     * })
     * 
     */
    delete<T extends PagamentoDeleteArgs>(args: SelectSubset<T, PagamentoDeleteArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pagamento.
     * @param {PagamentoUpdateArgs} args - Arguments to update one Pagamento.
     * @example
     * // Update one Pagamento
     * const pagamento = await prisma.pagamento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PagamentoUpdateArgs>(args: SelectSubset<T, PagamentoUpdateArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pagamentos.
     * @param {PagamentoDeleteManyArgs} args - Arguments to filter Pagamentos to delete.
     * @example
     * // Delete a few Pagamentos
     * const { count } = await prisma.pagamento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PagamentoDeleteManyArgs>(args?: SelectSubset<T, PagamentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pagamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pagamentos
     * const pagamento = await prisma.pagamento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PagamentoUpdateManyArgs>(args: SelectSubset<T, PagamentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pagamentos and returns the data updated in the database.
     * @param {PagamentoUpdateManyAndReturnArgs} args - Arguments to update many Pagamentos.
     * @example
     * // Update many Pagamentos
     * const pagamento = await prisma.pagamento.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pagamentos and only return the `id`
     * const pagamentoWithIdOnly = await prisma.pagamento.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PagamentoUpdateManyAndReturnArgs>(args: SelectSubset<T, PagamentoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pagamento.
     * @param {PagamentoUpsertArgs} args - Arguments to update or create a Pagamento.
     * @example
     * // Update or create a Pagamento
     * const pagamento = await prisma.pagamento.upsert({
     *   create: {
     *     // ... data to create a Pagamento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pagamento we want to update
     *   }
     * })
     */
    upsert<T extends PagamentoUpsertArgs>(args: SelectSubset<T, PagamentoUpsertArgs<ExtArgs>>): Prisma__PagamentoClient<$Result.GetResult<Prisma.$PagamentoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pagamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoCountArgs} args - Arguments to filter Pagamentos to count.
     * @example
     * // Count the number of Pagamentos
     * const count = await prisma.pagamento.count({
     *   where: {
     *     // ... the filter for the Pagamentos we want to count
     *   }
     * })
    **/
    count<T extends PagamentoCountArgs>(
      args?: Subset<T, PagamentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PagamentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pagamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PagamentoAggregateArgs>(args: Subset<T, PagamentoAggregateArgs>): Prisma.PrismaPromise<GetPagamentoAggregateType<T>>

    /**
     * Group by Pagamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PagamentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PagamentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PagamentoGroupByArgs['orderBy'] }
        : { orderBy?: PagamentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PagamentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPagamentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pagamento model
   */
  readonly fields: PagamentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pagamento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PagamentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ingresso<T extends IngressoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, IngressoDefaultArgs<ExtArgs>>): Prisma__IngressoClient<$Result.GetResult<Prisma.$IngressoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    formaPagamento<T extends FormaPagamentoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FormaPagamentoDefaultArgs<ExtArgs>>): Prisma__FormaPagamentoClient<$Result.GetResult<Prisma.$FormaPagamentoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pagamento model
   */
  interface PagamentoFieldRefs {
    readonly id: FieldRef<"Pagamento", 'Int'>
    readonly ingressoId: FieldRef<"Pagamento", 'Int'>
    readonly formaPagamentoId: FieldRef<"Pagamento", 'Int'>
    readonly valorTotal: FieldRef<"Pagamento", 'Float'>
    readonly ativo: FieldRef<"Pagamento", 'Boolean'>
    readonly criadoEm: FieldRef<"Pagamento", 'DateTime'>
    readonly atualizadoEm: FieldRef<"Pagamento", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pagamento findUnique
   */
  export type PagamentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pagamento
     */
    omit?: PagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamento to fetch.
     */
    where: PagamentoWhereUniqueInput
  }

  /**
   * Pagamento findUniqueOrThrow
   */
  export type PagamentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pagamento
     */
    omit?: PagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamento to fetch.
     */
    where: PagamentoWhereUniqueInput
  }

  /**
   * Pagamento findFirst
   */
  export type PagamentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pagamento
     */
    omit?: PagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamento to fetch.
     */
    where?: PagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagamentos to fetch.
     */
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pagamentos.
     */
    cursor?: PagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pagamentos.
     */
    distinct?: PagamentoScalarFieldEnum | PagamentoScalarFieldEnum[]
  }

  /**
   * Pagamento findFirstOrThrow
   */
  export type PagamentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pagamento
     */
    omit?: PagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamento to fetch.
     */
    where?: PagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagamentos to fetch.
     */
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pagamentos.
     */
    cursor?: PagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pagamentos.
     */
    distinct?: PagamentoScalarFieldEnum | PagamentoScalarFieldEnum[]
  }

  /**
   * Pagamento findMany
   */
  export type PagamentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pagamento
     */
    omit?: PagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter, which Pagamentos to fetch.
     */
    where?: PagamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pagamentos to fetch.
     */
    orderBy?: PagamentoOrderByWithRelationInput | PagamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pagamentos.
     */
    cursor?: PagamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pagamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pagamentos.
     */
    skip?: number
    distinct?: PagamentoScalarFieldEnum | PagamentoScalarFieldEnum[]
  }

  /**
   * Pagamento create
   */
  export type PagamentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pagamento
     */
    omit?: PagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * The data needed to create a Pagamento.
     */
    data: XOR<PagamentoCreateInput, PagamentoUncheckedCreateInput>
  }

  /**
   * Pagamento createMany
   */
  export type PagamentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pagamentos.
     */
    data: PagamentoCreateManyInput | PagamentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pagamento createManyAndReturn
   */
  export type PagamentoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pagamento
     */
    omit?: PagamentoOmit<ExtArgs> | null
    /**
     * The data used to create many Pagamentos.
     */
    data: PagamentoCreateManyInput | PagamentoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pagamento update
   */
  export type PagamentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pagamento
     */
    omit?: PagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * The data needed to update a Pagamento.
     */
    data: XOR<PagamentoUpdateInput, PagamentoUncheckedUpdateInput>
    /**
     * Choose, which Pagamento to update.
     */
    where: PagamentoWhereUniqueInput
  }

  /**
   * Pagamento updateMany
   */
  export type PagamentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pagamentos.
     */
    data: XOR<PagamentoUpdateManyMutationInput, PagamentoUncheckedUpdateManyInput>
    /**
     * Filter which Pagamentos to update
     */
    where?: PagamentoWhereInput
    /**
     * Limit how many Pagamentos to update.
     */
    limit?: number
  }

  /**
   * Pagamento updateManyAndReturn
   */
  export type PagamentoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pagamento
     */
    omit?: PagamentoOmit<ExtArgs> | null
    /**
     * The data used to update Pagamentos.
     */
    data: XOR<PagamentoUpdateManyMutationInput, PagamentoUncheckedUpdateManyInput>
    /**
     * Filter which Pagamentos to update
     */
    where?: PagamentoWhereInput
    /**
     * Limit how many Pagamentos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pagamento upsert
   */
  export type PagamentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pagamento
     */
    omit?: PagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * The filter to search for the Pagamento to update in case it exists.
     */
    where: PagamentoWhereUniqueInput
    /**
     * In case the Pagamento found by the `where` argument doesn't exist, create a new Pagamento with this data.
     */
    create: XOR<PagamentoCreateInput, PagamentoUncheckedCreateInput>
    /**
     * In case the Pagamento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PagamentoUpdateInput, PagamentoUncheckedUpdateInput>
  }

  /**
   * Pagamento delete
   */
  export type PagamentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pagamento
     */
    omit?: PagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
    /**
     * Filter which Pagamento to delete.
     */
    where: PagamentoWhereUniqueInput
  }

  /**
   * Pagamento deleteMany
   */
  export type PagamentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pagamentos to delete
     */
    where?: PagamentoWhereInput
    /**
     * Limit how many Pagamentos to delete.
     */
    limit?: number
  }

  /**
   * Pagamento without action
   */
  export type PagamentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pagamento
     */
    select?: PagamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pagamento
     */
    omit?: PagamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PagamentoInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const GeneroScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    ativo: 'ativo',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type GeneroScalarFieldEnum = (typeof GeneroScalarFieldEnum)[keyof typeof GeneroScalarFieldEnum]


  export const FilmeGeneroScalarFieldEnum: {
    id: 'id',
    filmeId: 'filmeId',
    generoId: 'generoId',
    ativo: 'ativo',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type FilmeGeneroScalarFieldEnum = (typeof FilmeGeneroScalarFieldEnum)[keyof typeof FilmeGeneroScalarFieldEnum]


  export const FilmeScalarFieldEnum: {
    id: 'id',
    classificacaoIndicativaId: 'classificacaoIndicativaId',
    titulo: 'titulo',
    descricao: 'descricao',
    duracaoEmMinutos: 'duracaoEmMinutos',
    trailerUrl: 'trailerUrl',
    capaUrl: 'capaUrl',
    dataLancamento: 'dataLancamento',
    dataInicioCartaz: 'dataInicioCartaz',
    dataFimCartaz: 'dataFimCartaz',
    ativo: 'ativo',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type FilmeScalarFieldEnum = (typeof FilmeScalarFieldEnum)[keyof typeof FilmeScalarFieldEnum]


  export const FilmeIntegranteScalarFieldEnum: {
    id: 'id',
    filmeId: 'filmeId',
    integranteId: 'integranteId',
    ativo: 'ativo',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type FilmeIntegranteScalarFieldEnum = (typeof FilmeIntegranteScalarFieldEnum)[keyof typeof FilmeIntegranteScalarFieldEnum]


  export const IntegranteScalarFieldEnum: {
    id: 'id',
    tipoIntegranteId: 'tipoIntegranteId',
    nome: 'nome',
    sobrenome: 'sobrenome',
    ativo: 'ativo',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type IntegranteScalarFieldEnum = (typeof IntegranteScalarFieldEnum)[keyof typeof IntegranteScalarFieldEnum]


  export const TipoIntegranteScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    ativo: 'ativo',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type TipoIntegranteScalarFieldEnum = (typeof TipoIntegranteScalarFieldEnum)[keyof typeof TipoIntegranteScalarFieldEnum]


  export const ClassificacaoIndicativaScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    ativo: 'ativo',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type ClassificacaoIndicativaScalarFieldEnum = (typeof ClassificacaoIndicativaScalarFieldEnum)[keyof typeof ClassificacaoIndicativaScalarFieldEnum]


  export const TipoIdiomaScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    ativo: 'ativo',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type TipoIdiomaScalarFieldEnum = (typeof TipoIdiomaScalarFieldEnum)[keyof typeof TipoIdiomaScalarFieldEnum]


  export const TipoSessaoScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    ativo: 'ativo',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type TipoSessaoScalarFieldEnum = (typeof TipoSessaoScalarFieldEnum)[keyof typeof TipoSessaoScalarFieldEnum]


  export const SessaoScalarFieldEnum: {
    id: 'id',
    filmeId: 'filmeId',
    salaId: 'salaId',
    tipoSessaoId: 'tipoSessaoId',
    tipoIdiomaId: 'tipoIdiomaId',
    inicio: 'inicio',
    fim: 'fim',
    ativo: 'ativo',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type SessaoScalarFieldEnum = (typeof SessaoScalarFieldEnum)[keyof typeof SessaoScalarFieldEnum]


  export const TipoSalaScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    ativo: 'ativo',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type TipoSalaScalarFieldEnum = (typeof TipoSalaScalarFieldEnum)[keyof typeof TipoSalaScalarFieldEnum]


  export const SalaScalarFieldEnum: {
    id: 'id',
    tipoSalaId: 'tipoSalaId',
    nome: 'nome',
    ativo: 'ativo',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type SalaScalarFieldEnum = (typeof SalaScalarFieldEnum)[keyof typeof SalaScalarFieldEnum]


  export const TipoAssentoScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    ativo: 'ativo',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type TipoAssentoScalarFieldEnum = (typeof TipoAssentoScalarFieldEnum)[keyof typeof TipoAssentoScalarFieldEnum]


  export const AssentoScalarFieldEnum: {
    id: 'id',
    salaId: 'salaId',
    tipoAssentoId: 'tipoAssentoId',
    fileira: 'fileira',
    coluna: 'coluna',
    ativo: 'ativo',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type AssentoScalarFieldEnum = (typeof AssentoScalarFieldEnum)[keyof typeof AssentoScalarFieldEnum]


  export const SessaoAssentoStatusScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    ativo: 'ativo',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type SessaoAssentoStatusScalarFieldEnum = (typeof SessaoAssentoStatusScalarFieldEnum)[keyof typeof SessaoAssentoStatusScalarFieldEnum]


  export const SessaoAssentoScalarFieldEnum: {
    id: 'id',
    sessaoId: 'sessaoId',
    assentoId: 'assentoId',
    ingressoId: 'ingressoId',
    sessaoAssentoStatusId: 'sessaoAssentoStatusId',
    tipoEntradaId: 'tipoEntradaId',
    ativo: 'ativo',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type SessaoAssentoScalarFieldEnum = (typeof SessaoAssentoScalarFieldEnum)[keyof typeof SessaoAssentoScalarFieldEnum]


  export const TipoEntradaScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    ativo: 'ativo',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type TipoEntradaScalarFieldEnum = (typeof TipoEntradaScalarFieldEnum)[keyof typeof TipoEntradaScalarFieldEnum]


  export const IngressoScalarFieldEnum: {
    id: 'id',
    documentoResponsavel: 'documentoResponsavel',
    ativo: 'ativo',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type IngressoScalarFieldEnum = (typeof IngressoScalarFieldEnum)[keyof typeof IngressoScalarFieldEnum]


  export const FormaPagamentoScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    ativo: 'ativo',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type FormaPagamentoScalarFieldEnum = (typeof FormaPagamentoScalarFieldEnum)[keyof typeof FormaPagamentoScalarFieldEnum]


  export const PagamentoScalarFieldEnum: {
    id: 'id',
    ingressoId: 'ingressoId',
    formaPagamentoId: 'formaPagamentoId',
    valorTotal: 'valorTotal',
    ativo: 'ativo',
    criadoEm: 'criadoEm',
    atualizadoEm: 'atualizadoEm'
  };

  export type PagamentoScalarFieldEnum = (typeof PagamentoScalarFieldEnum)[keyof typeof PagamentoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type GeneroWhereInput = {
    AND?: GeneroWhereInput | GeneroWhereInput[]
    OR?: GeneroWhereInput[]
    NOT?: GeneroWhereInput | GeneroWhereInput[]
    id?: IntFilter<"Genero"> | number
    nome?: StringFilter<"Genero"> | string
    ativo?: BoolFilter<"Genero"> | boolean
    criadoEm?: DateTimeFilter<"Genero"> | Date | string
    atualizadoEm?: DateTimeFilter<"Genero"> | Date | string
    filmes?: FilmeGeneroListRelationFilter
  }

  export type GeneroOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    filmes?: FilmeGeneroOrderByRelationAggregateInput
  }

  export type GeneroWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nome?: string
    AND?: GeneroWhereInput | GeneroWhereInput[]
    OR?: GeneroWhereInput[]
    NOT?: GeneroWhereInput | GeneroWhereInput[]
    ativo?: BoolFilter<"Genero"> | boolean
    criadoEm?: DateTimeFilter<"Genero"> | Date | string
    atualizadoEm?: DateTimeFilter<"Genero"> | Date | string
    filmes?: FilmeGeneroListRelationFilter
  }, "id" | "nome">

  export type GeneroOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: GeneroCountOrderByAggregateInput
    _avg?: GeneroAvgOrderByAggregateInput
    _max?: GeneroMaxOrderByAggregateInput
    _min?: GeneroMinOrderByAggregateInput
    _sum?: GeneroSumOrderByAggregateInput
  }

  export type GeneroScalarWhereWithAggregatesInput = {
    AND?: GeneroScalarWhereWithAggregatesInput | GeneroScalarWhereWithAggregatesInput[]
    OR?: GeneroScalarWhereWithAggregatesInput[]
    NOT?: GeneroScalarWhereWithAggregatesInput | GeneroScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Genero"> | number
    nome?: StringWithAggregatesFilter<"Genero"> | string
    ativo?: BoolWithAggregatesFilter<"Genero"> | boolean
    criadoEm?: DateTimeWithAggregatesFilter<"Genero"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"Genero"> | Date | string
  }

  export type FilmeGeneroWhereInput = {
    AND?: FilmeGeneroWhereInput | FilmeGeneroWhereInput[]
    OR?: FilmeGeneroWhereInput[]
    NOT?: FilmeGeneroWhereInput | FilmeGeneroWhereInput[]
    id?: IntFilter<"FilmeGenero"> | number
    filmeId?: IntFilter<"FilmeGenero"> | number
    generoId?: IntFilter<"FilmeGenero"> | number
    ativo?: BoolFilter<"FilmeGenero"> | boolean
    criadoEm?: DateTimeFilter<"FilmeGenero"> | Date | string
    atualizadoEm?: DateTimeFilter<"FilmeGenero"> | Date | string
    filme?: XOR<FilmeScalarRelationFilter, FilmeWhereInput>
    genero?: XOR<GeneroScalarRelationFilter, GeneroWhereInput>
  }

  export type FilmeGeneroOrderByWithRelationInput = {
    id?: SortOrder
    filmeId?: SortOrder
    generoId?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    filme?: FilmeOrderByWithRelationInput
    genero?: GeneroOrderByWithRelationInput
  }

  export type FilmeGeneroWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    generoId_filmeId?: FilmeGeneroGeneroIdFilmeIdCompoundUniqueInput
    AND?: FilmeGeneroWhereInput | FilmeGeneroWhereInput[]
    OR?: FilmeGeneroWhereInput[]
    NOT?: FilmeGeneroWhereInput | FilmeGeneroWhereInput[]
    filmeId?: IntFilter<"FilmeGenero"> | number
    generoId?: IntFilter<"FilmeGenero"> | number
    ativo?: BoolFilter<"FilmeGenero"> | boolean
    criadoEm?: DateTimeFilter<"FilmeGenero"> | Date | string
    atualizadoEm?: DateTimeFilter<"FilmeGenero"> | Date | string
    filme?: XOR<FilmeScalarRelationFilter, FilmeWhereInput>
    genero?: XOR<GeneroScalarRelationFilter, GeneroWhereInput>
  }, "id" | "generoId_filmeId">

  export type FilmeGeneroOrderByWithAggregationInput = {
    id?: SortOrder
    filmeId?: SortOrder
    generoId?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: FilmeGeneroCountOrderByAggregateInput
    _avg?: FilmeGeneroAvgOrderByAggregateInput
    _max?: FilmeGeneroMaxOrderByAggregateInput
    _min?: FilmeGeneroMinOrderByAggregateInput
    _sum?: FilmeGeneroSumOrderByAggregateInput
  }

  export type FilmeGeneroScalarWhereWithAggregatesInput = {
    AND?: FilmeGeneroScalarWhereWithAggregatesInput | FilmeGeneroScalarWhereWithAggregatesInput[]
    OR?: FilmeGeneroScalarWhereWithAggregatesInput[]
    NOT?: FilmeGeneroScalarWhereWithAggregatesInput | FilmeGeneroScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FilmeGenero"> | number
    filmeId?: IntWithAggregatesFilter<"FilmeGenero"> | number
    generoId?: IntWithAggregatesFilter<"FilmeGenero"> | number
    ativo?: BoolWithAggregatesFilter<"FilmeGenero"> | boolean
    criadoEm?: DateTimeWithAggregatesFilter<"FilmeGenero"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"FilmeGenero"> | Date | string
  }

  export type FilmeWhereInput = {
    AND?: FilmeWhereInput | FilmeWhereInput[]
    OR?: FilmeWhereInput[]
    NOT?: FilmeWhereInput | FilmeWhereInput[]
    id?: IntFilter<"Filme"> | number
    classificacaoIndicativaId?: IntFilter<"Filme"> | number
    titulo?: StringFilter<"Filme"> | string
    descricao?: StringFilter<"Filme"> | string
    duracaoEmMinutos?: IntFilter<"Filme"> | number
    trailerUrl?: StringFilter<"Filme"> | string
    capaUrl?: StringFilter<"Filme"> | string
    dataLancamento?: DateTimeFilter<"Filme"> | Date | string
    dataInicioCartaz?: DateTimeFilter<"Filme"> | Date | string
    dataFimCartaz?: DateTimeFilter<"Filme"> | Date | string
    ativo?: BoolFilter<"Filme"> | boolean
    criadoEm?: DateTimeFilter<"Filme"> | Date | string
    atualizadoEm?: DateTimeFilter<"Filme"> | Date | string
    classificacaoIndicativa?: XOR<ClassificacaoIndicativaScalarRelationFilter, ClassificacaoIndicativaWhereInput>
    generos?: FilmeGeneroListRelationFilter
    integrantes?: FilmeIntegranteListRelationFilter
    sessoes?: SessaoListRelationFilter
  }

  export type FilmeOrderByWithRelationInput = {
    id?: SortOrder
    classificacaoIndicativaId?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    duracaoEmMinutos?: SortOrder
    trailerUrl?: SortOrder
    capaUrl?: SortOrder
    dataLancamento?: SortOrder
    dataInicioCartaz?: SortOrder
    dataFimCartaz?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    classificacaoIndicativa?: ClassificacaoIndicativaOrderByWithRelationInput
    generos?: FilmeGeneroOrderByRelationAggregateInput
    integrantes?: FilmeIntegranteOrderByRelationAggregateInput
    sessoes?: SessaoOrderByRelationAggregateInput
  }

  export type FilmeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    titulo?: string
    AND?: FilmeWhereInput | FilmeWhereInput[]
    OR?: FilmeWhereInput[]
    NOT?: FilmeWhereInput | FilmeWhereInput[]
    classificacaoIndicativaId?: IntFilter<"Filme"> | number
    descricao?: StringFilter<"Filme"> | string
    duracaoEmMinutos?: IntFilter<"Filme"> | number
    trailerUrl?: StringFilter<"Filme"> | string
    capaUrl?: StringFilter<"Filme"> | string
    dataLancamento?: DateTimeFilter<"Filme"> | Date | string
    dataInicioCartaz?: DateTimeFilter<"Filme"> | Date | string
    dataFimCartaz?: DateTimeFilter<"Filme"> | Date | string
    ativo?: BoolFilter<"Filme"> | boolean
    criadoEm?: DateTimeFilter<"Filme"> | Date | string
    atualizadoEm?: DateTimeFilter<"Filme"> | Date | string
    classificacaoIndicativa?: XOR<ClassificacaoIndicativaScalarRelationFilter, ClassificacaoIndicativaWhereInput>
    generos?: FilmeGeneroListRelationFilter
    integrantes?: FilmeIntegranteListRelationFilter
    sessoes?: SessaoListRelationFilter
  }, "id" | "titulo">

  export type FilmeOrderByWithAggregationInput = {
    id?: SortOrder
    classificacaoIndicativaId?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    duracaoEmMinutos?: SortOrder
    trailerUrl?: SortOrder
    capaUrl?: SortOrder
    dataLancamento?: SortOrder
    dataInicioCartaz?: SortOrder
    dataFimCartaz?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: FilmeCountOrderByAggregateInput
    _avg?: FilmeAvgOrderByAggregateInput
    _max?: FilmeMaxOrderByAggregateInput
    _min?: FilmeMinOrderByAggregateInput
    _sum?: FilmeSumOrderByAggregateInput
  }

  export type FilmeScalarWhereWithAggregatesInput = {
    AND?: FilmeScalarWhereWithAggregatesInput | FilmeScalarWhereWithAggregatesInput[]
    OR?: FilmeScalarWhereWithAggregatesInput[]
    NOT?: FilmeScalarWhereWithAggregatesInput | FilmeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Filme"> | number
    classificacaoIndicativaId?: IntWithAggregatesFilter<"Filme"> | number
    titulo?: StringWithAggregatesFilter<"Filme"> | string
    descricao?: StringWithAggregatesFilter<"Filme"> | string
    duracaoEmMinutos?: IntWithAggregatesFilter<"Filme"> | number
    trailerUrl?: StringWithAggregatesFilter<"Filme"> | string
    capaUrl?: StringWithAggregatesFilter<"Filme"> | string
    dataLancamento?: DateTimeWithAggregatesFilter<"Filme"> | Date | string
    dataInicioCartaz?: DateTimeWithAggregatesFilter<"Filme"> | Date | string
    dataFimCartaz?: DateTimeWithAggregatesFilter<"Filme"> | Date | string
    ativo?: BoolWithAggregatesFilter<"Filme"> | boolean
    criadoEm?: DateTimeWithAggregatesFilter<"Filme"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"Filme"> | Date | string
  }

  export type FilmeIntegranteWhereInput = {
    AND?: FilmeIntegranteWhereInput | FilmeIntegranteWhereInput[]
    OR?: FilmeIntegranteWhereInput[]
    NOT?: FilmeIntegranteWhereInput | FilmeIntegranteWhereInput[]
    id?: IntFilter<"FilmeIntegrante"> | number
    filmeId?: IntFilter<"FilmeIntegrante"> | number
    integranteId?: IntFilter<"FilmeIntegrante"> | number
    ativo?: BoolFilter<"FilmeIntegrante"> | boolean
    criadoEm?: DateTimeFilter<"FilmeIntegrante"> | Date | string
    atualizadoEm?: DateTimeFilter<"FilmeIntegrante"> | Date | string
    filme?: XOR<FilmeScalarRelationFilter, FilmeWhereInput>
    integrante?: XOR<IntegranteScalarRelationFilter, IntegranteWhereInput>
  }

  export type FilmeIntegranteOrderByWithRelationInput = {
    id?: SortOrder
    filmeId?: SortOrder
    integranteId?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    filme?: FilmeOrderByWithRelationInput
    integrante?: IntegranteOrderByWithRelationInput
  }

  export type FilmeIntegranteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    integranteId_filmeId?: FilmeIntegranteIntegranteIdFilmeIdCompoundUniqueInput
    AND?: FilmeIntegranteWhereInput | FilmeIntegranteWhereInput[]
    OR?: FilmeIntegranteWhereInput[]
    NOT?: FilmeIntegranteWhereInput | FilmeIntegranteWhereInput[]
    filmeId?: IntFilter<"FilmeIntegrante"> | number
    integranteId?: IntFilter<"FilmeIntegrante"> | number
    ativo?: BoolFilter<"FilmeIntegrante"> | boolean
    criadoEm?: DateTimeFilter<"FilmeIntegrante"> | Date | string
    atualizadoEm?: DateTimeFilter<"FilmeIntegrante"> | Date | string
    filme?: XOR<FilmeScalarRelationFilter, FilmeWhereInput>
    integrante?: XOR<IntegranteScalarRelationFilter, IntegranteWhereInput>
  }, "id" | "integranteId_filmeId">

  export type FilmeIntegranteOrderByWithAggregationInput = {
    id?: SortOrder
    filmeId?: SortOrder
    integranteId?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: FilmeIntegranteCountOrderByAggregateInput
    _avg?: FilmeIntegranteAvgOrderByAggregateInput
    _max?: FilmeIntegranteMaxOrderByAggregateInput
    _min?: FilmeIntegranteMinOrderByAggregateInput
    _sum?: FilmeIntegranteSumOrderByAggregateInput
  }

  export type FilmeIntegranteScalarWhereWithAggregatesInput = {
    AND?: FilmeIntegranteScalarWhereWithAggregatesInput | FilmeIntegranteScalarWhereWithAggregatesInput[]
    OR?: FilmeIntegranteScalarWhereWithAggregatesInput[]
    NOT?: FilmeIntegranteScalarWhereWithAggregatesInput | FilmeIntegranteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FilmeIntegrante"> | number
    filmeId?: IntWithAggregatesFilter<"FilmeIntegrante"> | number
    integranteId?: IntWithAggregatesFilter<"FilmeIntegrante"> | number
    ativo?: BoolWithAggregatesFilter<"FilmeIntegrante"> | boolean
    criadoEm?: DateTimeWithAggregatesFilter<"FilmeIntegrante"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"FilmeIntegrante"> | Date | string
  }

  export type IntegranteWhereInput = {
    AND?: IntegranteWhereInput | IntegranteWhereInput[]
    OR?: IntegranteWhereInput[]
    NOT?: IntegranteWhereInput | IntegranteWhereInput[]
    id?: IntFilter<"Integrante"> | number
    tipoIntegranteId?: IntFilter<"Integrante"> | number
    nome?: StringFilter<"Integrante"> | string
    sobrenome?: StringFilter<"Integrante"> | string
    ativo?: BoolFilter<"Integrante"> | boolean
    criadoEm?: DateTimeFilter<"Integrante"> | Date | string
    atualizadoEm?: DateTimeFilter<"Integrante"> | Date | string
    tipoIntegrante?: XOR<TipoIntegranteScalarRelationFilter, TipoIntegranteWhereInput>
    filmes?: FilmeIntegranteListRelationFilter
  }

  export type IntegranteOrderByWithRelationInput = {
    id?: SortOrder
    tipoIntegranteId?: SortOrder
    nome?: SortOrder
    sobrenome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    tipoIntegrante?: TipoIntegranteOrderByWithRelationInput
    filmes?: FilmeIntegranteOrderByRelationAggregateInput
  }

  export type IntegranteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: IntegranteWhereInput | IntegranteWhereInput[]
    OR?: IntegranteWhereInput[]
    NOT?: IntegranteWhereInput | IntegranteWhereInput[]
    tipoIntegranteId?: IntFilter<"Integrante"> | number
    nome?: StringFilter<"Integrante"> | string
    sobrenome?: StringFilter<"Integrante"> | string
    ativo?: BoolFilter<"Integrante"> | boolean
    criadoEm?: DateTimeFilter<"Integrante"> | Date | string
    atualizadoEm?: DateTimeFilter<"Integrante"> | Date | string
    tipoIntegrante?: XOR<TipoIntegranteScalarRelationFilter, TipoIntegranteWhereInput>
    filmes?: FilmeIntegranteListRelationFilter
  }, "id">

  export type IntegranteOrderByWithAggregationInput = {
    id?: SortOrder
    tipoIntegranteId?: SortOrder
    nome?: SortOrder
    sobrenome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: IntegranteCountOrderByAggregateInput
    _avg?: IntegranteAvgOrderByAggregateInput
    _max?: IntegranteMaxOrderByAggregateInput
    _min?: IntegranteMinOrderByAggregateInput
    _sum?: IntegranteSumOrderByAggregateInput
  }

  export type IntegranteScalarWhereWithAggregatesInput = {
    AND?: IntegranteScalarWhereWithAggregatesInput | IntegranteScalarWhereWithAggregatesInput[]
    OR?: IntegranteScalarWhereWithAggregatesInput[]
    NOT?: IntegranteScalarWhereWithAggregatesInput | IntegranteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Integrante"> | number
    tipoIntegranteId?: IntWithAggregatesFilter<"Integrante"> | number
    nome?: StringWithAggregatesFilter<"Integrante"> | string
    sobrenome?: StringWithAggregatesFilter<"Integrante"> | string
    ativo?: BoolWithAggregatesFilter<"Integrante"> | boolean
    criadoEm?: DateTimeWithAggregatesFilter<"Integrante"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"Integrante"> | Date | string
  }

  export type TipoIntegranteWhereInput = {
    AND?: TipoIntegranteWhereInput | TipoIntegranteWhereInput[]
    OR?: TipoIntegranteWhereInput[]
    NOT?: TipoIntegranteWhereInput | TipoIntegranteWhereInput[]
    id?: IntFilter<"TipoIntegrante"> | number
    nome?: StringFilter<"TipoIntegrante"> | string
    ativo?: BoolFilter<"TipoIntegrante"> | boolean
    criadoEm?: DateTimeFilter<"TipoIntegrante"> | Date | string
    atualizadoEm?: DateTimeFilter<"TipoIntegrante"> | Date | string
    integrantes?: IntegranteListRelationFilter
  }

  export type TipoIntegranteOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    integrantes?: IntegranteOrderByRelationAggregateInput
  }

  export type TipoIntegranteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nome?: string
    AND?: TipoIntegranteWhereInput | TipoIntegranteWhereInput[]
    OR?: TipoIntegranteWhereInput[]
    NOT?: TipoIntegranteWhereInput | TipoIntegranteWhereInput[]
    ativo?: BoolFilter<"TipoIntegrante"> | boolean
    criadoEm?: DateTimeFilter<"TipoIntegrante"> | Date | string
    atualizadoEm?: DateTimeFilter<"TipoIntegrante"> | Date | string
    integrantes?: IntegranteListRelationFilter
  }, "id" | "nome">

  export type TipoIntegranteOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: TipoIntegranteCountOrderByAggregateInput
    _avg?: TipoIntegranteAvgOrderByAggregateInput
    _max?: TipoIntegranteMaxOrderByAggregateInput
    _min?: TipoIntegranteMinOrderByAggregateInput
    _sum?: TipoIntegranteSumOrderByAggregateInput
  }

  export type TipoIntegranteScalarWhereWithAggregatesInput = {
    AND?: TipoIntegranteScalarWhereWithAggregatesInput | TipoIntegranteScalarWhereWithAggregatesInput[]
    OR?: TipoIntegranteScalarWhereWithAggregatesInput[]
    NOT?: TipoIntegranteScalarWhereWithAggregatesInput | TipoIntegranteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TipoIntegrante"> | number
    nome?: StringWithAggregatesFilter<"TipoIntegrante"> | string
    ativo?: BoolWithAggregatesFilter<"TipoIntegrante"> | boolean
    criadoEm?: DateTimeWithAggregatesFilter<"TipoIntegrante"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"TipoIntegrante"> | Date | string
  }

  export type ClassificacaoIndicativaWhereInput = {
    AND?: ClassificacaoIndicativaWhereInput | ClassificacaoIndicativaWhereInput[]
    OR?: ClassificacaoIndicativaWhereInput[]
    NOT?: ClassificacaoIndicativaWhereInput | ClassificacaoIndicativaWhereInput[]
    id?: IntFilter<"ClassificacaoIndicativa"> | number
    nome?: StringFilter<"ClassificacaoIndicativa"> | string
    ativo?: BoolFilter<"ClassificacaoIndicativa"> | boolean
    criadoEm?: DateTimeFilter<"ClassificacaoIndicativa"> | Date | string
    atualizadoEm?: DateTimeFilter<"ClassificacaoIndicativa"> | Date | string
    filmes?: FilmeListRelationFilter
  }

  export type ClassificacaoIndicativaOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    filmes?: FilmeOrderByRelationAggregateInput
  }

  export type ClassificacaoIndicativaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nome?: string
    AND?: ClassificacaoIndicativaWhereInput | ClassificacaoIndicativaWhereInput[]
    OR?: ClassificacaoIndicativaWhereInput[]
    NOT?: ClassificacaoIndicativaWhereInput | ClassificacaoIndicativaWhereInput[]
    ativo?: BoolFilter<"ClassificacaoIndicativa"> | boolean
    criadoEm?: DateTimeFilter<"ClassificacaoIndicativa"> | Date | string
    atualizadoEm?: DateTimeFilter<"ClassificacaoIndicativa"> | Date | string
    filmes?: FilmeListRelationFilter
  }, "id" | "nome">

  export type ClassificacaoIndicativaOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: ClassificacaoIndicativaCountOrderByAggregateInput
    _avg?: ClassificacaoIndicativaAvgOrderByAggregateInput
    _max?: ClassificacaoIndicativaMaxOrderByAggregateInput
    _min?: ClassificacaoIndicativaMinOrderByAggregateInput
    _sum?: ClassificacaoIndicativaSumOrderByAggregateInput
  }

  export type ClassificacaoIndicativaScalarWhereWithAggregatesInput = {
    AND?: ClassificacaoIndicativaScalarWhereWithAggregatesInput | ClassificacaoIndicativaScalarWhereWithAggregatesInput[]
    OR?: ClassificacaoIndicativaScalarWhereWithAggregatesInput[]
    NOT?: ClassificacaoIndicativaScalarWhereWithAggregatesInput | ClassificacaoIndicativaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ClassificacaoIndicativa"> | number
    nome?: StringWithAggregatesFilter<"ClassificacaoIndicativa"> | string
    ativo?: BoolWithAggregatesFilter<"ClassificacaoIndicativa"> | boolean
    criadoEm?: DateTimeWithAggregatesFilter<"ClassificacaoIndicativa"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"ClassificacaoIndicativa"> | Date | string
  }

  export type TipoIdiomaWhereInput = {
    AND?: TipoIdiomaWhereInput | TipoIdiomaWhereInput[]
    OR?: TipoIdiomaWhereInput[]
    NOT?: TipoIdiomaWhereInput | TipoIdiomaWhereInput[]
    id?: IntFilter<"TipoIdioma"> | number
    nome?: StringFilter<"TipoIdioma"> | string
    ativo?: BoolFilter<"TipoIdioma"> | boolean
    criadoEm?: DateTimeFilter<"TipoIdioma"> | Date | string
    atualizadoEm?: DateTimeFilter<"TipoIdioma"> | Date | string
    sessoes?: SessaoListRelationFilter
  }

  export type TipoIdiomaOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    sessoes?: SessaoOrderByRelationAggregateInput
  }

  export type TipoIdiomaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nome?: string
    AND?: TipoIdiomaWhereInput | TipoIdiomaWhereInput[]
    OR?: TipoIdiomaWhereInput[]
    NOT?: TipoIdiomaWhereInput | TipoIdiomaWhereInput[]
    ativo?: BoolFilter<"TipoIdioma"> | boolean
    criadoEm?: DateTimeFilter<"TipoIdioma"> | Date | string
    atualizadoEm?: DateTimeFilter<"TipoIdioma"> | Date | string
    sessoes?: SessaoListRelationFilter
  }, "id" | "nome">

  export type TipoIdiomaOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: TipoIdiomaCountOrderByAggregateInput
    _avg?: TipoIdiomaAvgOrderByAggregateInput
    _max?: TipoIdiomaMaxOrderByAggregateInput
    _min?: TipoIdiomaMinOrderByAggregateInput
    _sum?: TipoIdiomaSumOrderByAggregateInput
  }

  export type TipoIdiomaScalarWhereWithAggregatesInput = {
    AND?: TipoIdiomaScalarWhereWithAggregatesInput | TipoIdiomaScalarWhereWithAggregatesInput[]
    OR?: TipoIdiomaScalarWhereWithAggregatesInput[]
    NOT?: TipoIdiomaScalarWhereWithAggregatesInput | TipoIdiomaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TipoIdioma"> | number
    nome?: StringWithAggregatesFilter<"TipoIdioma"> | string
    ativo?: BoolWithAggregatesFilter<"TipoIdioma"> | boolean
    criadoEm?: DateTimeWithAggregatesFilter<"TipoIdioma"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"TipoIdioma"> | Date | string
  }

  export type TipoSessaoWhereInput = {
    AND?: TipoSessaoWhereInput | TipoSessaoWhereInput[]
    OR?: TipoSessaoWhereInput[]
    NOT?: TipoSessaoWhereInput | TipoSessaoWhereInput[]
    id?: IntFilter<"TipoSessao"> | number
    nome?: StringFilter<"TipoSessao"> | string
    ativo?: BoolFilter<"TipoSessao"> | boolean
    criadoEm?: DateTimeFilter<"TipoSessao"> | Date | string
    atualizadoEm?: DateTimeFilter<"TipoSessao"> | Date | string
    sessoes?: SessaoListRelationFilter
  }

  export type TipoSessaoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    sessoes?: SessaoOrderByRelationAggregateInput
  }

  export type TipoSessaoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nome?: string
    AND?: TipoSessaoWhereInput | TipoSessaoWhereInput[]
    OR?: TipoSessaoWhereInput[]
    NOT?: TipoSessaoWhereInput | TipoSessaoWhereInput[]
    ativo?: BoolFilter<"TipoSessao"> | boolean
    criadoEm?: DateTimeFilter<"TipoSessao"> | Date | string
    atualizadoEm?: DateTimeFilter<"TipoSessao"> | Date | string
    sessoes?: SessaoListRelationFilter
  }, "id" | "nome">

  export type TipoSessaoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: TipoSessaoCountOrderByAggregateInput
    _avg?: TipoSessaoAvgOrderByAggregateInput
    _max?: TipoSessaoMaxOrderByAggregateInput
    _min?: TipoSessaoMinOrderByAggregateInput
    _sum?: TipoSessaoSumOrderByAggregateInput
  }

  export type TipoSessaoScalarWhereWithAggregatesInput = {
    AND?: TipoSessaoScalarWhereWithAggregatesInput | TipoSessaoScalarWhereWithAggregatesInput[]
    OR?: TipoSessaoScalarWhereWithAggregatesInput[]
    NOT?: TipoSessaoScalarWhereWithAggregatesInput | TipoSessaoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TipoSessao"> | number
    nome?: StringWithAggregatesFilter<"TipoSessao"> | string
    ativo?: BoolWithAggregatesFilter<"TipoSessao"> | boolean
    criadoEm?: DateTimeWithAggregatesFilter<"TipoSessao"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"TipoSessao"> | Date | string
  }

  export type SessaoWhereInput = {
    AND?: SessaoWhereInput | SessaoWhereInput[]
    OR?: SessaoWhereInput[]
    NOT?: SessaoWhereInput | SessaoWhereInput[]
    id?: IntFilter<"Sessao"> | number
    filmeId?: IntFilter<"Sessao"> | number
    salaId?: IntFilter<"Sessao"> | number
    tipoSessaoId?: IntFilter<"Sessao"> | number
    tipoIdiomaId?: IntFilter<"Sessao"> | number
    inicio?: DateTimeFilter<"Sessao"> | Date | string
    fim?: DateTimeFilter<"Sessao"> | Date | string
    ativo?: BoolFilter<"Sessao"> | boolean
    criadoEm?: DateTimeFilter<"Sessao"> | Date | string
    atualizadoEm?: DateTimeFilter<"Sessao"> | Date | string
    filme?: XOR<FilmeScalarRelationFilter, FilmeWhereInput>
    sala?: XOR<SalaScalarRelationFilter, SalaWhereInput>
    tipoSessao?: XOR<TipoSessaoScalarRelationFilter, TipoSessaoWhereInput>
    tipoIdioma?: XOR<TipoIdiomaScalarRelationFilter, TipoIdiomaWhereInput>
    sessoesAssentos?: SessaoAssentoListRelationFilter
  }

  export type SessaoOrderByWithRelationInput = {
    id?: SortOrder
    filmeId?: SortOrder
    salaId?: SortOrder
    tipoSessaoId?: SortOrder
    tipoIdiomaId?: SortOrder
    inicio?: SortOrder
    fim?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    filme?: FilmeOrderByWithRelationInput
    sala?: SalaOrderByWithRelationInput
    tipoSessao?: TipoSessaoOrderByWithRelationInput
    tipoIdioma?: TipoIdiomaOrderByWithRelationInput
    sessoesAssentos?: SessaoAssentoOrderByRelationAggregateInput
  }

  export type SessaoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SessaoWhereInput | SessaoWhereInput[]
    OR?: SessaoWhereInput[]
    NOT?: SessaoWhereInput | SessaoWhereInput[]
    filmeId?: IntFilter<"Sessao"> | number
    salaId?: IntFilter<"Sessao"> | number
    tipoSessaoId?: IntFilter<"Sessao"> | number
    tipoIdiomaId?: IntFilter<"Sessao"> | number
    inicio?: DateTimeFilter<"Sessao"> | Date | string
    fim?: DateTimeFilter<"Sessao"> | Date | string
    ativo?: BoolFilter<"Sessao"> | boolean
    criadoEm?: DateTimeFilter<"Sessao"> | Date | string
    atualizadoEm?: DateTimeFilter<"Sessao"> | Date | string
    filme?: XOR<FilmeScalarRelationFilter, FilmeWhereInput>
    sala?: XOR<SalaScalarRelationFilter, SalaWhereInput>
    tipoSessao?: XOR<TipoSessaoScalarRelationFilter, TipoSessaoWhereInput>
    tipoIdioma?: XOR<TipoIdiomaScalarRelationFilter, TipoIdiomaWhereInput>
    sessoesAssentos?: SessaoAssentoListRelationFilter
  }, "id">

  export type SessaoOrderByWithAggregationInput = {
    id?: SortOrder
    filmeId?: SortOrder
    salaId?: SortOrder
    tipoSessaoId?: SortOrder
    tipoIdiomaId?: SortOrder
    inicio?: SortOrder
    fim?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: SessaoCountOrderByAggregateInput
    _avg?: SessaoAvgOrderByAggregateInput
    _max?: SessaoMaxOrderByAggregateInput
    _min?: SessaoMinOrderByAggregateInput
    _sum?: SessaoSumOrderByAggregateInput
  }

  export type SessaoScalarWhereWithAggregatesInput = {
    AND?: SessaoScalarWhereWithAggregatesInput | SessaoScalarWhereWithAggregatesInput[]
    OR?: SessaoScalarWhereWithAggregatesInput[]
    NOT?: SessaoScalarWhereWithAggregatesInput | SessaoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Sessao"> | number
    filmeId?: IntWithAggregatesFilter<"Sessao"> | number
    salaId?: IntWithAggregatesFilter<"Sessao"> | number
    tipoSessaoId?: IntWithAggregatesFilter<"Sessao"> | number
    tipoIdiomaId?: IntWithAggregatesFilter<"Sessao"> | number
    inicio?: DateTimeWithAggregatesFilter<"Sessao"> | Date | string
    fim?: DateTimeWithAggregatesFilter<"Sessao"> | Date | string
    ativo?: BoolWithAggregatesFilter<"Sessao"> | boolean
    criadoEm?: DateTimeWithAggregatesFilter<"Sessao"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"Sessao"> | Date | string
  }

  export type TipoSalaWhereInput = {
    AND?: TipoSalaWhereInput | TipoSalaWhereInput[]
    OR?: TipoSalaWhereInput[]
    NOT?: TipoSalaWhereInput | TipoSalaWhereInput[]
    id?: IntFilter<"TipoSala"> | number
    nome?: StringFilter<"TipoSala"> | string
    ativo?: BoolFilter<"TipoSala"> | boolean
    criadoEm?: DateTimeFilter<"TipoSala"> | Date | string
    atualizadoEm?: DateTimeFilter<"TipoSala"> | Date | string
    salas?: SalaListRelationFilter
  }

  export type TipoSalaOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    salas?: SalaOrderByRelationAggregateInput
  }

  export type TipoSalaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nome?: string
    AND?: TipoSalaWhereInput | TipoSalaWhereInput[]
    OR?: TipoSalaWhereInput[]
    NOT?: TipoSalaWhereInput | TipoSalaWhereInput[]
    ativo?: BoolFilter<"TipoSala"> | boolean
    criadoEm?: DateTimeFilter<"TipoSala"> | Date | string
    atualizadoEm?: DateTimeFilter<"TipoSala"> | Date | string
    salas?: SalaListRelationFilter
  }, "id" | "nome">

  export type TipoSalaOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: TipoSalaCountOrderByAggregateInput
    _avg?: TipoSalaAvgOrderByAggregateInput
    _max?: TipoSalaMaxOrderByAggregateInput
    _min?: TipoSalaMinOrderByAggregateInput
    _sum?: TipoSalaSumOrderByAggregateInput
  }

  export type TipoSalaScalarWhereWithAggregatesInput = {
    AND?: TipoSalaScalarWhereWithAggregatesInput | TipoSalaScalarWhereWithAggregatesInput[]
    OR?: TipoSalaScalarWhereWithAggregatesInput[]
    NOT?: TipoSalaScalarWhereWithAggregatesInput | TipoSalaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TipoSala"> | number
    nome?: StringWithAggregatesFilter<"TipoSala"> | string
    ativo?: BoolWithAggregatesFilter<"TipoSala"> | boolean
    criadoEm?: DateTimeWithAggregatesFilter<"TipoSala"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"TipoSala"> | Date | string
  }

  export type SalaWhereInput = {
    AND?: SalaWhereInput | SalaWhereInput[]
    OR?: SalaWhereInput[]
    NOT?: SalaWhereInput | SalaWhereInput[]
    id?: IntFilter<"Sala"> | number
    tipoSalaId?: IntFilter<"Sala"> | number
    nome?: StringFilter<"Sala"> | string
    ativo?: BoolFilter<"Sala"> | boolean
    criadoEm?: DateTimeFilter<"Sala"> | Date | string
    atualizadoEm?: DateTimeFilter<"Sala"> | Date | string
    tipoSala?: XOR<TipoSalaScalarRelationFilter, TipoSalaWhereInput>
    sessoes?: SessaoListRelationFilter
    assentos?: AssentoListRelationFilter
  }

  export type SalaOrderByWithRelationInput = {
    id?: SortOrder
    tipoSalaId?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    tipoSala?: TipoSalaOrderByWithRelationInput
    sessoes?: SessaoOrderByRelationAggregateInput
    assentos?: AssentoOrderByRelationAggregateInput
  }

  export type SalaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nome?: string
    AND?: SalaWhereInput | SalaWhereInput[]
    OR?: SalaWhereInput[]
    NOT?: SalaWhereInput | SalaWhereInput[]
    tipoSalaId?: IntFilter<"Sala"> | number
    ativo?: BoolFilter<"Sala"> | boolean
    criadoEm?: DateTimeFilter<"Sala"> | Date | string
    atualizadoEm?: DateTimeFilter<"Sala"> | Date | string
    tipoSala?: XOR<TipoSalaScalarRelationFilter, TipoSalaWhereInput>
    sessoes?: SessaoListRelationFilter
    assentos?: AssentoListRelationFilter
  }, "id" | "nome">

  export type SalaOrderByWithAggregationInput = {
    id?: SortOrder
    tipoSalaId?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: SalaCountOrderByAggregateInput
    _avg?: SalaAvgOrderByAggregateInput
    _max?: SalaMaxOrderByAggregateInput
    _min?: SalaMinOrderByAggregateInput
    _sum?: SalaSumOrderByAggregateInput
  }

  export type SalaScalarWhereWithAggregatesInput = {
    AND?: SalaScalarWhereWithAggregatesInput | SalaScalarWhereWithAggregatesInput[]
    OR?: SalaScalarWhereWithAggregatesInput[]
    NOT?: SalaScalarWhereWithAggregatesInput | SalaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Sala"> | number
    tipoSalaId?: IntWithAggregatesFilter<"Sala"> | number
    nome?: StringWithAggregatesFilter<"Sala"> | string
    ativo?: BoolWithAggregatesFilter<"Sala"> | boolean
    criadoEm?: DateTimeWithAggregatesFilter<"Sala"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"Sala"> | Date | string
  }

  export type TipoAssentoWhereInput = {
    AND?: TipoAssentoWhereInput | TipoAssentoWhereInput[]
    OR?: TipoAssentoWhereInput[]
    NOT?: TipoAssentoWhereInput | TipoAssentoWhereInput[]
    id?: IntFilter<"TipoAssento"> | number
    nome?: StringFilter<"TipoAssento"> | string
    ativo?: BoolFilter<"TipoAssento"> | boolean
    criadoEm?: DateTimeFilter<"TipoAssento"> | Date | string
    atualizadoEm?: DateTimeFilter<"TipoAssento"> | Date | string
    assentos?: AssentoListRelationFilter
  }

  export type TipoAssentoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    assentos?: AssentoOrderByRelationAggregateInput
  }

  export type TipoAssentoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nome?: string
    AND?: TipoAssentoWhereInput | TipoAssentoWhereInput[]
    OR?: TipoAssentoWhereInput[]
    NOT?: TipoAssentoWhereInput | TipoAssentoWhereInput[]
    ativo?: BoolFilter<"TipoAssento"> | boolean
    criadoEm?: DateTimeFilter<"TipoAssento"> | Date | string
    atualizadoEm?: DateTimeFilter<"TipoAssento"> | Date | string
    assentos?: AssentoListRelationFilter
  }, "id" | "nome">

  export type TipoAssentoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: TipoAssentoCountOrderByAggregateInput
    _avg?: TipoAssentoAvgOrderByAggregateInput
    _max?: TipoAssentoMaxOrderByAggregateInput
    _min?: TipoAssentoMinOrderByAggregateInput
    _sum?: TipoAssentoSumOrderByAggregateInput
  }

  export type TipoAssentoScalarWhereWithAggregatesInput = {
    AND?: TipoAssentoScalarWhereWithAggregatesInput | TipoAssentoScalarWhereWithAggregatesInput[]
    OR?: TipoAssentoScalarWhereWithAggregatesInput[]
    NOT?: TipoAssentoScalarWhereWithAggregatesInput | TipoAssentoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TipoAssento"> | number
    nome?: StringWithAggregatesFilter<"TipoAssento"> | string
    ativo?: BoolWithAggregatesFilter<"TipoAssento"> | boolean
    criadoEm?: DateTimeWithAggregatesFilter<"TipoAssento"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"TipoAssento"> | Date | string
  }

  export type AssentoWhereInput = {
    AND?: AssentoWhereInput | AssentoWhereInput[]
    OR?: AssentoWhereInput[]
    NOT?: AssentoWhereInput | AssentoWhereInput[]
    id?: IntFilter<"Assento"> | number
    salaId?: IntFilter<"Assento"> | number
    tipoAssentoId?: IntFilter<"Assento"> | number
    fileira?: StringFilter<"Assento"> | string
    coluna?: IntFilter<"Assento"> | number
    ativo?: BoolFilter<"Assento"> | boolean
    criadoEm?: DateTimeFilter<"Assento"> | Date | string
    atualizadoEm?: DateTimeFilter<"Assento"> | Date | string
    sala?: XOR<SalaScalarRelationFilter, SalaWhereInput>
    tipoAssento?: XOR<TipoAssentoScalarRelationFilter, TipoAssentoWhereInput>
    sessoesAssentos?: SessaoAssentoListRelationFilter
  }

  export type AssentoOrderByWithRelationInput = {
    id?: SortOrder
    salaId?: SortOrder
    tipoAssentoId?: SortOrder
    fileira?: SortOrder
    coluna?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    sala?: SalaOrderByWithRelationInput
    tipoAssento?: TipoAssentoOrderByWithRelationInput
    sessoesAssentos?: SessaoAssentoOrderByRelationAggregateInput
  }

  export type AssentoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AssentoWhereInput | AssentoWhereInput[]
    OR?: AssentoWhereInput[]
    NOT?: AssentoWhereInput | AssentoWhereInput[]
    salaId?: IntFilter<"Assento"> | number
    tipoAssentoId?: IntFilter<"Assento"> | number
    fileira?: StringFilter<"Assento"> | string
    coluna?: IntFilter<"Assento"> | number
    ativo?: BoolFilter<"Assento"> | boolean
    criadoEm?: DateTimeFilter<"Assento"> | Date | string
    atualizadoEm?: DateTimeFilter<"Assento"> | Date | string
    sala?: XOR<SalaScalarRelationFilter, SalaWhereInput>
    tipoAssento?: XOR<TipoAssentoScalarRelationFilter, TipoAssentoWhereInput>
    sessoesAssentos?: SessaoAssentoListRelationFilter
  }, "id">

  export type AssentoOrderByWithAggregationInput = {
    id?: SortOrder
    salaId?: SortOrder
    tipoAssentoId?: SortOrder
    fileira?: SortOrder
    coluna?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: AssentoCountOrderByAggregateInput
    _avg?: AssentoAvgOrderByAggregateInput
    _max?: AssentoMaxOrderByAggregateInput
    _min?: AssentoMinOrderByAggregateInput
    _sum?: AssentoSumOrderByAggregateInput
  }

  export type AssentoScalarWhereWithAggregatesInput = {
    AND?: AssentoScalarWhereWithAggregatesInput | AssentoScalarWhereWithAggregatesInput[]
    OR?: AssentoScalarWhereWithAggregatesInput[]
    NOT?: AssentoScalarWhereWithAggregatesInput | AssentoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Assento"> | number
    salaId?: IntWithAggregatesFilter<"Assento"> | number
    tipoAssentoId?: IntWithAggregatesFilter<"Assento"> | number
    fileira?: StringWithAggregatesFilter<"Assento"> | string
    coluna?: IntWithAggregatesFilter<"Assento"> | number
    ativo?: BoolWithAggregatesFilter<"Assento"> | boolean
    criadoEm?: DateTimeWithAggregatesFilter<"Assento"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"Assento"> | Date | string
  }

  export type SessaoAssentoStatusWhereInput = {
    AND?: SessaoAssentoStatusWhereInput | SessaoAssentoStatusWhereInput[]
    OR?: SessaoAssentoStatusWhereInput[]
    NOT?: SessaoAssentoStatusWhereInput | SessaoAssentoStatusWhereInput[]
    id?: IntFilter<"SessaoAssentoStatus"> | number
    nome?: StringFilter<"SessaoAssentoStatus"> | string
    ativo?: BoolFilter<"SessaoAssentoStatus"> | boolean
    criadoEm?: DateTimeFilter<"SessaoAssentoStatus"> | Date | string
    atualizadoEm?: DateTimeFilter<"SessaoAssentoStatus"> | Date | string
    sessoesAssentos?: SessaoAssentoListRelationFilter
  }

  export type SessaoAssentoStatusOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    sessoesAssentos?: SessaoAssentoOrderByRelationAggregateInput
  }

  export type SessaoAssentoStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nome?: string
    AND?: SessaoAssentoStatusWhereInput | SessaoAssentoStatusWhereInput[]
    OR?: SessaoAssentoStatusWhereInput[]
    NOT?: SessaoAssentoStatusWhereInput | SessaoAssentoStatusWhereInput[]
    ativo?: BoolFilter<"SessaoAssentoStatus"> | boolean
    criadoEm?: DateTimeFilter<"SessaoAssentoStatus"> | Date | string
    atualizadoEm?: DateTimeFilter<"SessaoAssentoStatus"> | Date | string
    sessoesAssentos?: SessaoAssentoListRelationFilter
  }, "id" | "nome">

  export type SessaoAssentoStatusOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: SessaoAssentoStatusCountOrderByAggregateInput
    _avg?: SessaoAssentoStatusAvgOrderByAggregateInput
    _max?: SessaoAssentoStatusMaxOrderByAggregateInput
    _min?: SessaoAssentoStatusMinOrderByAggregateInput
    _sum?: SessaoAssentoStatusSumOrderByAggregateInput
  }

  export type SessaoAssentoStatusScalarWhereWithAggregatesInput = {
    AND?: SessaoAssentoStatusScalarWhereWithAggregatesInput | SessaoAssentoStatusScalarWhereWithAggregatesInput[]
    OR?: SessaoAssentoStatusScalarWhereWithAggregatesInput[]
    NOT?: SessaoAssentoStatusScalarWhereWithAggregatesInput | SessaoAssentoStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SessaoAssentoStatus"> | number
    nome?: StringWithAggregatesFilter<"SessaoAssentoStatus"> | string
    ativo?: BoolWithAggregatesFilter<"SessaoAssentoStatus"> | boolean
    criadoEm?: DateTimeWithAggregatesFilter<"SessaoAssentoStatus"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"SessaoAssentoStatus"> | Date | string
  }

  export type SessaoAssentoWhereInput = {
    AND?: SessaoAssentoWhereInput | SessaoAssentoWhereInput[]
    OR?: SessaoAssentoWhereInput[]
    NOT?: SessaoAssentoWhereInput | SessaoAssentoWhereInput[]
    id?: IntFilter<"SessaoAssento"> | number
    sessaoId?: IntFilter<"SessaoAssento"> | number
    assentoId?: IntFilter<"SessaoAssento"> | number
    ingressoId?: IntFilter<"SessaoAssento"> | number
    sessaoAssentoStatusId?: IntFilter<"SessaoAssento"> | number
    tipoEntradaId?: IntFilter<"SessaoAssento"> | number
    ativo?: BoolFilter<"SessaoAssento"> | boolean
    criadoEm?: DateTimeFilter<"SessaoAssento"> | Date | string
    atualizadoEm?: DateTimeFilter<"SessaoAssento"> | Date | string
    sessao?: XOR<SessaoScalarRelationFilter, SessaoWhereInput>
    assento?: XOR<AssentoScalarRelationFilter, AssentoWhereInput>
    ingresso?: XOR<IngressoScalarRelationFilter, IngressoWhereInput>
    sessaoAssentoStatus?: XOR<SessaoAssentoStatusScalarRelationFilter, SessaoAssentoStatusWhereInput>
    tipoEntrada?: XOR<TipoEntradaScalarRelationFilter, TipoEntradaWhereInput>
  }

  export type SessaoAssentoOrderByWithRelationInput = {
    id?: SortOrder
    sessaoId?: SortOrder
    assentoId?: SortOrder
    ingressoId?: SortOrder
    sessaoAssentoStatusId?: SortOrder
    tipoEntradaId?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    sessao?: SessaoOrderByWithRelationInput
    assento?: AssentoOrderByWithRelationInput
    ingresso?: IngressoOrderByWithRelationInput
    sessaoAssentoStatus?: SessaoAssentoStatusOrderByWithRelationInput
    tipoEntrada?: TipoEntradaOrderByWithRelationInput
  }

  export type SessaoAssentoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    sessaoId_assentoId?: SessaoAssentoSessaoIdAssentoIdCompoundUniqueInput
    AND?: SessaoAssentoWhereInput | SessaoAssentoWhereInput[]
    OR?: SessaoAssentoWhereInput[]
    NOT?: SessaoAssentoWhereInput | SessaoAssentoWhereInput[]
    sessaoId?: IntFilter<"SessaoAssento"> | number
    assentoId?: IntFilter<"SessaoAssento"> | number
    ingressoId?: IntFilter<"SessaoAssento"> | number
    sessaoAssentoStatusId?: IntFilter<"SessaoAssento"> | number
    tipoEntradaId?: IntFilter<"SessaoAssento"> | number
    ativo?: BoolFilter<"SessaoAssento"> | boolean
    criadoEm?: DateTimeFilter<"SessaoAssento"> | Date | string
    atualizadoEm?: DateTimeFilter<"SessaoAssento"> | Date | string
    sessao?: XOR<SessaoScalarRelationFilter, SessaoWhereInput>
    assento?: XOR<AssentoScalarRelationFilter, AssentoWhereInput>
    ingresso?: XOR<IngressoScalarRelationFilter, IngressoWhereInput>
    sessaoAssentoStatus?: XOR<SessaoAssentoStatusScalarRelationFilter, SessaoAssentoStatusWhereInput>
    tipoEntrada?: XOR<TipoEntradaScalarRelationFilter, TipoEntradaWhereInput>
  }, "id" | "sessaoId_assentoId">

  export type SessaoAssentoOrderByWithAggregationInput = {
    id?: SortOrder
    sessaoId?: SortOrder
    assentoId?: SortOrder
    ingressoId?: SortOrder
    sessaoAssentoStatusId?: SortOrder
    tipoEntradaId?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: SessaoAssentoCountOrderByAggregateInput
    _avg?: SessaoAssentoAvgOrderByAggregateInput
    _max?: SessaoAssentoMaxOrderByAggregateInput
    _min?: SessaoAssentoMinOrderByAggregateInput
    _sum?: SessaoAssentoSumOrderByAggregateInput
  }

  export type SessaoAssentoScalarWhereWithAggregatesInput = {
    AND?: SessaoAssentoScalarWhereWithAggregatesInput | SessaoAssentoScalarWhereWithAggregatesInput[]
    OR?: SessaoAssentoScalarWhereWithAggregatesInput[]
    NOT?: SessaoAssentoScalarWhereWithAggregatesInput | SessaoAssentoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SessaoAssento"> | number
    sessaoId?: IntWithAggregatesFilter<"SessaoAssento"> | number
    assentoId?: IntWithAggregatesFilter<"SessaoAssento"> | number
    ingressoId?: IntWithAggregatesFilter<"SessaoAssento"> | number
    sessaoAssentoStatusId?: IntWithAggregatesFilter<"SessaoAssento"> | number
    tipoEntradaId?: IntWithAggregatesFilter<"SessaoAssento"> | number
    ativo?: BoolWithAggregatesFilter<"SessaoAssento"> | boolean
    criadoEm?: DateTimeWithAggregatesFilter<"SessaoAssento"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"SessaoAssento"> | Date | string
  }

  export type TipoEntradaWhereInput = {
    AND?: TipoEntradaWhereInput | TipoEntradaWhereInput[]
    OR?: TipoEntradaWhereInput[]
    NOT?: TipoEntradaWhereInput | TipoEntradaWhereInput[]
    id?: IntFilter<"TipoEntrada"> | number
    nome?: StringFilter<"TipoEntrada"> | string
    ativo?: BoolFilter<"TipoEntrada"> | boolean
    criadoEm?: DateTimeFilter<"TipoEntrada"> | Date | string
    atualizadoEm?: DateTimeFilter<"TipoEntrada"> | Date | string
    sessoesAssentos?: SessaoAssentoListRelationFilter
  }

  export type TipoEntradaOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    sessoesAssentos?: SessaoAssentoOrderByRelationAggregateInput
  }

  export type TipoEntradaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nome?: string
    AND?: TipoEntradaWhereInput | TipoEntradaWhereInput[]
    OR?: TipoEntradaWhereInput[]
    NOT?: TipoEntradaWhereInput | TipoEntradaWhereInput[]
    ativo?: BoolFilter<"TipoEntrada"> | boolean
    criadoEm?: DateTimeFilter<"TipoEntrada"> | Date | string
    atualizadoEm?: DateTimeFilter<"TipoEntrada"> | Date | string
    sessoesAssentos?: SessaoAssentoListRelationFilter
  }, "id" | "nome">

  export type TipoEntradaOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: TipoEntradaCountOrderByAggregateInput
    _avg?: TipoEntradaAvgOrderByAggregateInput
    _max?: TipoEntradaMaxOrderByAggregateInput
    _min?: TipoEntradaMinOrderByAggregateInput
    _sum?: TipoEntradaSumOrderByAggregateInput
  }

  export type TipoEntradaScalarWhereWithAggregatesInput = {
    AND?: TipoEntradaScalarWhereWithAggregatesInput | TipoEntradaScalarWhereWithAggregatesInput[]
    OR?: TipoEntradaScalarWhereWithAggregatesInput[]
    NOT?: TipoEntradaScalarWhereWithAggregatesInput | TipoEntradaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TipoEntrada"> | number
    nome?: StringWithAggregatesFilter<"TipoEntrada"> | string
    ativo?: BoolWithAggregatesFilter<"TipoEntrada"> | boolean
    criadoEm?: DateTimeWithAggregatesFilter<"TipoEntrada"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"TipoEntrada"> | Date | string
  }

  export type IngressoWhereInput = {
    AND?: IngressoWhereInput | IngressoWhereInput[]
    OR?: IngressoWhereInput[]
    NOT?: IngressoWhereInput | IngressoWhereInput[]
    id?: IntFilter<"Ingresso"> | number
    documentoResponsavel?: IntFilter<"Ingresso"> | number
    ativo?: BoolFilter<"Ingresso"> | boolean
    criadoEm?: DateTimeFilter<"Ingresso"> | Date | string
    atualizadoEm?: DateTimeFilter<"Ingresso"> | Date | string
    sessoesAssentos?: SessaoAssentoListRelationFilter
    pagamento?: XOR<PagamentoNullableScalarRelationFilter, PagamentoWhereInput> | null
  }

  export type IngressoOrderByWithRelationInput = {
    id?: SortOrder
    documentoResponsavel?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    sessoesAssentos?: SessaoAssentoOrderByRelationAggregateInput
    pagamento?: PagamentoOrderByWithRelationInput
  }

  export type IngressoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: IngressoWhereInput | IngressoWhereInput[]
    OR?: IngressoWhereInput[]
    NOT?: IngressoWhereInput | IngressoWhereInput[]
    documentoResponsavel?: IntFilter<"Ingresso"> | number
    ativo?: BoolFilter<"Ingresso"> | boolean
    criadoEm?: DateTimeFilter<"Ingresso"> | Date | string
    atualizadoEm?: DateTimeFilter<"Ingresso"> | Date | string
    sessoesAssentos?: SessaoAssentoListRelationFilter
    pagamento?: XOR<PagamentoNullableScalarRelationFilter, PagamentoWhereInput> | null
  }, "id">

  export type IngressoOrderByWithAggregationInput = {
    id?: SortOrder
    documentoResponsavel?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: IngressoCountOrderByAggregateInput
    _avg?: IngressoAvgOrderByAggregateInput
    _max?: IngressoMaxOrderByAggregateInput
    _min?: IngressoMinOrderByAggregateInput
    _sum?: IngressoSumOrderByAggregateInput
  }

  export type IngressoScalarWhereWithAggregatesInput = {
    AND?: IngressoScalarWhereWithAggregatesInput | IngressoScalarWhereWithAggregatesInput[]
    OR?: IngressoScalarWhereWithAggregatesInput[]
    NOT?: IngressoScalarWhereWithAggregatesInput | IngressoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Ingresso"> | number
    documentoResponsavel?: IntWithAggregatesFilter<"Ingresso"> | number
    ativo?: BoolWithAggregatesFilter<"Ingresso"> | boolean
    criadoEm?: DateTimeWithAggregatesFilter<"Ingresso"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"Ingresso"> | Date | string
  }

  export type FormaPagamentoWhereInput = {
    AND?: FormaPagamentoWhereInput | FormaPagamentoWhereInput[]
    OR?: FormaPagamentoWhereInput[]
    NOT?: FormaPagamentoWhereInput | FormaPagamentoWhereInput[]
    id?: IntFilter<"FormaPagamento"> | number
    nome?: StringFilter<"FormaPagamento"> | string
    ativo?: BoolFilter<"FormaPagamento"> | boolean
    criadoEm?: DateTimeFilter<"FormaPagamento"> | Date | string
    atualizadoEm?: DateTimeFilter<"FormaPagamento"> | Date | string
    pagamentos?: PagamentoListRelationFilter
  }

  export type FormaPagamentoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    pagamentos?: PagamentoOrderByRelationAggregateInput
  }

  export type FormaPagamentoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nome?: string
    AND?: FormaPagamentoWhereInput | FormaPagamentoWhereInput[]
    OR?: FormaPagamentoWhereInput[]
    NOT?: FormaPagamentoWhereInput | FormaPagamentoWhereInput[]
    ativo?: BoolFilter<"FormaPagamento"> | boolean
    criadoEm?: DateTimeFilter<"FormaPagamento"> | Date | string
    atualizadoEm?: DateTimeFilter<"FormaPagamento"> | Date | string
    pagamentos?: PagamentoListRelationFilter
  }, "id" | "nome">

  export type FormaPagamentoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: FormaPagamentoCountOrderByAggregateInput
    _avg?: FormaPagamentoAvgOrderByAggregateInput
    _max?: FormaPagamentoMaxOrderByAggregateInput
    _min?: FormaPagamentoMinOrderByAggregateInput
    _sum?: FormaPagamentoSumOrderByAggregateInput
  }

  export type FormaPagamentoScalarWhereWithAggregatesInput = {
    AND?: FormaPagamentoScalarWhereWithAggregatesInput | FormaPagamentoScalarWhereWithAggregatesInput[]
    OR?: FormaPagamentoScalarWhereWithAggregatesInput[]
    NOT?: FormaPagamentoScalarWhereWithAggregatesInput | FormaPagamentoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FormaPagamento"> | number
    nome?: StringWithAggregatesFilter<"FormaPagamento"> | string
    ativo?: BoolWithAggregatesFilter<"FormaPagamento"> | boolean
    criadoEm?: DateTimeWithAggregatesFilter<"FormaPagamento"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"FormaPagamento"> | Date | string
  }

  export type PagamentoWhereInput = {
    AND?: PagamentoWhereInput | PagamentoWhereInput[]
    OR?: PagamentoWhereInput[]
    NOT?: PagamentoWhereInput | PagamentoWhereInput[]
    id?: IntFilter<"Pagamento"> | number
    ingressoId?: IntFilter<"Pagamento"> | number
    formaPagamentoId?: IntFilter<"Pagamento"> | number
    valorTotal?: FloatFilter<"Pagamento"> | number
    ativo?: BoolFilter<"Pagamento"> | boolean
    criadoEm?: DateTimeFilter<"Pagamento"> | Date | string
    atualizadoEm?: DateTimeFilter<"Pagamento"> | Date | string
    ingresso?: XOR<IngressoScalarRelationFilter, IngressoWhereInput>
    formaPagamento?: XOR<FormaPagamentoScalarRelationFilter, FormaPagamentoWhereInput>
  }

  export type PagamentoOrderByWithRelationInput = {
    id?: SortOrder
    ingressoId?: SortOrder
    formaPagamentoId?: SortOrder
    valorTotal?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    ingresso?: IngressoOrderByWithRelationInput
    formaPagamento?: FormaPagamentoOrderByWithRelationInput
  }

  export type PagamentoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    ingressoId?: number
    AND?: PagamentoWhereInput | PagamentoWhereInput[]
    OR?: PagamentoWhereInput[]
    NOT?: PagamentoWhereInput | PagamentoWhereInput[]
    formaPagamentoId?: IntFilter<"Pagamento"> | number
    valorTotal?: FloatFilter<"Pagamento"> | number
    ativo?: BoolFilter<"Pagamento"> | boolean
    criadoEm?: DateTimeFilter<"Pagamento"> | Date | string
    atualizadoEm?: DateTimeFilter<"Pagamento"> | Date | string
    ingresso?: XOR<IngressoScalarRelationFilter, IngressoWhereInput>
    formaPagamento?: XOR<FormaPagamentoScalarRelationFilter, FormaPagamentoWhereInput>
  }, "id" | "ingressoId">

  export type PagamentoOrderByWithAggregationInput = {
    id?: SortOrder
    ingressoId?: SortOrder
    formaPagamentoId?: SortOrder
    valorTotal?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
    _count?: PagamentoCountOrderByAggregateInput
    _avg?: PagamentoAvgOrderByAggregateInput
    _max?: PagamentoMaxOrderByAggregateInput
    _min?: PagamentoMinOrderByAggregateInput
    _sum?: PagamentoSumOrderByAggregateInput
  }

  export type PagamentoScalarWhereWithAggregatesInput = {
    AND?: PagamentoScalarWhereWithAggregatesInput | PagamentoScalarWhereWithAggregatesInput[]
    OR?: PagamentoScalarWhereWithAggregatesInput[]
    NOT?: PagamentoScalarWhereWithAggregatesInput | PagamentoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Pagamento"> | number
    ingressoId?: IntWithAggregatesFilter<"Pagamento"> | number
    formaPagamentoId?: IntWithAggregatesFilter<"Pagamento"> | number
    valorTotal?: FloatWithAggregatesFilter<"Pagamento"> | number
    ativo?: BoolWithAggregatesFilter<"Pagamento"> | boolean
    criadoEm?: DateTimeWithAggregatesFilter<"Pagamento"> | Date | string
    atualizadoEm?: DateTimeWithAggregatesFilter<"Pagamento"> | Date | string
  }

  export type GeneroCreateInput = {
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    filmes?: FilmeGeneroCreateNestedManyWithoutGeneroInput
  }

  export type GeneroUncheckedCreateInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    filmes?: FilmeGeneroUncheckedCreateNestedManyWithoutGeneroInput
  }

  export type GeneroUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    filmes?: FilmeGeneroUpdateManyWithoutGeneroNestedInput
  }

  export type GeneroUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    filmes?: FilmeGeneroUncheckedUpdateManyWithoutGeneroNestedInput
  }

  export type GeneroCreateManyInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type GeneroUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneroUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilmeGeneroCreateInput = {
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    filme: FilmeCreateNestedOneWithoutGenerosInput
    genero: GeneroCreateNestedOneWithoutFilmesInput
  }

  export type FilmeGeneroUncheckedCreateInput = {
    id?: number
    filmeId: number
    generoId: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type FilmeGeneroUpdateInput = {
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    filme?: FilmeUpdateOneRequiredWithoutGenerosNestedInput
    genero?: GeneroUpdateOneRequiredWithoutFilmesNestedInput
  }

  export type FilmeGeneroUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    filmeId?: IntFieldUpdateOperationsInput | number
    generoId?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilmeGeneroCreateManyInput = {
    id?: number
    filmeId: number
    generoId: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type FilmeGeneroUpdateManyMutationInput = {
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilmeGeneroUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    filmeId?: IntFieldUpdateOperationsInput | number
    generoId?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilmeCreateInput = {
    titulo: string
    descricao: string
    duracaoEmMinutos: number
    trailerUrl: string
    capaUrl: string
    dataLancamento: Date | string
    dataInicioCartaz: Date | string
    dataFimCartaz: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    classificacaoIndicativa: ClassificacaoIndicativaCreateNestedOneWithoutFilmesInput
    generos?: FilmeGeneroCreateNestedManyWithoutFilmeInput
    integrantes?: FilmeIntegranteCreateNestedManyWithoutFilmeInput
    sessoes?: SessaoCreateNestedManyWithoutFilmeInput
  }

  export type FilmeUncheckedCreateInput = {
    id?: number
    classificacaoIndicativaId: number
    titulo: string
    descricao: string
    duracaoEmMinutos: number
    trailerUrl: string
    capaUrl: string
    dataLancamento: Date | string
    dataInicioCartaz: Date | string
    dataFimCartaz: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    generos?: FilmeGeneroUncheckedCreateNestedManyWithoutFilmeInput
    integrantes?: FilmeIntegranteUncheckedCreateNestedManyWithoutFilmeInput
    sessoes?: SessaoUncheckedCreateNestedManyWithoutFilmeInput
  }

  export type FilmeUpdateInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    duracaoEmMinutos?: IntFieldUpdateOperationsInput | number
    trailerUrl?: StringFieldUpdateOperationsInput | string
    capaUrl?: StringFieldUpdateOperationsInput | string
    dataLancamento?: DateTimeFieldUpdateOperationsInput | Date | string
    dataInicioCartaz?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFimCartaz?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    classificacaoIndicativa?: ClassificacaoIndicativaUpdateOneRequiredWithoutFilmesNestedInput
    generos?: FilmeGeneroUpdateManyWithoutFilmeNestedInput
    integrantes?: FilmeIntegranteUpdateManyWithoutFilmeNestedInput
    sessoes?: SessaoUpdateManyWithoutFilmeNestedInput
  }

  export type FilmeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    classificacaoIndicativaId?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    duracaoEmMinutos?: IntFieldUpdateOperationsInput | number
    trailerUrl?: StringFieldUpdateOperationsInput | string
    capaUrl?: StringFieldUpdateOperationsInput | string
    dataLancamento?: DateTimeFieldUpdateOperationsInput | Date | string
    dataInicioCartaz?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFimCartaz?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    generos?: FilmeGeneroUncheckedUpdateManyWithoutFilmeNestedInput
    integrantes?: FilmeIntegranteUncheckedUpdateManyWithoutFilmeNestedInput
    sessoes?: SessaoUncheckedUpdateManyWithoutFilmeNestedInput
  }

  export type FilmeCreateManyInput = {
    id?: number
    classificacaoIndicativaId: number
    titulo: string
    descricao: string
    duracaoEmMinutos: number
    trailerUrl: string
    capaUrl: string
    dataLancamento: Date | string
    dataInicioCartaz: Date | string
    dataFimCartaz: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type FilmeUpdateManyMutationInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    duracaoEmMinutos?: IntFieldUpdateOperationsInput | number
    trailerUrl?: StringFieldUpdateOperationsInput | string
    capaUrl?: StringFieldUpdateOperationsInput | string
    dataLancamento?: DateTimeFieldUpdateOperationsInput | Date | string
    dataInicioCartaz?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFimCartaz?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilmeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    classificacaoIndicativaId?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    duracaoEmMinutos?: IntFieldUpdateOperationsInput | number
    trailerUrl?: StringFieldUpdateOperationsInput | string
    capaUrl?: StringFieldUpdateOperationsInput | string
    dataLancamento?: DateTimeFieldUpdateOperationsInput | Date | string
    dataInicioCartaz?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFimCartaz?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilmeIntegranteCreateInput = {
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    filme: FilmeCreateNestedOneWithoutIntegrantesInput
    integrante: IntegranteCreateNestedOneWithoutFilmesInput
  }

  export type FilmeIntegranteUncheckedCreateInput = {
    id?: number
    filmeId: number
    integranteId: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type FilmeIntegranteUpdateInput = {
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    filme?: FilmeUpdateOneRequiredWithoutIntegrantesNestedInput
    integrante?: IntegranteUpdateOneRequiredWithoutFilmesNestedInput
  }

  export type FilmeIntegranteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    filmeId?: IntFieldUpdateOperationsInput | number
    integranteId?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilmeIntegranteCreateManyInput = {
    id?: number
    filmeId: number
    integranteId: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type FilmeIntegranteUpdateManyMutationInput = {
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilmeIntegranteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    filmeId?: IntFieldUpdateOperationsInput | number
    integranteId?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegranteCreateInput = {
    nome: string
    sobrenome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    tipoIntegrante: TipoIntegranteCreateNestedOneWithoutIntegrantesInput
    filmes?: FilmeIntegranteCreateNestedManyWithoutIntegranteInput
  }

  export type IntegranteUncheckedCreateInput = {
    id?: number
    tipoIntegranteId: number
    nome: string
    sobrenome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    filmes?: FilmeIntegranteUncheckedCreateNestedManyWithoutIntegranteInput
  }

  export type IntegranteUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tipoIntegrante?: TipoIntegranteUpdateOneRequiredWithoutIntegrantesNestedInput
    filmes?: FilmeIntegranteUpdateManyWithoutIntegranteNestedInput
  }

  export type IntegranteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoIntegranteId?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    filmes?: FilmeIntegranteUncheckedUpdateManyWithoutIntegranteNestedInput
  }

  export type IntegranteCreateManyInput = {
    id?: number
    tipoIntegranteId: number
    nome: string
    sobrenome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type IntegranteUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegranteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoIntegranteId?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoIntegranteCreateInput = {
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    integrantes?: IntegranteCreateNestedManyWithoutTipoIntegranteInput
  }

  export type TipoIntegranteUncheckedCreateInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    integrantes?: IntegranteUncheckedCreateNestedManyWithoutTipoIntegranteInput
  }

  export type TipoIntegranteUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    integrantes?: IntegranteUpdateManyWithoutTipoIntegranteNestedInput
  }

  export type TipoIntegranteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    integrantes?: IntegranteUncheckedUpdateManyWithoutTipoIntegranteNestedInput
  }

  export type TipoIntegranteCreateManyInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type TipoIntegranteUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoIntegranteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassificacaoIndicativaCreateInput = {
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    filmes?: FilmeCreateNestedManyWithoutClassificacaoIndicativaInput
  }

  export type ClassificacaoIndicativaUncheckedCreateInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    filmes?: FilmeUncheckedCreateNestedManyWithoutClassificacaoIndicativaInput
  }

  export type ClassificacaoIndicativaUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    filmes?: FilmeUpdateManyWithoutClassificacaoIndicativaNestedInput
  }

  export type ClassificacaoIndicativaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    filmes?: FilmeUncheckedUpdateManyWithoutClassificacaoIndicativaNestedInput
  }

  export type ClassificacaoIndicativaCreateManyInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type ClassificacaoIndicativaUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassificacaoIndicativaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoIdiomaCreateInput = {
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessoes?: SessaoCreateNestedManyWithoutTipoIdiomaInput
  }

  export type TipoIdiomaUncheckedCreateInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessoes?: SessaoUncheckedCreateNestedManyWithoutTipoIdiomaInput
  }

  export type TipoIdiomaUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessoes?: SessaoUpdateManyWithoutTipoIdiomaNestedInput
  }

  export type TipoIdiomaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessoes?: SessaoUncheckedUpdateManyWithoutTipoIdiomaNestedInput
  }

  export type TipoIdiomaCreateManyInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type TipoIdiomaUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoIdiomaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoSessaoCreateInput = {
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessoes?: SessaoCreateNestedManyWithoutTipoSessaoInput
  }

  export type TipoSessaoUncheckedCreateInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessoes?: SessaoUncheckedCreateNestedManyWithoutTipoSessaoInput
  }

  export type TipoSessaoUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessoes?: SessaoUpdateManyWithoutTipoSessaoNestedInput
  }

  export type TipoSessaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessoes?: SessaoUncheckedUpdateManyWithoutTipoSessaoNestedInput
  }

  export type TipoSessaoCreateManyInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type TipoSessaoUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoSessaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessaoCreateInput = {
    inicio: Date | string
    fim: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    filme: FilmeCreateNestedOneWithoutSessoesInput
    sala: SalaCreateNestedOneWithoutSessoesInput
    tipoSessao: TipoSessaoCreateNestedOneWithoutSessoesInput
    tipoIdioma: TipoIdiomaCreateNestedOneWithoutSessoesInput
    sessoesAssentos?: SessaoAssentoCreateNestedManyWithoutSessaoInput
  }

  export type SessaoUncheckedCreateInput = {
    id?: number
    filmeId: number
    salaId: number
    tipoSessaoId: number
    tipoIdiomaId: number
    inicio: Date | string
    fim: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessoesAssentos?: SessaoAssentoUncheckedCreateNestedManyWithoutSessaoInput
  }

  export type SessaoUpdateInput = {
    inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fim?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    filme?: FilmeUpdateOneRequiredWithoutSessoesNestedInput
    sala?: SalaUpdateOneRequiredWithoutSessoesNestedInput
    tipoSessao?: TipoSessaoUpdateOneRequiredWithoutSessoesNestedInput
    tipoIdioma?: TipoIdiomaUpdateOneRequiredWithoutSessoesNestedInput
    sessoesAssentos?: SessaoAssentoUpdateManyWithoutSessaoNestedInput
  }

  export type SessaoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    filmeId?: IntFieldUpdateOperationsInput | number
    salaId?: IntFieldUpdateOperationsInput | number
    tipoSessaoId?: IntFieldUpdateOperationsInput | number
    tipoIdiomaId?: IntFieldUpdateOperationsInput | number
    inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fim?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessoesAssentos?: SessaoAssentoUncheckedUpdateManyWithoutSessaoNestedInput
  }

  export type SessaoCreateManyInput = {
    id?: number
    filmeId: number
    salaId: number
    tipoSessaoId: number
    tipoIdiomaId: number
    inicio: Date | string
    fim: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type SessaoUpdateManyMutationInput = {
    inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fim?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessaoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    filmeId?: IntFieldUpdateOperationsInput | number
    salaId?: IntFieldUpdateOperationsInput | number
    tipoSessaoId?: IntFieldUpdateOperationsInput | number
    tipoIdiomaId?: IntFieldUpdateOperationsInput | number
    inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fim?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoSalaCreateInput = {
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    salas?: SalaCreateNestedManyWithoutTipoSalaInput
  }

  export type TipoSalaUncheckedCreateInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    salas?: SalaUncheckedCreateNestedManyWithoutTipoSalaInput
  }

  export type TipoSalaUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    salas?: SalaUpdateManyWithoutTipoSalaNestedInput
  }

  export type TipoSalaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    salas?: SalaUncheckedUpdateManyWithoutTipoSalaNestedInput
  }

  export type TipoSalaCreateManyInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type TipoSalaUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoSalaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaCreateInput = {
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    tipoSala: TipoSalaCreateNestedOneWithoutSalasInput
    sessoes?: SessaoCreateNestedManyWithoutSalaInput
    assentos?: AssentoCreateNestedManyWithoutSalaInput
  }

  export type SalaUncheckedCreateInput = {
    id?: number
    tipoSalaId: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessoes?: SessaoUncheckedCreateNestedManyWithoutSalaInput
    assentos?: AssentoUncheckedCreateNestedManyWithoutSalaInput
  }

  export type SalaUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tipoSala?: TipoSalaUpdateOneRequiredWithoutSalasNestedInput
    sessoes?: SessaoUpdateManyWithoutSalaNestedInput
    assentos?: AssentoUpdateManyWithoutSalaNestedInput
  }

  export type SalaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoSalaId?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessoes?: SessaoUncheckedUpdateManyWithoutSalaNestedInput
    assentos?: AssentoUncheckedUpdateManyWithoutSalaNestedInput
  }

  export type SalaCreateManyInput = {
    id?: number
    tipoSalaId: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type SalaUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoSalaId?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoAssentoCreateInput = {
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    assentos?: AssentoCreateNestedManyWithoutTipoAssentoInput
  }

  export type TipoAssentoUncheckedCreateInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    assentos?: AssentoUncheckedCreateNestedManyWithoutTipoAssentoInput
  }

  export type TipoAssentoUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    assentos?: AssentoUpdateManyWithoutTipoAssentoNestedInput
  }

  export type TipoAssentoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    assentos?: AssentoUncheckedUpdateManyWithoutTipoAssentoNestedInput
  }

  export type TipoAssentoCreateManyInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type TipoAssentoUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoAssentoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssentoCreateInput = {
    fileira: string
    coluna: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sala: SalaCreateNestedOneWithoutAssentosInput
    tipoAssento: TipoAssentoCreateNestedOneWithoutAssentosInput
    sessoesAssentos?: SessaoAssentoCreateNestedManyWithoutAssentoInput
  }

  export type AssentoUncheckedCreateInput = {
    id?: number
    salaId: number
    tipoAssentoId: number
    fileira: string
    coluna: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessoesAssentos?: SessaoAssentoUncheckedCreateNestedManyWithoutAssentoInput
  }

  export type AssentoUpdateInput = {
    fileira?: StringFieldUpdateOperationsInput | string
    coluna?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sala?: SalaUpdateOneRequiredWithoutAssentosNestedInput
    tipoAssento?: TipoAssentoUpdateOneRequiredWithoutAssentosNestedInput
    sessoesAssentos?: SessaoAssentoUpdateManyWithoutAssentoNestedInput
  }

  export type AssentoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    salaId?: IntFieldUpdateOperationsInput | number
    tipoAssentoId?: IntFieldUpdateOperationsInput | number
    fileira?: StringFieldUpdateOperationsInput | string
    coluna?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessoesAssentos?: SessaoAssentoUncheckedUpdateManyWithoutAssentoNestedInput
  }

  export type AssentoCreateManyInput = {
    id?: number
    salaId: number
    tipoAssentoId: number
    fileira: string
    coluna: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type AssentoUpdateManyMutationInput = {
    fileira?: StringFieldUpdateOperationsInput | string
    coluna?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssentoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    salaId?: IntFieldUpdateOperationsInput | number
    tipoAssentoId?: IntFieldUpdateOperationsInput | number
    fileira?: StringFieldUpdateOperationsInput | string
    coluna?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessaoAssentoStatusCreateInput = {
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessoesAssentos?: SessaoAssentoCreateNestedManyWithoutSessaoAssentoStatusInput
  }

  export type SessaoAssentoStatusUncheckedCreateInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessoesAssentos?: SessaoAssentoUncheckedCreateNestedManyWithoutSessaoAssentoStatusInput
  }

  export type SessaoAssentoStatusUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessoesAssentos?: SessaoAssentoUpdateManyWithoutSessaoAssentoStatusNestedInput
  }

  export type SessaoAssentoStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessoesAssentos?: SessaoAssentoUncheckedUpdateManyWithoutSessaoAssentoStatusNestedInput
  }

  export type SessaoAssentoStatusCreateManyInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type SessaoAssentoStatusUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessaoAssentoStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessaoAssentoCreateInput = {
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessao: SessaoCreateNestedOneWithoutSessoesAssentosInput
    assento: AssentoCreateNestedOneWithoutSessoesAssentosInput
    ingresso: IngressoCreateNestedOneWithoutSessoesAssentosInput
    sessaoAssentoStatus: SessaoAssentoStatusCreateNestedOneWithoutSessoesAssentosInput
    tipoEntrada: TipoEntradaCreateNestedOneWithoutSessoesAssentosInput
  }

  export type SessaoAssentoUncheckedCreateInput = {
    id?: number
    sessaoId: number
    assentoId: number
    ingressoId: number
    sessaoAssentoStatusId: number
    tipoEntradaId: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type SessaoAssentoUpdateInput = {
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessao?: SessaoUpdateOneRequiredWithoutSessoesAssentosNestedInput
    assento?: AssentoUpdateOneRequiredWithoutSessoesAssentosNestedInput
    ingresso?: IngressoUpdateOneRequiredWithoutSessoesAssentosNestedInput
    sessaoAssentoStatus?: SessaoAssentoStatusUpdateOneRequiredWithoutSessoesAssentosNestedInput
    tipoEntrada?: TipoEntradaUpdateOneRequiredWithoutSessoesAssentosNestedInput
  }

  export type SessaoAssentoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessaoId?: IntFieldUpdateOperationsInput | number
    assentoId?: IntFieldUpdateOperationsInput | number
    ingressoId?: IntFieldUpdateOperationsInput | number
    sessaoAssentoStatusId?: IntFieldUpdateOperationsInput | number
    tipoEntradaId?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessaoAssentoCreateManyInput = {
    id?: number
    sessaoId: number
    assentoId: number
    ingressoId: number
    sessaoAssentoStatusId: number
    tipoEntradaId: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type SessaoAssentoUpdateManyMutationInput = {
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessaoAssentoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessaoId?: IntFieldUpdateOperationsInput | number
    assentoId?: IntFieldUpdateOperationsInput | number
    ingressoId?: IntFieldUpdateOperationsInput | number
    sessaoAssentoStatusId?: IntFieldUpdateOperationsInput | number
    tipoEntradaId?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoEntradaCreateInput = {
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessoesAssentos?: SessaoAssentoCreateNestedManyWithoutTipoEntradaInput
  }

  export type TipoEntradaUncheckedCreateInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessoesAssentos?: SessaoAssentoUncheckedCreateNestedManyWithoutTipoEntradaInput
  }

  export type TipoEntradaUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessoesAssentos?: SessaoAssentoUpdateManyWithoutTipoEntradaNestedInput
  }

  export type TipoEntradaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessoesAssentos?: SessaoAssentoUncheckedUpdateManyWithoutTipoEntradaNestedInput
  }

  export type TipoEntradaCreateManyInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type TipoEntradaUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoEntradaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngressoCreateInput = {
    documentoResponsavel: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessoesAssentos?: SessaoAssentoCreateNestedManyWithoutIngressoInput
    pagamento?: PagamentoCreateNestedOneWithoutIngressoInput
  }

  export type IngressoUncheckedCreateInput = {
    id?: number
    documentoResponsavel: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessoesAssentos?: SessaoAssentoUncheckedCreateNestedManyWithoutIngressoInput
    pagamento?: PagamentoUncheckedCreateNestedOneWithoutIngressoInput
  }

  export type IngressoUpdateInput = {
    documentoResponsavel?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessoesAssentos?: SessaoAssentoUpdateManyWithoutIngressoNestedInput
    pagamento?: PagamentoUpdateOneWithoutIngressoNestedInput
  }

  export type IngressoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    documentoResponsavel?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessoesAssentos?: SessaoAssentoUncheckedUpdateManyWithoutIngressoNestedInput
    pagamento?: PagamentoUncheckedUpdateOneWithoutIngressoNestedInput
  }

  export type IngressoCreateManyInput = {
    id?: number
    documentoResponsavel: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type IngressoUpdateManyMutationInput = {
    documentoResponsavel?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngressoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    documentoResponsavel?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormaPagamentoCreateInput = {
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    pagamentos?: PagamentoCreateNestedManyWithoutFormaPagamentoInput
  }

  export type FormaPagamentoUncheckedCreateInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    pagamentos?: PagamentoUncheckedCreateNestedManyWithoutFormaPagamentoInput
  }

  export type FormaPagamentoUpdateInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    pagamentos?: PagamentoUpdateManyWithoutFormaPagamentoNestedInput
  }

  export type FormaPagamentoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    pagamentos?: PagamentoUncheckedUpdateManyWithoutFormaPagamentoNestedInput
  }

  export type FormaPagamentoCreateManyInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type FormaPagamentoUpdateManyMutationInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormaPagamentoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagamentoCreateInput = {
    valorTotal: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    ingresso: IngressoCreateNestedOneWithoutPagamentoInput
    formaPagamento: FormaPagamentoCreateNestedOneWithoutPagamentosInput
  }

  export type PagamentoUncheckedCreateInput = {
    id?: number
    ingressoId: number
    formaPagamentoId: number
    valorTotal: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type PagamentoUpdateInput = {
    valorTotal?: FloatFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    ingresso?: IngressoUpdateOneRequiredWithoutPagamentoNestedInput
    formaPagamento?: FormaPagamentoUpdateOneRequiredWithoutPagamentosNestedInput
  }

  export type PagamentoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    ingressoId?: IntFieldUpdateOperationsInput | number
    formaPagamentoId?: IntFieldUpdateOperationsInput | number
    valorTotal?: FloatFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagamentoCreateManyInput = {
    id?: number
    ingressoId: number
    formaPagamentoId: number
    valorTotal: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type PagamentoUpdateManyMutationInput = {
    valorTotal?: FloatFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagamentoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    ingressoId?: IntFieldUpdateOperationsInput | number
    formaPagamentoId?: IntFieldUpdateOperationsInput | number
    valorTotal?: FloatFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type FilmeGeneroListRelationFilter = {
    every?: FilmeGeneroWhereInput
    some?: FilmeGeneroWhereInput
    none?: FilmeGeneroWhereInput
  }

  export type FilmeGeneroOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GeneroCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type GeneroAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type GeneroMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type GeneroMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type GeneroSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FilmeScalarRelationFilter = {
    is?: FilmeWhereInput
    isNot?: FilmeWhereInput
  }

  export type GeneroScalarRelationFilter = {
    is?: GeneroWhereInput
    isNot?: GeneroWhereInput
  }

  export type FilmeGeneroGeneroIdFilmeIdCompoundUniqueInput = {
    generoId: number
    filmeId: number
  }

  export type FilmeGeneroCountOrderByAggregateInput = {
    id?: SortOrder
    filmeId?: SortOrder
    generoId?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type FilmeGeneroAvgOrderByAggregateInput = {
    id?: SortOrder
    filmeId?: SortOrder
    generoId?: SortOrder
  }

  export type FilmeGeneroMaxOrderByAggregateInput = {
    id?: SortOrder
    filmeId?: SortOrder
    generoId?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type FilmeGeneroMinOrderByAggregateInput = {
    id?: SortOrder
    filmeId?: SortOrder
    generoId?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type FilmeGeneroSumOrderByAggregateInput = {
    id?: SortOrder
    filmeId?: SortOrder
    generoId?: SortOrder
  }

  export type ClassificacaoIndicativaScalarRelationFilter = {
    is?: ClassificacaoIndicativaWhereInput
    isNot?: ClassificacaoIndicativaWhereInput
  }

  export type FilmeIntegranteListRelationFilter = {
    every?: FilmeIntegranteWhereInput
    some?: FilmeIntegranteWhereInput
    none?: FilmeIntegranteWhereInput
  }

  export type SessaoListRelationFilter = {
    every?: SessaoWhereInput
    some?: SessaoWhereInput
    none?: SessaoWhereInput
  }

  export type FilmeIntegranteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FilmeCountOrderByAggregateInput = {
    id?: SortOrder
    classificacaoIndicativaId?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    duracaoEmMinutos?: SortOrder
    trailerUrl?: SortOrder
    capaUrl?: SortOrder
    dataLancamento?: SortOrder
    dataInicioCartaz?: SortOrder
    dataFimCartaz?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type FilmeAvgOrderByAggregateInput = {
    id?: SortOrder
    classificacaoIndicativaId?: SortOrder
    duracaoEmMinutos?: SortOrder
  }

  export type FilmeMaxOrderByAggregateInput = {
    id?: SortOrder
    classificacaoIndicativaId?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    duracaoEmMinutos?: SortOrder
    trailerUrl?: SortOrder
    capaUrl?: SortOrder
    dataLancamento?: SortOrder
    dataInicioCartaz?: SortOrder
    dataFimCartaz?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type FilmeMinOrderByAggregateInput = {
    id?: SortOrder
    classificacaoIndicativaId?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    duracaoEmMinutos?: SortOrder
    trailerUrl?: SortOrder
    capaUrl?: SortOrder
    dataLancamento?: SortOrder
    dataInicioCartaz?: SortOrder
    dataFimCartaz?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type FilmeSumOrderByAggregateInput = {
    id?: SortOrder
    classificacaoIndicativaId?: SortOrder
    duracaoEmMinutos?: SortOrder
  }

  export type IntegranteScalarRelationFilter = {
    is?: IntegranteWhereInput
    isNot?: IntegranteWhereInput
  }

  export type FilmeIntegranteIntegranteIdFilmeIdCompoundUniqueInput = {
    integranteId: number
    filmeId: number
  }

  export type FilmeIntegranteCountOrderByAggregateInput = {
    id?: SortOrder
    filmeId?: SortOrder
    integranteId?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type FilmeIntegranteAvgOrderByAggregateInput = {
    id?: SortOrder
    filmeId?: SortOrder
    integranteId?: SortOrder
  }

  export type FilmeIntegranteMaxOrderByAggregateInput = {
    id?: SortOrder
    filmeId?: SortOrder
    integranteId?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type FilmeIntegranteMinOrderByAggregateInput = {
    id?: SortOrder
    filmeId?: SortOrder
    integranteId?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type FilmeIntegranteSumOrderByAggregateInput = {
    id?: SortOrder
    filmeId?: SortOrder
    integranteId?: SortOrder
  }

  export type TipoIntegranteScalarRelationFilter = {
    is?: TipoIntegranteWhereInput
    isNot?: TipoIntegranteWhereInput
  }

  export type IntegranteCountOrderByAggregateInput = {
    id?: SortOrder
    tipoIntegranteId?: SortOrder
    nome?: SortOrder
    sobrenome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type IntegranteAvgOrderByAggregateInput = {
    id?: SortOrder
    tipoIntegranteId?: SortOrder
  }

  export type IntegranteMaxOrderByAggregateInput = {
    id?: SortOrder
    tipoIntegranteId?: SortOrder
    nome?: SortOrder
    sobrenome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type IntegranteMinOrderByAggregateInput = {
    id?: SortOrder
    tipoIntegranteId?: SortOrder
    nome?: SortOrder
    sobrenome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type IntegranteSumOrderByAggregateInput = {
    id?: SortOrder
    tipoIntegranteId?: SortOrder
  }

  export type IntegranteListRelationFilter = {
    every?: IntegranteWhereInput
    some?: IntegranteWhereInput
    none?: IntegranteWhereInput
  }

  export type IntegranteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TipoIntegranteCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type TipoIntegranteAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TipoIntegranteMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type TipoIntegranteMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type TipoIntegranteSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FilmeListRelationFilter = {
    every?: FilmeWhereInput
    some?: FilmeWhereInput
    none?: FilmeWhereInput
  }

  export type FilmeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassificacaoIndicativaCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type ClassificacaoIndicativaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ClassificacaoIndicativaMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type ClassificacaoIndicativaMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type ClassificacaoIndicativaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TipoIdiomaCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type TipoIdiomaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TipoIdiomaMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type TipoIdiomaMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type TipoIdiomaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TipoSessaoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type TipoSessaoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TipoSessaoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type TipoSessaoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type TipoSessaoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SalaScalarRelationFilter = {
    is?: SalaWhereInput
    isNot?: SalaWhereInput
  }

  export type TipoSessaoScalarRelationFilter = {
    is?: TipoSessaoWhereInput
    isNot?: TipoSessaoWhereInput
  }

  export type TipoIdiomaScalarRelationFilter = {
    is?: TipoIdiomaWhereInput
    isNot?: TipoIdiomaWhereInput
  }

  export type SessaoAssentoListRelationFilter = {
    every?: SessaoAssentoWhereInput
    some?: SessaoAssentoWhereInput
    none?: SessaoAssentoWhereInput
  }

  export type SessaoAssentoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessaoCountOrderByAggregateInput = {
    id?: SortOrder
    filmeId?: SortOrder
    salaId?: SortOrder
    tipoSessaoId?: SortOrder
    tipoIdiomaId?: SortOrder
    inicio?: SortOrder
    fim?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type SessaoAvgOrderByAggregateInput = {
    id?: SortOrder
    filmeId?: SortOrder
    salaId?: SortOrder
    tipoSessaoId?: SortOrder
    tipoIdiomaId?: SortOrder
  }

  export type SessaoMaxOrderByAggregateInput = {
    id?: SortOrder
    filmeId?: SortOrder
    salaId?: SortOrder
    tipoSessaoId?: SortOrder
    tipoIdiomaId?: SortOrder
    inicio?: SortOrder
    fim?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type SessaoMinOrderByAggregateInput = {
    id?: SortOrder
    filmeId?: SortOrder
    salaId?: SortOrder
    tipoSessaoId?: SortOrder
    tipoIdiomaId?: SortOrder
    inicio?: SortOrder
    fim?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type SessaoSumOrderByAggregateInput = {
    id?: SortOrder
    filmeId?: SortOrder
    salaId?: SortOrder
    tipoSessaoId?: SortOrder
    tipoIdiomaId?: SortOrder
  }

  export type SalaListRelationFilter = {
    every?: SalaWhereInput
    some?: SalaWhereInput
    none?: SalaWhereInput
  }

  export type SalaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TipoSalaCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type TipoSalaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TipoSalaMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type TipoSalaMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type TipoSalaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TipoSalaScalarRelationFilter = {
    is?: TipoSalaWhereInput
    isNot?: TipoSalaWhereInput
  }

  export type AssentoListRelationFilter = {
    every?: AssentoWhereInput
    some?: AssentoWhereInput
    none?: AssentoWhereInput
  }

  export type AssentoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalaCountOrderByAggregateInput = {
    id?: SortOrder
    tipoSalaId?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type SalaAvgOrderByAggregateInput = {
    id?: SortOrder
    tipoSalaId?: SortOrder
  }

  export type SalaMaxOrderByAggregateInput = {
    id?: SortOrder
    tipoSalaId?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type SalaMinOrderByAggregateInput = {
    id?: SortOrder
    tipoSalaId?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type SalaSumOrderByAggregateInput = {
    id?: SortOrder
    tipoSalaId?: SortOrder
  }

  export type TipoAssentoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type TipoAssentoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TipoAssentoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type TipoAssentoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type TipoAssentoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TipoAssentoScalarRelationFilter = {
    is?: TipoAssentoWhereInput
    isNot?: TipoAssentoWhereInput
  }

  export type AssentoCountOrderByAggregateInput = {
    id?: SortOrder
    salaId?: SortOrder
    tipoAssentoId?: SortOrder
    fileira?: SortOrder
    coluna?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type AssentoAvgOrderByAggregateInput = {
    id?: SortOrder
    salaId?: SortOrder
    tipoAssentoId?: SortOrder
    coluna?: SortOrder
  }

  export type AssentoMaxOrderByAggregateInput = {
    id?: SortOrder
    salaId?: SortOrder
    tipoAssentoId?: SortOrder
    fileira?: SortOrder
    coluna?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type AssentoMinOrderByAggregateInput = {
    id?: SortOrder
    salaId?: SortOrder
    tipoAssentoId?: SortOrder
    fileira?: SortOrder
    coluna?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type AssentoSumOrderByAggregateInput = {
    id?: SortOrder
    salaId?: SortOrder
    tipoAssentoId?: SortOrder
    coluna?: SortOrder
  }

  export type SessaoAssentoStatusCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type SessaoAssentoStatusAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SessaoAssentoStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type SessaoAssentoStatusMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type SessaoAssentoStatusSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SessaoScalarRelationFilter = {
    is?: SessaoWhereInput
    isNot?: SessaoWhereInput
  }

  export type AssentoScalarRelationFilter = {
    is?: AssentoWhereInput
    isNot?: AssentoWhereInput
  }

  export type IngressoScalarRelationFilter = {
    is?: IngressoWhereInput
    isNot?: IngressoWhereInput
  }

  export type SessaoAssentoStatusScalarRelationFilter = {
    is?: SessaoAssentoStatusWhereInput
    isNot?: SessaoAssentoStatusWhereInput
  }

  export type TipoEntradaScalarRelationFilter = {
    is?: TipoEntradaWhereInput
    isNot?: TipoEntradaWhereInput
  }

  export type SessaoAssentoSessaoIdAssentoIdCompoundUniqueInput = {
    sessaoId: number
    assentoId: number
  }

  export type SessaoAssentoCountOrderByAggregateInput = {
    id?: SortOrder
    sessaoId?: SortOrder
    assentoId?: SortOrder
    ingressoId?: SortOrder
    sessaoAssentoStatusId?: SortOrder
    tipoEntradaId?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type SessaoAssentoAvgOrderByAggregateInput = {
    id?: SortOrder
    sessaoId?: SortOrder
    assentoId?: SortOrder
    ingressoId?: SortOrder
    sessaoAssentoStatusId?: SortOrder
    tipoEntradaId?: SortOrder
  }

  export type SessaoAssentoMaxOrderByAggregateInput = {
    id?: SortOrder
    sessaoId?: SortOrder
    assentoId?: SortOrder
    ingressoId?: SortOrder
    sessaoAssentoStatusId?: SortOrder
    tipoEntradaId?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type SessaoAssentoMinOrderByAggregateInput = {
    id?: SortOrder
    sessaoId?: SortOrder
    assentoId?: SortOrder
    ingressoId?: SortOrder
    sessaoAssentoStatusId?: SortOrder
    tipoEntradaId?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type SessaoAssentoSumOrderByAggregateInput = {
    id?: SortOrder
    sessaoId?: SortOrder
    assentoId?: SortOrder
    ingressoId?: SortOrder
    sessaoAssentoStatusId?: SortOrder
    tipoEntradaId?: SortOrder
  }

  export type TipoEntradaCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type TipoEntradaAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TipoEntradaMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type TipoEntradaMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type TipoEntradaSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PagamentoNullableScalarRelationFilter = {
    is?: PagamentoWhereInput | null
    isNot?: PagamentoWhereInput | null
  }

  export type IngressoCountOrderByAggregateInput = {
    id?: SortOrder
    documentoResponsavel?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type IngressoAvgOrderByAggregateInput = {
    id?: SortOrder
    documentoResponsavel?: SortOrder
  }

  export type IngressoMaxOrderByAggregateInput = {
    id?: SortOrder
    documentoResponsavel?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type IngressoMinOrderByAggregateInput = {
    id?: SortOrder
    documentoResponsavel?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type IngressoSumOrderByAggregateInput = {
    id?: SortOrder
    documentoResponsavel?: SortOrder
  }

  export type PagamentoListRelationFilter = {
    every?: PagamentoWhereInput
    some?: PagamentoWhereInput
    none?: PagamentoWhereInput
  }

  export type PagamentoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FormaPagamentoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type FormaPagamentoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FormaPagamentoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type FormaPagamentoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type FormaPagamentoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FormaPagamentoScalarRelationFilter = {
    is?: FormaPagamentoWhereInput
    isNot?: FormaPagamentoWhereInput
  }

  export type PagamentoCountOrderByAggregateInput = {
    id?: SortOrder
    ingressoId?: SortOrder
    formaPagamentoId?: SortOrder
    valorTotal?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type PagamentoAvgOrderByAggregateInput = {
    id?: SortOrder
    ingressoId?: SortOrder
    formaPagamentoId?: SortOrder
    valorTotal?: SortOrder
  }

  export type PagamentoMaxOrderByAggregateInput = {
    id?: SortOrder
    ingressoId?: SortOrder
    formaPagamentoId?: SortOrder
    valorTotal?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type PagamentoMinOrderByAggregateInput = {
    id?: SortOrder
    ingressoId?: SortOrder
    formaPagamentoId?: SortOrder
    valorTotal?: SortOrder
    ativo?: SortOrder
    criadoEm?: SortOrder
    atualizadoEm?: SortOrder
  }

  export type PagamentoSumOrderByAggregateInput = {
    id?: SortOrder
    ingressoId?: SortOrder
    formaPagamentoId?: SortOrder
    valorTotal?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FilmeGeneroCreateNestedManyWithoutGeneroInput = {
    create?: XOR<FilmeGeneroCreateWithoutGeneroInput, FilmeGeneroUncheckedCreateWithoutGeneroInput> | FilmeGeneroCreateWithoutGeneroInput[] | FilmeGeneroUncheckedCreateWithoutGeneroInput[]
    connectOrCreate?: FilmeGeneroCreateOrConnectWithoutGeneroInput | FilmeGeneroCreateOrConnectWithoutGeneroInput[]
    createMany?: FilmeGeneroCreateManyGeneroInputEnvelope
    connect?: FilmeGeneroWhereUniqueInput | FilmeGeneroWhereUniqueInput[]
  }

  export type FilmeGeneroUncheckedCreateNestedManyWithoutGeneroInput = {
    create?: XOR<FilmeGeneroCreateWithoutGeneroInput, FilmeGeneroUncheckedCreateWithoutGeneroInput> | FilmeGeneroCreateWithoutGeneroInput[] | FilmeGeneroUncheckedCreateWithoutGeneroInput[]
    connectOrCreate?: FilmeGeneroCreateOrConnectWithoutGeneroInput | FilmeGeneroCreateOrConnectWithoutGeneroInput[]
    createMany?: FilmeGeneroCreateManyGeneroInputEnvelope
    connect?: FilmeGeneroWhereUniqueInput | FilmeGeneroWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type FilmeGeneroUpdateManyWithoutGeneroNestedInput = {
    create?: XOR<FilmeGeneroCreateWithoutGeneroInput, FilmeGeneroUncheckedCreateWithoutGeneroInput> | FilmeGeneroCreateWithoutGeneroInput[] | FilmeGeneroUncheckedCreateWithoutGeneroInput[]
    connectOrCreate?: FilmeGeneroCreateOrConnectWithoutGeneroInput | FilmeGeneroCreateOrConnectWithoutGeneroInput[]
    upsert?: FilmeGeneroUpsertWithWhereUniqueWithoutGeneroInput | FilmeGeneroUpsertWithWhereUniqueWithoutGeneroInput[]
    createMany?: FilmeGeneroCreateManyGeneroInputEnvelope
    set?: FilmeGeneroWhereUniqueInput | FilmeGeneroWhereUniqueInput[]
    disconnect?: FilmeGeneroWhereUniqueInput | FilmeGeneroWhereUniqueInput[]
    delete?: FilmeGeneroWhereUniqueInput | FilmeGeneroWhereUniqueInput[]
    connect?: FilmeGeneroWhereUniqueInput | FilmeGeneroWhereUniqueInput[]
    update?: FilmeGeneroUpdateWithWhereUniqueWithoutGeneroInput | FilmeGeneroUpdateWithWhereUniqueWithoutGeneroInput[]
    updateMany?: FilmeGeneroUpdateManyWithWhereWithoutGeneroInput | FilmeGeneroUpdateManyWithWhereWithoutGeneroInput[]
    deleteMany?: FilmeGeneroScalarWhereInput | FilmeGeneroScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FilmeGeneroUncheckedUpdateManyWithoutGeneroNestedInput = {
    create?: XOR<FilmeGeneroCreateWithoutGeneroInput, FilmeGeneroUncheckedCreateWithoutGeneroInput> | FilmeGeneroCreateWithoutGeneroInput[] | FilmeGeneroUncheckedCreateWithoutGeneroInput[]
    connectOrCreate?: FilmeGeneroCreateOrConnectWithoutGeneroInput | FilmeGeneroCreateOrConnectWithoutGeneroInput[]
    upsert?: FilmeGeneroUpsertWithWhereUniqueWithoutGeneroInput | FilmeGeneroUpsertWithWhereUniqueWithoutGeneroInput[]
    createMany?: FilmeGeneroCreateManyGeneroInputEnvelope
    set?: FilmeGeneroWhereUniqueInput | FilmeGeneroWhereUniqueInput[]
    disconnect?: FilmeGeneroWhereUniqueInput | FilmeGeneroWhereUniqueInput[]
    delete?: FilmeGeneroWhereUniqueInput | FilmeGeneroWhereUniqueInput[]
    connect?: FilmeGeneroWhereUniqueInput | FilmeGeneroWhereUniqueInput[]
    update?: FilmeGeneroUpdateWithWhereUniqueWithoutGeneroInput | FilmeGeneroUpdateWithWhereUniqueWithoutGeneroInput[]
    updateMany?: FilmeGeneroUpdateManyWithWhereWithoutGeneroInput | FilmeGeneroUpdateManyWithWhereWithoutGeneroInput[]
    deleteMany?: FilmeGeneroScalarWhereInput | FilmeGeneroScalarWhereInput[]
  }

  export type FilmeCreateNestedOneWithoutGenerosInput = {
    create?: XOR<FilmeCreateWithoutGenerosInput, FilmeUncheckedCreateWithoutGenerosInput>
    connectOrCreate?: FilmeCreateOrConnectWithoutGenerosInput
    connect?: FilmeWhereUniqueInput
  }

  export type GeneroCreateNestedOneWithoutFilmesInput = {
    create?: XOR<GeneroCreateWithoutFilmesInput, GeneroUncheckedCreateWithoutFilmesInput>
    connectOrCreate?: GeneroCreateOrConnectWithoutFilmesInput
    connect?: GeneroWhereUniqueInput
  }

  export type FilmeUpdateOneRequiredWithoutGenerosNestedInput = {
    create?: XOR<FilmeCreateWithoutGenerosInput, FilmeUncheckedCreateWithoutGenerosInput>
    connectOrCreate?: FilmeCreateOrConnectWithoutGenerosInput
    upsert?: FilmeUpsertWithoutGenerosInput
    connect?: FilmeWhereUniqueInput
    update?: XOR<XOR<FilmeUpdateToOneWithWhereWithoutGenerosInput, FilmeUpdateWithoutGenerosInput>, FilmeUncheckedUpdateWithoutGenerosInput>
  }

  export type GeneroUpdateOneRequiredWithoutFilmesNestedInput = {
    create?: XOR<GeneroCreateWithoutFilmesInput, GeneroUncheckedCreateWithoutFilmesInput>
    connectOrCreate?: GeneroCreateOrConnectWithoutFilmesInput
    upsert?: GeneroUpsertWithoutFilmesInput
    connect?: GeneroWhereUniqueInput
    update?: XOR<XOR<GeneroUpdateToOneWithWhereWithoutFilmesInput, GeneroUpdateWithoutFilmesInput>, GeneroUncheckedUpdateWithoutFilmesInput>
  }

  export type ClassificacaoIndicativaCreateNestedOneWithoutFilmesInput = {
    create?: XOR<ClassificacaoIndicativaCreateWithoutFilmesInput, ClassificacaoIndicativaUncheckedCreateWithoutFilmesInput>
    connectOrCreate?: ClassificacaoIndicativaCreateOrConnectWithoutFilmesInput
    connect?: ClassificacaoIndicativaWhereUniqueInput
  }

  export type FilmeGeneroCreateNestedManyWithoutFilmeInput = {
    create?: XOR<FilmeGeneroCreateWithoutFilmeInput, FilmeGeneroUncheckedCreateWithoutFilmeInput> | FilmeGeneroCreateWithoutFilmeInput[] | FilmeGeneroUncheckedCreateWithoutFilmeInput[]
    connectOrCreate?: FilmeGeneroCreateOrConnectWithoutFilmeInput | FilmeGeneroCreateOrConnectWithoutFilmeInput[]
    createMany?: FilmeGeneroCreateManyFilmeInputEnvelope
    connect?: FilmeGeneroWhereUniqueInput | FilmeGeneroWhereUniqueInput[]
  }

  export type FilmeIntegranteCreateNestedManyWithoutFilmeInput = {
    create?: XOR<FilmeIntegranteCreateWithoutFilmeInput, FilmeIntegranteUncheckedCreateWithoutFilmeInput> | FilmeIntegranteCreateWithoutFilmeInput[] | FilmeIntegranteUncheckedCreateWithoutFilmeInput[]
    connectOrCreate?: FilmeIntegranteCreateOrConnectWithoutFilmeInput | FilmeIntegranteCreateOrConnectWithoutFilmeInput[]
    createMany?: FilmeIntegranteCreateManyFilmeInputEnvelope
    connect?: FilmeIntegranteWhereUniqueInput | FilmeIntegranteWhereUniqueInput[]
  }

  export type SessaoCreateNestedManyWithoutFilmeInput = {
    create?: XOR<SessaoCreateWithoutFilmeInput, SessaoUncheckedCreateWithoutFilmeInput> | SessaoCreateWithoutFilmeInput[] | SessaoUncheckedCreateWithoutFilmeInput[]
    connectOrCreate?: SessaoCreateOrConnectWithoutFilmeInput | SessaoCreateOrConnectWithoutFilmeInput[]
    createMany?: SessaoCreateManyFilmeInputEnvelope
    connect?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
  }

  export type FilmeGeneroUncheckedCreateNestedManyWithoutFilmeInput = {
    create?: XOR<FilmeGeneroCreateWithoutFilmeInput, FilmeGeneroUncheckedCreateWithoutFilmeInput> | FilmeGeneroCreateWithoutFilmeInput[] | FilmeGeneroUncheckedCreateWithoutFilmeInput[]
    connectOrCreate?: FilmeGeneroCreateOrConnectWithoutFilmeInput | FilmeGeneroCreateOrConnectWithoutFilmeInput[]
    createMany?: FilmeGeneroCreateManyFilmeInputEnvelope
    connect?: FilmeGeneroWhereUniqueInput | FilmeGeneroWhereUniqueInput[]
  }

  export type FilmeIntegranteUncheckedCreateNestedManyWithoutFilmeInput = {
    create?: XOR<FilmeIntegranteCreateWithoutFilmeInput, FilmeIntegranteUncheckedCreateWithoutFilmeInput> | FilmeIntegranteCreateWithoutFilmeInput[] | FilmeIntegranteUncheckedCreateWithoutFilmeInput[]
    connectOrCreate?: FilmeIntegranteCreateOrConnectWithoutFilmeInput | FilmeIntegranteCreateOrConnectWithoutFilmeInput[]
    createMany?: FilmeIntegranteCreateManyFilmeInputEnvelope
    connect?: FilmeIntegranteWhereUniqueInput | FilmeIntegranteWhereUniqueInput[]
  }

  export type SessaoUncheckedCreateNestedManyWithoutFilmeInput = {
    create?: XOR<SessaoCreateWithoutFilmeInput, SessaoUncheckedCreateWithoutFilmeInput> | SessaoCreateWithoutFilmeInput[] | SessaoUncheckedCreateWithoutFilmeInput[]
    connectOrCreate?: SessaoCreateOrConnectWithoutFilmeInput | SessaoCreateOrConnectWithoutFilmeInput[]
    createMany?: SessaoCreateManyFilmeInputEnvelope
    connect?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
  }

  export type ClassificacaoIndicativaUpdateOneRequiredWithoutFilmesNestedInput = {
    create?: XOR<ClassificacaoIndicativaCreateWithoutFilmesInput, ClassificacaoIndicativaUncheckedCreateWithoutFilmesInput>
    connectOrCreate?: ClassificacaoIndicativaCreateOrConnectWithoutFilmesInput
    upsert?: ClassificacaoIndicativaUpsertWithoutFilmesInput
    connect?: ClassificacaoIndicativaWhereUniqueInput
    update?: XOR<XOR<ClassificacaoIndicativaUpdateToOneWithWhereWithoutFilmesInput, ClassificacaoIndicativaUpdateWithoutFilmesInput>, ClassificacaoIndicativaUncheckedUpdateWithoutFilmesInput>
  }

  export type FilmeGeneroUpdateManyWithoutFilmeNestedInput = {
    create?: XOR<FilmeGeneroCreateWithoutFilmeInput, FilmeGeneroUncheckedCreateWithoutFilmeInput> | FilmeGeneroCreateWithoutFilmeInput[] | FilmeGeneroUncheckedCreateWithoutFilmeInput[]
    connectOrCreate?: FilmeGeneroCreateOrConnectWithoutFilmeInput | FilmeGeneroCreateOrConnectWithoutFilmeInput[]
    upsert?: FilmeGeneroUpsertWithWhereUniqueWithoutFilmeInput | FilmeGeneroUpsertWithWhereUniqueWithoutFilmeInput[]
    createMany?: FilmeGeneroCreateManyFilmeInputEnvelope
    set?: FilmeGeneroWhereUniqueInput | FilmeGeneroWhereUniqueInput[]
    disconnect?: FilmeGeneroWhereUniqueInput | FilmeGeneroWhereUniqueInput[]
    delete?: FilmeGeneroWhereUniqueInput | FilmeGeneroWhereUniqueInput[]
    connect?: FilmeGeneroWhereUniqueInput | FilmeGeneroWhereUniqueInput[]
    update?: FilmeGeneroUpdateWithWhereUniqueWithoutFilmeInput | FilmeGeneroUpdateWithWhereUniqueWithoutFilmeInput[]
    updateMany?: FilmeGeneroUpdateManyWithWhereWithoutFilmeInput | FilmeGeneroUpdateManyWithWhereWithoutFilmeInput[]
    deleteMany?: FilmeGeneroScalarWhereInput | FilmeGeneroScalarWhereInput[]
  }

  export type FilmeIntegranteUpdateManyWithoutFilmeNestedInput = {
    create?: XOR<FilmeIntegranteCreateWithoutFilmeInput, FilmeIntegranteUncheckedCreateWithoutFilmeInput> | FilmeIntegranteCreateWithoutFilmeInput[] | FilmeIntegranteUncheckedCreateWithoutFilmeInput[]
    connectOrCreate?: FilmeIntegranteCreateOrConnectWithoutFilmeInput | FilmeIntegranteCreateOrConnectWithoutFilmeInput[]
    upsert?: FilmeIntegranteUpsertWithWhereUniqueWithoutFilmeInput | FilmeIntegranteUpsertWithWhereUniqueWithoutFilmeInput[]
    createMany?: FilmeIntegranteCreateManyFilmeInputEnvelope
    set?: FilmeIntegranteWhereUniqueInput | FilmeIntegranteWhereUniqueInput[]
    disconnect?: FilmeIntegranteWhereUniqueInput | FilmeIntegranteWhereUniqueInput[]
    delete?: FilmeIntegranteWhereUniqueInput | FilmeIntegranteWhereUniqueInput[]
    connect?: FilmeIntegranteWhereUniqueInput | FilmeIntegranteWhereUniqueInput[]
    update?: FilmeIntegranteUpdateWithWhereUniqueWithoutFilmeInput | FilmeIntegranteUpdateWithWhereUniqueWithoutFilmeInput[]
    updateMany?: FilmeIntegranteUpdateManyWithWhereWithoutFilmeInput | FilmeIntegranteUpdateManyWithWhereWithoutFilmeInput[]
    deleteMany?: FilmeIntegranteScalarWhereInput | FilmeIntegranteScalarWhereInput[]
  }

  export type SessaoUpdateManyWithoutFilmeNestedInput = {
    create?: XOR<SessaoCreateWithoutFilmeInput, SessaoUncheckedCreateWithoutFilmeInput> | SessaoCreateWithoutFilmeInput[] | SessaoUncheckedCreateWithoutFilmeInput[]
    connectOrCreate?: SessaoCreateOrConnectWithoutFilmeInput | SessaoCreateOrConnectWithoutFilmeInput[]
    upsert?: SessaoUpsertWithWhereUniqueWithoutFilmeInput | SessaoUpsertWithWhereUniqueWithoutFilmeInput[]
    createMany?: SessaoCreateManyFilmeInputEnvelope
    set?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    disconnect?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    delete?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    connect?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    update?: SessaoUpdateWithWhereUniqueWithoutFilmeInput | SessaoUpdateWithWhereUniqueWithoutFilmeInput[]
    updateMany?: SessaoUpdateManyWithWhereWithoutFilmeInput | SessaoUpdateManyWithWhereWithoutFilmeInput[]
    deleteMany?: SessaoScalarWhereInput | SessaoScalarWhereInput[]
  }

  export type FilmeGeneroUncheckedUpdateManyWithoutFilmeNestedInput = {
    create?: XOR<FilmeGeneroCreateWithoutFilmeInput, FilmeGeneroUncheckedCreateWithoutFilmeInput> | FilmeGeneroCreateWithoutFilmeInput[] | FilmeGeneroUncheckedCreateWithoutFilmeInput[]
    connectOrCreate?: FilmeGeneroCreateOrConnectWithoutFilmeInput | FilmeGeneroCreateOrConnectWithoutFilmeInput[]
    upsert?: FilmeGeneroUpsertWithWhereUniqueWithoutFilmeInput | FilmeGeneroUpsertWithWhereUniqueWithoutFilmeInput[]
    createMany?: FilmeGeneroCreateManyFilmeInputEnvelope
    set?: FilmeGeneroWhereUniqueInput | FilmeGeneroWhereUniqueInput[]
    disconnect?: FilmeGeneroWhereUniqueInput | FilmeGeneroWhereUniqueInput[]
    delete?: FilmeGeneroWhereUniqueInput | FilmeGeneroWhereUniqueInput[]
    connect?: FilmeGeneroWhereUniqueInput | FilmeGeneroWhereUniqueInput[]
    update?: FilmeGeneroUpdateWithWhereUniqueWithoutFilmeInput | FilmeGeneroUpdateWithWhereUniqueWithoutFilmeInput[]
    updateMany?: FilmeGeneroUpdateManyWithWhereWithoutFilmeInput | FilmeGeneroUpdateManyWithWhereWithoutFilmeInput[]
    deleteMany?: FilmeGeneroScalarWhereInput | FilmeGeneroScalarWhereInput[]
  }

  export type FilmeIntegranteUncheckedUpdateManyWithoutFilmeNestedInput = {
    create?: XOR<FilmeIntegranteCreateWithoutFilmeInput, FilmeIntegranteUncheckedCreateWithoutFilmeInput> | FilmeIntegranteCreateWithoutFilmeInput[] | FilmeIntegranteUncheckedCreateWithoutFilmeInput[]
    connectOrCreate?: FilmeIntegranteCreateOrConnectWithoutFilmeInput | FilmeIntegranteCreateOrConnectWithoutFilmeInput[]
    upsert?: FilmeIntegranteUpsertWithWhereUniqueWithoutFilmeInput | FilmeIntegranteUpsertWithWhereUniqueWithoutFilmeInput[]
    createMany?: FilmeIntegranteCreateManyFilmeInputEnvelope
    set?: FilmeIntegranteWhereUniqueInput | FilmeIntegranteWhereUniqueInput[]
    disconnect?: FilmeIntegranteWhereUniqueInput | FilmeIntegranteWhereUniqueInput[]
    delete?: FilmeIntegranteWhereUniqueInput | FilmeIntegranteWhereUniqueInput[]
    connect?: FilmeIntegranteWhereUniqueInput | FilmeIntegranteWhereUniqueInput[]
    update?: FilmeIntegranteUpdateWithWhereUniqueWithoutFilmeInput | FilmeIntegranteUpdateWithWhereUniqueWithoutFilmeInput[]
    updateMany?: FilmeIntegranteUpdateManyWithWhereWithoutFilmeInput | FilmeIntegranteUpdateManyWithWhereWithoutFilmeInput[]
    deleteMany?: FilmeIntegranteScalarWhereInput | FilmeIntegranteScalarWhereInput[]
  }

  export type SessaoUncheckedUpdateManyWithoutFilmeNestedInput = {
    create?: XOR<SessaoCreateWithoutFilmeInput, SessaoUncheckedCreateWithoutFilmeInput> | SessaoCreateWithoutFilmeInput[] | SessaoUncheckedCreateWithoutFilmeInput[]
    connectOrCreate?: SessaoCreateOrConnectWithoutFilmeInput | SessaoCreateOrConnectWithoutFilmeInput[]
    upsert?: SessaoUpsertWithWhereUniqueWithoutFilmeInput | SessaoUpsertWithWhereUniqueWithoutFilmeInput[]
    createMany?: SessaoCreateManyFilmeInputEnvelope
    set?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    disconnect?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    delete?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    connect?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    update?: SessaoUpdateWithWhereUniqueWithoutFilmeInput | SessaoUpdateWithWhereUniqueWithoutFilmeInput[]
    updateMany?: SessaoUpdateManyWithWhereWithoutFilmeInput | SessaoUpdateManyWithWhereWithoutFilmeInput[]
    deleteMany?: SessaoScalarWhereInput | SessaoScalarWhereInput[]
  }

  export type FilmeCreateNestedOneWithoutIntegrantesInput = {
    create?: XOR<FilmeCreateWithoutIntegrantesInput, FilmeUncheckedCreateWithoutIntegrantesInput>
    connectOrCreate?: FilmeCreateOrConnectWithoutIntegrantesInput
    connect?: FilmeWhereUniqueInput
  }

  export type IntegranteCreateNestedOneWithoutFilmesInput = {
    create?: XOR<IntegranteCreateWithoutFilmesInput, IntegranteUncheckedCreateWithoutFilmesInput>
    connectOrCreate?: IntegranteCreateOrConnectWithoutFilmesInput
    connect?: IntegranteWhereUniqueInput
  }

  export type FilmeUpdateOneRequiredWithoutIntegrantesNestedInput = {
    create?: XOR<FilmeCreateWithoutIntegrantesInput, FilmeUncheckedCreateWithoutIntegrantesInput>
    connectOrCreate?: FilmeCreateOrConnectWithoutIntegrantesInput
    upsert?: FilmeUpsertWithoutIntegrantesInput
    connect?: FilmeWhereUniqueInput
    update?: XOR<XOR<FilmeUpdateToOneWithWhereWithoutIntegrantesInput, FilmeUpdateWithoutIntegrantesInput>, FilmeUncheckedUpdateWithoutIntegrantesInput>
  }

  export type IntegranteUpdateOneRequiredWithoutFilmesNestedInput = {
    create?: XOR<IntegranteCreateWithoutFilmesInput, IntegranteUncheckedCreateWithoutFilmesInput>
    connectOrCreate?: IntegranteCreateOrConnectWithoutFilmesInput
    upsert?: IntegranteUpsertWithoutFilmesInput
    connect?: IntegranteWhereUniqueInput
    update?: XOR<XOR<IntegranteUpdateToOneWithWhereWithoutFilmesInput, IntegranteUpdateWithoutFilmesInput>, IntegranteUncheckedUpdateWithoutFilmesInput>
  }

  export type TipoIntegranteCreateNestedOneWithoutIntegrantesInput = {
    create?: XOR<TipoIntegranteCreateWithoutIntegrantesInput, TipoIntegranteUncheckedCreateWithoutIntegrantesInput>
    connectOrCreate?: TipoIntegranteCreateOrConnectWithoutIntegrantesInput
    connect?: TipoIntegranteWhereUniqueInput
  }

  export type FilmeIntegranteCreateNestedManyWithoutIntegranteInput = {
    create?: XOR<FilmeIntegranteCreateWithoutIntegranteInput, FilmeIntegranteUncheckedCreateWithoutIntegranteInput> | FilmeIntegranteCreateWithoutIntegranteInput[] | FilmeIntegranteUncheckedCreateWithoutIntegranteInput[]
    connectOrCreate?: FilmeIntegranteCreateOrConnectWithoutIntegranteInput | FilmeIntegranteCreateOrConnectWithoutIntegranteInput[]
    createMany?: FilmeIntegranteCreateManyIntegranteInputEnvelope
    connect?: FilmeIntegranteWhereUniqueInput | FilmeIntegranteWhereUniqueInput[]
  }

  export type FilmeIntegranteUncheckedCreateNestedManyWithoutIntegranteInput = {
    create?: XOR<FilmeIntegranteCreateWithoutIntegranteInput, FilmeIntegranteUncheckedCreateWithoutIntegranteInput> | FilmeIntegranteCreateWithoutIntegranteInput[] | FilmeIntegranteUncheckedCreateWithoutIntegranteInput[]
    connectOrCreate?: FilmeIntegranteCreateOrConnectWithoutIntegranteInput | FilmeIntegranteCreateOrConnectWithoutIntegranteInput[]
    createMany?: FilmeIntegranteCreateManyIntegranteInputEnvelope
    connect?: FilmeIntegranteWhereUniqueInput | FilmeIntegranteWhereUniqueInput[]
  }

  export type TipoIntegranteUpdateOneRequiredWithoutIntegrantesNestedInput = {
    create?: XOR<TipoIntegranteCreateWithoutIntegrantesInput, TipoIntegranteUncheckedCreateWithoutIntegrantesInput>
    connectOrCreate?: TipoIntegranteCreateOrConnectWithoutIntegrantesInput
    upsert?: TipoIntegranteUpsertWithoutIntegrantesInput
    connect?: TipoIntegranteWhereUniqueInput
    update?: XOR<XOR<TipoIntegranteUpdateToOneWithWhereWithoutIntegrantesInput, TipoIntegranteUpdateWithoutIntegrantesInput>, TipoIntegranteUncheckedUpdateWithoutIntegrantesInput>
  }

  export type FilmeIntegranteUpdateManyWithoutIntegranteNestedInput = {
    create?: XOR<FilmeIntegranteCreateWithoutIntegranteInput, FilmeIntegranteUncheckedCreateWithoutIntegranteInput> | FilmeIntegranteCreateWithoutIntegranteInput[] | FilmeIntegranteUncheckedCreateWithoutIntegranteInput[]
    connectOrCreate?: FilmeIntegranteCreateOrConnectWithoutIntegranteInput | FilmeIntegranteCreateOrConnectWithoutIntegranteInput[]
    upsert?: FilmeIntegranteUpsertWithWhereUniqueWithoutIntegranteInput | FilmeIntegranteUpsertWithWhereUniqueWithoutIntegranteInput[]
    createMany?: FilmeIntegranteCreateManyIntegranteInputEnvelope
    set?: FilmeIntegranteWhereUniqueInput | FilmeIntegranteWhereUniqueInput[]
    disconnect?: FilmeIntegranteWhereUniqueInput | FilmeIntegranteWhereUniqueInput[]
    delete?: FilmeIntegranteWhereUniqueInput | FilmeIntegranteWhereUniqueInput[]
    connect?: FilmeIntegranteWhereUniqueInput | FilmeIntegranteWhereUniqueInput[]
    update?: FilmeIntegranteUpdateWithWhereUniqueWithoutIntegranteInput | FilmeIntegranteUpdateWithWhereUniqueWithoutIntegranteInput[]
    updateMany?: FilmeIntegranteUpdateManyWithWhereWithoutIntegranteInput | FilmeIntegranteUpdateManyWithWhereWithoutIntegranteInput[]
    deleteMany?: FilmeIntegranteScalarWhereInput | FilmeIntegranteScalarWhereInput[]
  }

  export type FilmeIntegranteUncheckedUpdateManyWithoutIntegranteNestedInput = {
    create?: XOR<FilmeIntegranteCreateWithoutIntegranteInput, FilmeIntegranteUncheckedCreateWithoutIntegranteInput> | FilmeIntegranteCreateWithoutIntegranteInput[] | FilmeIntegranteUncheckedCreateWithoutIntegranteInput[]
    connectOrCreate?: FilmeIntegranteCreateOrConnectWithoutIntegranteInput | FilmeIntegranteCreateOrConnectWithoutIntegranteInput[]
    upsert?: FilmeIntegranteUpsertWithWhereUniqueWithoutIntegranteInput | FilmeIntegranteUpsertWithWhereUniqueWithoutIntegranteInput[]
    createMany?: FilmeIntegranteCreateManyIntegranteInputEnvelope
    set?: FilmeIntegranteWhereUniqueInput | FilmeIntegranteWhereUniqueInput[]
    disconnect?: FilmeIntegranteWhereUniqueInput | FilmeIntegranteWhereUniqueInput[]
    delete?: FilmeIntegranteWhereUniqueInput | FilmeIntegranteWhereUniqueInput[]
    connect?: FilmeIntegranteWhereUniqueInput | FilmeIntegranteWhereUniqueInput[]
    update?: FilmeIntegranteUpdateWithWhereUniqueWithoutIntegranteInput | FilmeIntegranteUpdateWithWhereUniqueWithoutIntegranteInput[]
    updateMany?: FilmeIntegranteUpdateManyWithWhereWithoutIntegranteInput | FilmeIntegranteUpdateManyWithWhereWithoutIntegranteInput[]
    deleteMany?: FilmeIntegranteScalarWhereInput | FilmeIntegranteScalarWhereInput[]
  }

  export type IntegranteCreateNestedManyWithoutTipoIntegranteInput = {
    create?: XOR<IntegranteCreateWithoutTipoIntegranteInput, IntegranteUncheckedCreateWithoutTipoIntegranteInput> | IntegranteCreateWithoutTipoIntegranteInput[] | IntegranteUncheckedCreateWithoutTipoIntegranteInput[]
    connectOrCreate?: IntegranteCreateOrConnectWithoutTipoIntegranteInput | IntegranteCreateOrConnectWithoutTipoIntegranteInput[]
    createMany?: IntegranteCreateManyTipoIntegranteInputEnvelope
    connect?: IntegranteWhereUniqueInput | IntegranteWhereUniqueInput[]
  }

  export type IntegranteUncheckedCreateNestedManyWithoutTipoIntegranteInput = {
    create?: XOR<IntegranteCreateWithoutTipoIntegranteInput, IntegranteUncheckedCreateWithoutTipoIntegranteInput> | IntegranteCreateWithoutTipoIntegranteInput[] | IntegranteUncheckedCreateWithoutTipoIntegranteInput[]
    connectOrCreate?: IntegranteCreateOrConnectWithoutTipoIntegranteInput | IntegranteCreateOrConnectWithoutTipoIntegranteInput[]
    createMany?: IntegranteCreateManyTipoIntegranteInputEnvelope
    connect?: IntegranteWhereUniqueInput | IntegranteWhereUniqueInput[]
  }

  export type IntegranteUpdateManyWithoutTipoIntegranteNestedInput = {
    create?: XOR<IntegranteCreateWithoutTipoIntegranteInput, IntegranteUncheckedCreateWithoutTipoIntegranteInput> | IntegranteCreateWithoutTipoIntegranteInput[] | IntegranteUncheckedCreateWithoutTipoIntegranteInput[]
    connectOrCreate?: IntegranteCreateOrConnectWithoutTipoIntegranteInput | IntegranteCreateOrConnectWithoutTipoIntegranteInput[]
    upsert?: IntegranteUpsertWithWhereUniqueWithoutTipoIntegranteInput | IntegranteUpsertWithWhereUniqueWithoutTipoIntegranteInput[]
    createMany?: IntegranteCreateManyTipoIntegranteInputEnvelope
    set?: IntegranteWhereUniqueInput | IntegranteWhereUniqueInput[]
    disconnect?: IntegranteWhereUniqueInput | IntegranteWhereUniqueInput[]
    delete?: IntegranteWhereUniqueInput | IntegranteWhereUniqueInput[]
    connect?: IntegranteWhereUniqueInput | IntegranteWhereUniqueInput[]
    update?: IntegranteUpdateWithWhereUniqueWithoutTipoIntegranteInput | IntegranteUpdateWithWhereUniqueWithoutTipoIntegranteInput[]
    updateMany?: IntegranteUpdateManyWithWhereWithoutTipoIntegranteInput | IntegranteUpdateManyWithWhereWithoutTipoIntegranteInput[]
    deleteMany?: IntegranteScalarWhereInput | IntegranteScalarWhereInput[]
  }

  export type IntegranteUncheckedUpdateManyWithoutTipoIntegranteNestedInput = {
    create?: XOR<IntegranteCreateWithoutTipoIntegranteInput, IntegranteUncheckedCreateWithoutTipoIntegranteInput> | IntegranteCreateWithoutTipoIntegranteInput[] | IntegranteUncheckedCreateWithoutTipoIntegranteInput[]
    connectOrCreate?: IntegranteCreateOrConnectWithoutTipoIntegranteInput | IntegranteCreateOrConnectWithoutTipoIntegranteInput[]
    upsert?: IntegranteUpsertWithWhereUniqueWithoutTipoIntegranteInput | IntegranteUpsertWithWhereUniqueWithoutTipoIntegranteInput[]
    createMany?: IntegranteCreateManyTipoIntegranteInputEnvelope
    set?: IntegranteWhereUniqueInput | IntegranteWhereUniqueInput[]
    disconnect?: IntegranteWhereUniqueInput | IntegranteWhereUniqueInput[]
    delete?: IntegranteWhereUniqueInput | IntegranteWhereUniqueInput[]
    connect?: IntegranteWhereUniqueInput | IntegranteWhereUniqueInput[]
    update?: IntegranteUpdateWithWhereUniqueWithoutTipoIntegranteInput | IntegranteUpdateWithWhereUniqueWithoutTipoIntegranteInput[]
    updateMany?: IntegranteUpdateManyWithWhereWithoutTipoIntegranteInput | IntegranteUpdateManyWithWhereWithoutTipoIntegranteInput[]
    deleteMany?: IntegranteScalarWhereInput | IntegranteScalarWhereInput[]
  }

  export type FilmeCreateNestedManyWithoutClassificacaoIndicativaInput = {
    create?: XOR<FilmeCreateWithoutClassificacaoIndicativaInput, FilmeUncheckedCreateWithoutClassificacaoIndicativaInput> | FilmeCreateWithoutClassificacaoIndicativaInput[] | FilmeUncheckedCreateWithoutClassificacaoIndicativaInput[]
    connectOrCreate?: FilmeCreateOrConnectWithoutClassificacaoIndicativaInput | FilmeCreateOrConnectWithoutClassificacaoIndicativaInput[]
    createMany?: FilmeCreateManyClassificacaoIndicativaInputEnvelope
    connect?: FilmeWhereUniqueInput | FilmeWhereUniqueInput[]
  }

  export type FilmeUncheckedCreateNestedManyWithoutClassificacaoIndicativaInput = {
    create?: XOR<FilmeCreateWithoutClassificacaoIndicativaInput, FilmeUncheckedCreateWithoutClassificacaoIndicativaInput> | FilmeCreateWithoutClassificacaoIndicativaInput[] | FilmeUncheckedCreateWithoutClassificacaoIndicativaInput[]
    connectOrCreate?: FilmeCreateOrConnectWithoutClassificacaoIndicativaInput | FilmeCreateOrConnectWithoutClassificacaoIndicativaInput[]
    createMany?: FilmeCreateManyClassificacaoIndicativaInputEnvelope
    connect?: FilmeWhereUniqueInput | FilmeWhereUniqueInput[]
  }

  export type FilmeUpdateManyWithoutClassificacaoIndicativaNestedInput = {
    create?: XOR<FilmeCreateWithoutClassificacaoIndicativaInput, FilmeUncheckedCreateWithoutClassificacaoIndicativaInput> | FilmeCreateWithoutClassificacaoIndicativaInput[] | FilmeUncheckedCreateWithoutClassificacaoIndicativaInput[]
    connectOrCreate?: FilmeCreateOrConnectWithoutClassificacaoIndicativaInput | FilmeCreateOrConnectWithoutClassificacaoIndicativaInput[]
    upsert?: FilmeUpsertWithWhereUniqueWithoutClassificacaoIndicativaInput | FilmeUpsertWithWhereUniqueWithoutClassificacaoIndicativaInput[]
    createMany?: FilmeCreateManyClassificacaoIndicativaInputEnvelope
    set?: FilmeWhereUniqueInput | FilmeWhereUniqueInput[]
    disconnect?: FilmeWhereUniqueInput | FilmeWhereUniqueInput[]
    delete?: FilmeWhereUniqueInput | FilmeWhereUniqueInput[]
    connect?: FilmeWhereUniqueInput | FilmeWhereUniqueInput[]
    update?: FilmeUpdateWithWhereUniqueWithoutClassificacaoIndicativaInput | FilmeUpdateWithWhereUniqueWithoutClassificacaoIndicativaInput[]
    updateMany?: FilmeUpdateManyWithWhereWithoutClassificacaoIndicativaInput | FilmeUpdateManyWithWhereWithoutClassificacaoIndicativaInput[]
    deleteMany?: FilmeScalarWhereInput | FilmeScalarWhereInput[]
  }

  export type FilmeUncheckedUpdateManyWithoutClassificacaoIndicativaNestedInput = {
    create?: XOR<FilmeCreateWithoutClassificacaoIndicativaInput, FilmeUncheckedCreateWithoutClassificacaoIndicativaInput> | FilmeCreateWithoutClassificacaoIndicativaInput[] | FilmeUncheckedCreateWithoutClassificacaoIndicativaInput[]
    connectOrCreate?: FilmeCreateOrConnectWithoutClassificacaoIndicativaInput | FilmeCreateOrConnectWithoutClassificacaoIndicativaInput[]
    upsert?: FilmeUpsertWithWhereUniqueWithoutClassificacaoIndicativaInput | FilmeUpsertWithWhereUniqueWithoutClassificacaoIndicativaInput[]
    createMany?: FilmeCreateManyClassificacaoIndicativaInputEnvelope
    set?: FilmeWhereUniqueInput | FilmeWhereUniqueInput[]
    disconnect?: FilmeWhereUniqueInput | FilmeWhereUniqueInput[]
    delete?: FilmeWhereUniqueInput | FilmeWhereUniqueInput[]
    connect?: FilmeWhereUniqueInput | FilmeWhereUniqueInput[]
    update?: FilmeUpdateWithWhereUniqueWithoutClassificacaoIndicativaInput | FilmeUpdateWithWhereUniqueWithoutClassificacaoIndicativaInput[]
    updateMany?: FilmeUpdateManyWithWhereWithoutClassificacaoIndicativaInput | FilmeUpdateManyWithWhereWithoutClassificacaoIndicativaInput[]
    deleteMany?: FilmeScalarWhereInput | FilmeScalarWhereInput[]
  }

  export type SessaoCreateNestedManyWithoutTipoIdiomaInput = {
    create?: XOR<SessaoCreateWithoutTipoIdiomaInput, SessaoUncheckedCreateWithoutTipoIdiomaInput> | SessaoCreateWithoutTipoIdiomaInput[] | SessaoUncheckedCreateWithoutTipoIdiomaInput[]
    connectOrCreate?: SessaoCreateOrConnectWithoutTipoIdiomaInput | SessaoCreateOrConnectWithoutTipoIdiomaInput[]
    createMany?: SessaoCreateManyTipoIdiomaInputEnvelope
    connect?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
  }

  export type SessaoUncheckedCreateNestedManyWithoutTipoIdiomaInput = {
    create?: XOR<SessaoCreateWithoutTipoIdiomaInput, SessaoUncheckedCreateWithoutTipoIdiomaInput> | SessaoCreateWithoutTipoIdiomaInput[] | SessaoUncheckedCreateWithoutTipoIdiomaInput[]
    connectOrCreate?: SessaoCreateOrConnectWithoutTipoIdiomaInput | SessaoCreateOrConnectWithoutTipoIdiomaInput[]
    createMany?: SessaoCreateManyTipoIdiomaInputEnvelope
    connect?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
  }

  export type SessaoUpdateManyWithoutTipoIdiomaNestedInput = {
    create?: XOR<SessaoCreateWithoutTipoIdiomaInput, SessaoUncheckedCreateWithoutTipoIdiomaInput> | SessaoCreateWithoutTipoIdiomaInput[] | SessaoUncheckedCreateWithoutTipoIdiomaInput[]
    connectOrCreate?: SessaoCreateOrConnectWithoutTipoIdiomaInput | SessaoCreateOrConnectWithoutTipoIdiomaInput[]
    upsert?: SessaoUpsertWithWhereUniqueWithoutTipoIdiomaInput | SessaoUpsertWithWhereUniqueWithoutTipoIdiomaInput[]
    createMany?: SessaoCreateManyTipoIdiomaInputEnvelope
    set?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    disconnect?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    delete?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    connect?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    update?: SessaoUpdateWithWhereUniqueWithoutTipoIdiomaInput | SessaoUpdateWithWhereUniqueWithoutTipoIdiomaInput[]
    updateMany?: SessaoUpdateManyWithWhereWithoutTipoIdiomaInput | SessaoUpdateManyWithWhereWithoutTipoIdiomaInput[]
    deleteMany?: SessaoScalarWhereInput | SessaoScalarWhereInput[]
  }

  export type SessaoUncheckedUpdateManyWithoutTipoIdiomaNestedInput = {
    create?: XOR<SessaoCreateWithoutTipoIdiomaInput, SessaoUncheckedCreateWithoutTipoIdiomaInput> | SessaoCreateWithoutTipoIdiomaInput[] | SessaoUncheckedCreateWithoutTipoIdiomaInput[]
    connectOrCreate?: SessaoCreateOrConnectWithoutTipoIdiomaInput | SessaoCreateOrConnectWithoutTipoIdiomaInput[]
    upsert?: SessaoUpsertWithWhereUniqueWithoutTipoIdiomaInput | SessaoUpsertWithWhereUniqueWithoutTipoIdiomaInput[]
    createMany?: SessaoCreateManyTipoIdiomaInputEnvelope
    set?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    disconnect?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    delete?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    connect?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    update?: SessaoUpdateWithWhereUniqueWithoutTipoIdiomaInput | SessaoUpdateWithWhereUniqueWithoutTipoIdiomaInput[]
    updateMany?: SessaoUpdateManyWithWhereWithoutTipoIdiomaInput | SessaoUpdateManyWithWhereWithoutTipoIdiomaInput[]
    deleteMany?: SessaoScalarWhereInput | SessaoScalarWhereInput[]
  }

  export type SessaoCreateNestedManyWithoutTipoSessaoInput = {
    create?: XOR<SessaoCreateWithoutTipoSessaoInput, SessaoUncheckedCreateWithoutTipoSessaoInput> | SessaoCreateWithoutTipoSessaoInput[] | SessaoUncheckedCreateWithoutTipoSessaoInput[]
    connectOrCreate?: SessaoCreateOrConnectWithoutTipoSessaoInput | SessaoCreateOrConnectWithoutTipoSessaoInput[]
    createMany?: SessaoCreateManyTipoSessaoInputEnvelope
    connect?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
  }

  export type SessaoUncheckedCreateNestedManyWithoutTipoSessaoInput = {
    create?: XOR<SessaoCreateWithoutTipoSessaoInput, SessaoUncheckedCreateWithoutTipoSessaoInput> | SessaoCreateWithoutTipoSessaoInput[] | SessaoUncheckedCreateWithoutTipoSessaoInput[]
    connectOrCreate?: SessaoCreateOrConnectWithoutTipoSessaoInput | SessaoCreateOrConnectWithoutTipoSessaoInput[]
    createMany?: SessaoCreateManyTipoSessaoInputEnvelope
    connect?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
  }

  export type SessaoUpdateManyWithoutTipoSessaoNestedInput = {
    create?: XOR<SessaoCreateWithoutTipoSessaoInput, SessaoUncheckedCreateWithoutTipoSessaoInput> | SessaoCreateWithoutTipoSessaoInput[] | SessaoUncheckedCreateWithoutTipoSessaoInput[]
    connectOrCreate?: SessaoCreateOrConnectWithoutTipoSessaoInput | SessaoCreateOrConnectWithoutTipoSessaoInput[]
    upsert?: SessaoUpsertWithWhereUniqueWithoutTipoSessaoInput | SessaoUpsertWithWhereUniqueWithoutTipoSessaoInput[]
    createMany?: SessaoCreateManyTipoSessaoInputEnvelope
    set?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    disconnect?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    delete?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    connect?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    update?: SessaoUpdateWithWhereUniqueWithoutTipoSessaoInput | SessaoUpdateWithWhereUniqueWithoutTipoSessaoInput[]
    updateMany?: SessaoUpdateManyWithWhereWithoutTipoSessaoInput | SessaoUpdateManyWithWhereWithoutTipoSessaoInput[]
    deleteMany?: SessaoScalarWhereInput | SessaoScalarWhereInput[]
  }

  export type SessaoUncheckedUpdateManyWithoutTipoSessaoNestedInput = {
    create?: XOR<SessaoCreateWithoutTipoSessaoInput, SessaoUncheckedCreateWithoutTipoSessaoInput> | SessaoCreateWithoutTipoSessaoInput[] | SessaoUncheckedCreateWithoutTipoSessaoInput[]
    connectOrCreate?: SessaoCreateOrConnectWithoutTipoSessaoInput | SessaoCreateOrConnectWithoutTipoSessaoInput[]
    upsert?: SessaoUpsertWithWhereUniqueWithoutTipoSessaoInput | SessaoUpsertWithWhereUniqueWithoutTipoSessaoInput[]
    createMany?: SessaoCreateManyTipoSessaoInputEnvelope
    set?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    disconnect?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    delete?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    connect?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    update?: SessaoUpdateWithWhereUniqueWithoutTipoSessaoInput | SessaoUpdateWithWhereUniqueWithoutTipoSessaoInput[]
    updateMany?: SessaoUpdateManyWithWhereWithoutTipoSessaoInput | SessaoUpdateManyWithWhereWithoutTipoSessaoInput[]
    deleteMany?: SessaoScalarWhereInput | SessaoScalarWhereInput[]
  }

  export type FilmeCreateNestedOneWithoutSessoesInput = {
    create?: XOR<FilmeCreateWithoutSessoesInput, FilmeUncheckedCreateWithoutSessoesInput>
    connectOrCreate?: FilmeCreateOrConnectWithoutSessoesInput
    connect?: FilmeWhereUniqueInput
  }

  export type SalaCreateNestedOneWithoutSessoesInput = {
    create?: XOR<SalaCreateWithoutSessoesInput, SalaUncheckedCreateWithoutSessoesInput>
    connectOrCreate?: SalaCreateOrConnectWithoutSessoesInput
    connect?: SalaWhereUniqueInput
  }

  export type TipoSessaoCreateNestedOneWithoutSessoesInput = {
    create?: XOR<TipoSessaoCreateWithoutSessoesInput, TipoSessaoUncheckedCreateWithoutSessoesInput>
    connectOrCreate?: TipoSessaoCreateOrConnectWithoutSessoesInput
    connect?: TipoSessaoWhereUniqueInput
  }

  export type TipoIdiomaCreateNestedOneWithoutSessoesInput = {
    create?: XOR<TipoIdiomaCreateWithoutSessoesInput, TipoIdiomaUncheckedCreateWithoutSessoesInput>
    connectOrCreate?: TipoIdiomaCreateOrConnectWithoutSessoesInput
    connect?: TipoIdiomaWhereUniqueInput
  }

  export type SessaoAssentoCreateNestedManyWithoutSessaoInput = {
    create?: XOR<SessaoAssentoCreateWithoutSessaoInput, SessaoAssentoUncheckedCreateWithoutSessaoInput> | SessaoAssentoCreateWithoutSessaoInput[] | SessaoAssentoUncheckedCreateWithoutSessaoInput[]
    connectOrCreate?: SessaoAssentoCreateOrConnectWithoutSessaoInput | SessaoAssentoCreateOrConnectWithoutSessaoInput[]
    createMany?: SessaoAssentoCreateManySessaoInputEnvelope
    connect?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
  }

  export type SessaoAssentoUncheckedCreateNestedManyWithoutSessaoInput = {
    create?: XOR<SessaoAssentoCreateWithoutSessaoInput, SessaoAssentoUncheckedCreateWithoutSessaoInput> | SessaoAssentoCreateWithoutSessaoInput[] | SessaoAssentoUncheckedCreateWithoutSessaoInput[]
    connectOrCreate?: SessaoAssentoCreateOrConnectWithoutSessaoInput | SessaoAssentoCreateOrConnectWithoutSessaoInput[]
    createMany?: SessaoAssentoCreateManySessaoInputEnvelope
    connect?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
  }

  export type FilmeUpdateOneRequiredWithoutSessoesNestedInput = {
    create?: XOR<FilmeCreateWithoutSessoesInput, FilmeUncheckedCreateWithoutSessoesInput>
    connectOrCreate?: FilmeCreateOrConnectWithoutSessoesInput
    upsert?: FilmeUpsertWithoutSessoesInput
    connect?: FilmeWhereUniqueInput
    update?: XOR<XOR<FilmeUpdateToOneWithWhereWithoutSessoesInput, FilmeUpdateWithoutSessoesInput>, FilmeUncheckedUpdateWithoutSessoesInput>
  }

  export type SalaUpdateOneRequiredWithoutSessoesNestedInput = {
    create?: XOR<SalaCreateWithoutSessoesInput, SalaUncheckedCreateWithoutSessoesInput>
    connectOrCreate?: SalaCreateOrConnectWithoutSessoesInput
    upsert?: SalaUpsertWithoutSessoesInput
    connect?: SalaWhereUniqueInput
    update?: XOR<XOR<SalaUpdateToOneWithWhereWithoutSessoesInput, SalaUpdateWithoutSessoesInput>, SalaUncheckedUpdateWithoutSessoesInput>
  }

  export type TipoSessaoUpdateOneRequiredWithoutSessoesNestedInput = {
    create?: XOR<TipoSessaoCreateWithoutSessoesInput, TipoSessaoUncheckedCreateWithoutSessoesInput>
    connectOrCreate?: TipoSessaoCreateOrConnectWithoutSessoesInput
    upsert?: TipoSessaoUpsertWithoutSessoesInput
    connect?: TipoSessaoWhereUniqueInput
    update?: XOR<XOR<TipoSessaoUpdateToOneWithWhereWithoutSessoesInput, TipoSessaoUpdateWithoutSessoesInput>, TipoSessaoUncheckedUpdateWithoutSessoesInput>
  }

  export type TipoIdiomaUpdateOneRequiredWithoutSessoesNestedInput = {
    create?: XOR<TipoIdiomaCreateWithoutSessoesInput, TipoIdiomaUncheckedCreateWithoutSessoesInput>
    connectOrCreate?: TipoIdiomaCreateOrConnectWithoutSessoesInput
    upsert?: TipoIdiomaUpsertWithoutSessoesInput
    connect?: TipoIdiomaWhereUniqueInput
    update?: XOR<XOR<TipoIdiomaUpdateToOneWithWhereWithoutSessoesInput, TipoIdiomaUpdateWithoutSessoesInput>, TipoIdiomaUncheckedUpdateWithoutSessoesInput>
  }

  export type SessaoAssentoUpdateManyWithoutSessaoNestedInput = {
    create?: XOR<SessaoAssentoCreateWithoutSessaoInput, SessaoAssentoUncheckedCreateWithoutSessaoInput> | SessaoAssentoCreateWithoutSessaoInput[] | SessaoAssentoUncheckedCreateWithoutSessaoInput[]
    connectOrCreate?: SessaoAssentoCreateOrConnectWithoutSessaoInput | SessaoAssentoCreateOrConnectWithoutSessaoInput[]
    upsert?: SessaoAssentoUpsertWithWhereUniqueWithoutSessaoInput | SessaoAssentoUpsertWithWhereUniqueWithoutSessaoInput[]
    createMany?: SessaoAssentoCreateManySessaoInputEnvelope
    set?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    disconnect?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    delete?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    connect?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    update?: SessaoAssentoUpdateWithWhereUniqueWithoutSessaoInput | SessaoAssentoUpdateWithWhereUniqueWithoutSessaoInput[]
    updateMany?: SessaoAssentoUpdateManyWithWhereWithoutSessaoInput | SessaoAssentoUpdateManyWithWhereWithoutSessaoInput[]
    deleteMany?: SessaoAssentoScalarWhereInput | SessaoAssentoScalarWhereInput[]
  }

  export type SessaoAssentoUncheckedUpdateManyWithoutSessaoNestedInput = {
    create?: XOR<SessaoAssentoCreateWithoutSessaoInput, SessaoAssentoUncheckedCreateWithoutSessaoInput> | SessaoAssentoCreateWithoutSessaoInput[] | SessaoAssentoUncheckedCreateWithoutSessaoInput[]
    connectOrCreate?: SessaoAssentoCreateOrConnectWithoutSessaoInput | SessaoAssentoCreateOrConnectWithoutSessaoInput[]
    upsert?: SessaoAssentoUpsertWithWhereUniqueWithoutSessaoInput | SessaoAssentoUpsertWithWhereUniqueWithoutSessaoInput[]
    createMany?: SessaoAssentoCreateManySessaoInputEnvelope
    set?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    disconnect?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    delete?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    connect?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    update?: SessaoAssentoUpdateWithWhereUniqueWithoutSessaoInput | SessaoAssentoUpdateWithWhereUniqueWithoutSessaoInput[]
    updateMany?: SessaoAssentoUpdateManyWithWhereWithoutSessaoInput | SessaoAssentoUpdateManyWithWhereWithoutSessaoInput[]
    deleteMany?: SessaoAssentoScalarWhereInput | SessaoAssentoScalarWhereInput[]
  }

  export type SalaCreateNestedManyWithoutTipoSalaInput = {
    create?: XOR<SalaCreateWithoutTipoSalaInput, SalaUncheckedCreateWithoutTipoSalaInput> | SalaCreateWithoutTipoSalaInput[] | SalaUncheckedCreateWithoutTipoSalaInput[]
    connectOrCreate?: SalaCreateOrConnectWithoutTipoSalaInput | SalaCreateOrConnectWithoutTipoSalaInput[]
    createMany?: SalaCreateManyTipoSalaInputEnvelope
    connect?: SalaWhereUniqueInput | SalaWhereUniqueInput[]
  }

  export type SalaUncheckedCreateNestedManyWithoutTipoSalaInput = {
    create?: XOR<SalaCreateWithoutTipoSalaInput, SalaUncheckedCreateWithoutTipoSalaInput> | SalaCreateWithoutTipoSalaInput[] | SalaUncheckedCreateWithoutTipoSalaInput[]
    connectOrCreate?: SalaCreateOrConnectWithoutTipoSalaInput | SalaCreateOrConnectWithoutTipoSalaInput[]
    createMany?: SalaCreateManyTipoSalaInputEnvelope
    connect?: SalaWhereUniqueInput | SalaWhereUniqueInput[]
  }

  export type SalaUpdateManyWithoutTipoSalaNestedInput = {
    create?: XOR<SalaCreateWithoutTipoSalaInput, SalaUncheckedCreateWithoutTipoSalaInput> | SalaCreateWithoutTipoSalaInput[] | SalaUncheckedCreateWithoutTipoSalaInput[]
    connectOrCreate?: SalaCreateOrConnectWithoutTipoSalaInput | SalaCreateOrConnectWithoutTipoSalaInput[]
    upsert?: SalaUpsertWithWhereUniqueWithoutTipoSalaInput | SalaUpsertWithWhereUniqueWithoutTipoSalaInput[]
    createMany?: SalaCreateManyTipoSalaInputEnvelope
    set?: SalaWhereUniqueInput | SalaWhereUniqueInput[]
    disconnect?: SalaWhereUniqueInput | SalaWhereUniqueInput[]
    delete?: SalaWhereUniqueInput | SalaWhereUniqueInput[]
    connect?: SalaWhereUniqueInput | SalaWhereUniqueInput[]
    update?: SalaUpdateWithWhereUniqueWithoutTipoSalaInput | SalaUpdateWithWhereUniqueWithoutTipoSalaInput[]
    updateMany?: SalaUpdateManyWithWhereWithoutTipoSalaInput | SalaUpdateManyWithWhereWithoutTipoSalaInput[]
    deleteMany?: SalaScalarWhereInput | SalaScalarWhereInput[]
  }

  export type SalaUncheckedUpdateManyWithoutTipoSalaNestedInput = {
    create?: XOR<SalaCreateWithoutTipoSalaInput, SalaUncheckedCreateWithoutTipoSalaInput> | SalaCreateWithoutTipoSalaInput[] | SalaUncheckedCreateWithoutTipoSalaInput[]
    connectOrCreate?: SalaCreateOrConnectWithoutTipoSalaInput | SalaCreateOrConnectWithoutTipoSalaInput[]
    upsert?: SalaUpsertWithWhereUniqueWithoutTipoSalaInput | SalaUpsertWithWhereUniqueWithoutTipoSalaInput[]
    createMany?: SalaCreateManyTipoSalaInputEnvelope
    set?: SalaWhereUniqueInput | SalaWhereUniqueInput[]
    disconnect?: SalaWhereUniqueInput | SalaWhereUniqueInput[]
    delete?: SalaWhereUniqueInput | SalaWhereUniqueInput[]
    connect?: SalaWhereUniqueInput | SalaWhereUniqueInput[]
    update?: SalaUpdateWithWhereUniqueWithoutTipoSalaInput | SalaUpdateWithWhereUniqueWithoutTipoSalaInput[]
    updateMany?: SalaUpdateManyWithWhereWithoutTipoSalaInput | SalaUpdateManyWithWhereWithoutTipoSalaInput[]
    deleteMany?: SalaScalarWhereInput | SalaScalarWhereInput[]
  }

  export type TipoSalaCreateNestedOneWithoutSalasInput = {
    create?: XOR<TipoSalaCreateWithoutSalasInput, TipoSalaUncheckedCreateWithoutSalasInput>
    connectOrCreate?: TipoSalaCreateOrConnectWithoutSalasInput
    connect?: TipoSalaWhereUniqueInput
  }

  export type SessaoCreateNestedManyWithoutSalaInput = {
    create?: XOR<SessaoCreateWithoutSalaInput, SessaoUncheckedCreateWithoutSalaInput> | SessaoCreateWithoutSalaInput[] | SessaoUncheckedCreateWithoutSalaInput[]
    connectOrCreate?: SessaoCreateOrConnectWithoutSalaInput | SessaoCreateOrConnectWithoutSalaInput[]
    createMany?: SessaoCreateManySalaInputEnvelope
    connect?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
  }

  export type AssentoCreateNestedManyWithoutSalaInput = {
    create?: XOR<AssentoCreateWithoutSalaInput, AssentoUncheckedCreateWithoutSalaInput> | AssentoCreateWithoutSalaInput[] | AssentoUncheckedCreateWithoutSalaInput[]
    connectOrCreate?: AssentoCreateOrConnectWithoutSalaInput | AssentoCreateOrConnectWithoutSalaInput[]
    createMany?: AssentoCreateManySalaInputEnvelope
    connect?: AssentoWhereUniqueInput | AssentoWhereUniqueInput[]
  }

  export type SessaoUncheckedCreateNestedManyWithoutSalaInput = {
    create?: XOR<SessaoCreateWithoutSalaInput, SessaoUncheckedCreateWithoutSalaInput> | SessaoCreateWithoutSalaInput[] | SessaoUncheckedCreateWithoutSalaInput[]
    connectOrCreate?: SessaoCreateOrConnectWithoutSalaInput | SessaoCreateOrConnectWithoutSalaInput[]
    createMany?: SessaoCreateManySalaInputEnvelope
    connect?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
  }

  export type AssentoUncheckedCreateNestedManyWithoutSalaInput = {
    create?: XOR<AssentoCreateWithoutSalaInput, AssentoUncheckedCreateWithoutSalaInput> | AssentoCreateWithoutSalaInput[] | AssentoUncheckedCreateWithoutSalaInput[]
    connectOrCreate?: AssentoCreateOrConnectWithoutSalaInput | AssentoCreateOrConnectWithoutSalaInput[]
    createMany?: AssentoCreateManySalaInputEnvelope
    connect?: AssentoWhereUniqueInput | AssentoWhereUniqueInput[]
  }

  export type TipoSalaUpdateOneRequiredWithoutSalasNestedInput = {
    create?: XOR<TipoSalaCreateWithoutSalasInput, TipoSalaUncheckedCreateWithoutSalasInput>
    connectOrCreate?: TipoSalaCreateOrConnectWithoutSalasInput
    upsert?: TipoSalaUpsertWithoutSalasInput
    connect?: TipoSalaWhereUniqueInput
    update?: XOR<XOR<TipoSalaUpdateToOneWithWhereWithoutSalasInput, TipoSalaUpdateWithoutSalasInput>, TipoSalaUncheckedUpdateWithoutSalasInput>
  }

  export type SessaoUpdateManyWithoutSalaNestedInput = {
    create?: XOR<SessaoCreateWithoutSalaInput, SessaoUncheckedCreateWithoutSalaInput> | SessaoCreateWithoutSalaInput[] | SessaoUncheckedCreateWithoutSalaInput[]
    connectOrCreate?: SessaoCreateOrConnectWithoutSalaInput | SessaoCreateOrConnectWithoutSalaInput[]
    upsert?: SessaoUpsertWithWhereUniqueWithoutSalaInput | SessaoUpsertWithWhereUniqueWithoutSalaInput[]
    createMany?: SessaoCreateManySalaInputEnvelope
    set?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    disconnect?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    delete?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    connect?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    update?: SessaoUpdateWithWhereUniqueWithoutSalaInput | SessaoUpdateWithWhereUniqueWithoutSalaInput[]
    updateMany?: SessaoUpdateManyWithWhereWithoutSalaInput | SessaoUpdateManyWithWhereWithoutSalaInput[]
    deleteMany?: SessaoScalarWhereInput | SessaoScalarWhereInput[]
  }

  export type AssentoUpdateManyWithoutSalaNestedInput = {
    create?: XOR<AssentoCreateWithoutSalaInput, AssentoUncheckedCreateWithoutSalaInput> | AssentoCreateWithoutSalaInput[] | AssentoUncheckedCreateWithoutSalaInput[]
    connectOrCreate?: AssentoCreateOrConnectWithoutSalaInput | AssentoCreateOrConnectWithoutSalaInput[]
    upsert?: AssentoUpsertWithWhereUniqueWithoutSalaInput | AssentoUpsertWithWhereUniqueWithoutSalaInput[]
    createMany?: AssentoCreateManySalaInputEnvelope
    set?: AssentoWhereUniqueInput | AssentoWhereUniqueInput[]
    disconnect?: AssentoWhereUniqueInput | AssentoWhereUniqueInput[]
    delete?: AssentoWhereUniqueInput | AssentoWhereUniqueInput[]
    connect?: AssentoWhereUniqueInput | AssentoWhereUniqueInput[]
    update?: AssentoUpdateWithWhereUniqueWithoutSalaInput | AssentoUpdateWithWhereUniqueWithoutSalaInput[]
    updateMany?: AssentoUpdateManyWithWhereWithoutSalaInput | AssentoUpdateManyWithWhereWithoutSalaInput[]
    deleteMany?: AssentoScalarWhereInput | AssentoScalarWhereInput[]
  }

  export type SessaoUncheckedUpdateManyWithoutSalaNestedInput = {
    create?: XOR<SessaoCreateWithoutSalaInput, SessaoUncheckedCreateWithoutSalaInput> | SessaoCreateWithoutSalaInput[] | SessaoUncheckedCreateWithoutSalaInput[]
    connectOrCreate?: SessaoCreateOrConnectWithoutSalaInput | SessaoCreateOrConnectWithoutSalaInput[]
    upsert?: SessaoUpsertWithWhereUniqueWithoutSalaInput | SessaoUpsertWithWhereUniqueWithoutSalaInput[]
    createMany?: SessaoCreateManySalaInputEnvelope
    set?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    disconnect?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    delete?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    connect?: SessaoWhereUniqueInput | SessaoWhereUniqueInput[]
    update?: SessaoUpdateWithWhereUniqueWithoutSalaInput | SessaoUpdateWithWhereUniqueWithoutSalaInput[]
    updateMany?: SessaoUpdateManyWithWhereWithoutSalaInput | SessaoUpdateManyWithWhereWithoutSalaInput[]
    deleteMany?: SessaoScalarWhereInput | SessaoScalarWhereInput[]
  }

  export type AssentoUncheckedUpdateManyWithoutSalaNestedInput = {
    create?: XOR<AssentoCreateWithoutSalaInput, AssentoUncheckedCreateWithoutSalaInput> | AssentoCreateWithoutSalaInput[] | AssentoUncheckedCreateWithoutSalaInput[]
    connectOrCreate?: AssentoCreateOrConnectWithoutSalaInput | AssentoCreateOrConnectWithoutSalaInput[]
    upsert?: AssentoUpsertWithWhereUniqueWithoutSalaInput | AssentoUpsertWithWhereUniqueWithoutSalaInput[]
    createMany?: AssentoCreateManySalaInputEnvelope
    set?: AssentoWhereUniqueInput | AssentoWhereUniqueInput[]
    disconnect?: AssentoWhereUniqueInput | AssentoWhereUniqueInput[]
    delete?: AssentoWhereUniqueInput | AssentoWhereUniqueInput[]
    connect?: AssentoWhereUniqueInput | AssentoWhereUniqueInput[]
    update?: AssentoUpdateWithWhereUniqueWithoutSalaInput | AssentoUpdateWithWhereUniqueWithoutSalaInput[]
    updateMany?: AssentoUpdateManyWithWhereWithoutSalaInput | AssentoUpdateManyWithWhereWithoutSalaInput[]
    deleteMany?: AssentoScalarWhereInput | AssentoScalarWhereInput[]
  }

  export type AssentoCreateNestedManyWithoutTipoAssentoInput = {
    create?: XOR<AssentoCreateWithoutTipoAssentoInput, AssentoUncheckedCreateWithoutTipoAssentoInput> | AssentoCreateWithoutTipoAssentoInput[] | AssentoUncheckedCreateWithoutTipoAssentoInput[]
    connectOrCreate?: AssentoCreateOrConnectWithoutTipoAssentoInput | AssentoCreateOrConnectWithoutTipoAssentoInput[]
    createMany?: AssentoCreateManyTipoAssentoInputEnvelope
    connect?: AssentoWhereUniqueInput | AssentoWhereUniqueInput[]
  }

  export type AssentoUncheckedCreateNestedManyWithoutTipoAssentoInput = {
    create?: XOR<AssentoCreateWithoutTipoAssentoInput, AssentoUncheckedCreateWithoutTipoAssentoInput> | AssentoCreateWithoutTipoAssentoInput[] | AssentoUncheckedCreateWithoutTipoAssentoInput[]
    connectOrCreate?: AssentoCreateOrConnectWithoutTipoAssentoInput | AssentoCreateOrConnectWithoutTipoAssentoInput[]
    createMany?: AssentoCreateManyTipoAssentoInputEnvelope
    connect?: AssentoWhereUniqueInput | AssentoWhereUniqueInput[]
  }

  export type AssentoUpdateManyWithoutTipoAssentoNestedInput = {
    create?: XOR<AssentoCreateWithoutTipoAssentoInput, AssentoUncheckedCreateWithoutTipoAssentoInput> | AssentoCreateWithoutTipoAssentoInput[] | AssentoUncheckedCreateWithoutTipoAssentoInput[]
    connectOrCreate?: AssentoCreateOrConnectWithoutTipoAssentoInput | AssentoCreateOrConnectWithoutTipoAssentoInput[]
    upsert?: AssentoUpsertWithWhereUniqueWithoutTipoAssentoInput | AssentoUpsertWithWhereUniqueWithoutTipoAssentoInput[]
    createMany?: AssentoCreateManyTipoAssentoInputEnvelope
    set?: AssentoWhereUniqueInput | AssentoWhereUniqueInput[]
    disconnect?: AssentoWhereUniqueInput | AssentoWhereUniqueInput[]
    delete?: AssentoWhereUniqueInput | AssentoWhereUniqueInput[]
    connect?: AssentoWhereUniqueInput | AssentoWhereUniqueInput[]
    update?: AssentoUpdateWithWhereUniqueWithoutTipoAssentoInput | AssentoUpdateWithWhereUniqueWithoutTipoAssentoInput[]
    updateMany?: AssentoUpdateManyWithWhereWithoutTipoAssentoInput | AssentoUpdateManyWithWhereWithoutTipoAssentoInput[]
    deleteMany?: AssentoScalarWhereInput | AssentoScalarWhereInput[]
  }

  export type AssentoUncheckedUpdateManyWithoutTipoAssentoNestedInput = {
    create?: XOR<AssentoCreateWithoutTipoAssentoInput, AssentoUncheckedCreateWithoutTipoAssentoInput> | AssentoCreateWithoutTipoAssentoInput[] | AssentoUncheckedCreateWithoutTipoAssentoInput[]
    connectOrCreate?: AssentoCreateOrConnectWithoutTipoAssentoInput | AssentoCreateOrConnectWithoutTipoAssentoInput[]
    upsert?: AssentoUpsertWithWhereUniqueWithoutTipoAssentoInput | AssentoUpsertWithWhereUniqueWithoutTipoAssentoInput[]
    createMany?: AssentoCreateManyTipoAssentoInputEnvelope
    set?: AssentoWhereUniqueInput | AssentoWhereUniqueInput[]
    disconnect?: AssentoWhereUniqueInput | AssentoWhereUniqueInput[]
    delete?: AssentoWhereUniqueInput | AssentoWhereUniqueInput[]
    connect?: AssentoWhereUniqueInput | AssentoWhereUniqueInput[]
    update?: AssentoUpdateWithWhereUniqueWithoutTipoAssentoInput | AssentoUpdateWithWhereUniqueWithoutTipoAssentoInput[]
    updateMany?: AssentoUpdateManyWithWhereWithoutTipoAssentoInput | AssentoUpdateManyWithWhereWithoutTipoAssentoInput[]
    deleteMany?: AssentoScalarWhereInput | AssentoScalarWhereInput[]
  }

  export type SalaCreateNestedOneWithoutAssentosInput = {
    create?: XOR<SalaCreateWithoutAssentosInput, SalaUncheckedCreateWithoutAssentosInput>
    connectOrCreate?: SalaCreateOrConnectWithoutAssentosInput
    connect?: SalaWhereUniqueInput
  }

  export type TipoAssentoCreateNestedOneWithoutAssentosInput = {
    create?: XOR<TipoAssentoCreateWithoutAssentosInput, TipoAssentoUncheckedCreateWithoutAssentosInput>
    connectOrCreate?: TipoAssentoCreateOrConnectWithoutAssentosInput
    connect?: TipoAssentoWhereUniqueInput
  }

  export type SessaoAssentoCreateNestedManyWithoutAssentoInput = {
    create?: XOR<SessaoAssentoCreateWithoutAssentoInput, SessaoAssentoUncheckedCreateWithoutAssentoInput> | SessaoAssentoCreateWithoutAssentoInput[] | SessaoAssentoUncheckedCreateWithoutAssentoInput[]
    connectOrCreate?: SessaoAssentoCreateOrConnectWithoutAssentoInput | SessaoAssentoCreateOrConnectWithoutAssentoInput[]
    createMany?: SessaoAssentoCreateManyAssentoInputEnvelope
    connect?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
  }

  export type SessaoAssentoUncheckedCreateNestedManyWithoutAssentoInput = {
    create?: XOR<SessaoAssentoCreateWithoutAssentoInput, SessaoAssentoUncheckedCreateWithoutAssentoInput> | SessaoAssentoCreateWithoutAssentoInput[] | SessaoAssentoUncheckedCreateWithoutAssentoInput[]
    connectOrCreate?: SessaoAssentoCreateOrConnectWithoutAssentoInput | SessaoAssentoCreateOrConnectWithoutAssentoInput[]
    createMany?: SessaoAssentoCreateManyAssentoInputEnvelope
    connect?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
  }

  export type SalaUpdateOneRequiredWithoutAssentosNestedInput = {
    create?: XOR<SalaCreateWithoutAssentosInput, SalaUncheckedCreateWithoutAssentosInput>
    connectOrCreate?: SalaCreateOrConnectWithoutAssentosInput
    upsert?: SalaUpsertWithoutAssentosInput
    connect?: SalaWhereUniqueInput
    update?: XOR<XOR<SalaUpdateToOneWithWhereWithoutAssentosInput, SalaUpdateWithoutAssentosInput>, SalaUncheckedUpdateWithoutAssentosInput>
  }

  export type TipoAssentoUpdateOneRequiredWithoutAssentosNestedInput = {
    create?: XOR<TipoAssentoCreateWithoutAssentosInput, TipoAssentoUncheckedCreateWithoutAssentosInput>
    connectOrCreate?: TipoAssentoCreateOrConnectWithoutAssentosInput
    upsert?: TipoAssentoUpsertWithoutAssentosInput
    connect?: TipoAssentoWhereUniqueInput
    update?: XOR<XOR<TipoAssentoUpdateToOneWithWhereWithoutAssentosInput, TipoAssentoUpdateWithoutAssentosInput>, TipoAssentoUncheckedUpdateWithoutAssentosInput>
  }

  export type SessaoAssentoUpdateManyWithoutAssentoNestedInput = {
    create?: XOR<SessaoAssentoCreateWithoutAssentoInput, SessaoAssentoUncheckedCreateWithoutAssentoInput> | SessaoAssentoCreateWithoutAssentoInput[] | SessaoAssentoUncheckedCreateWithoutAssentoInput[]
    connectOrCreate?: SessaoAssentoCreateOrConnectWithoutAssentoInput | SessaoAssentoCreateOrConnectWithoutAssentoInput[]
    upsert?: SessaoAssentoUpsertWithWhereUniqueWithoutAssentoInput | SessaoAssentoUpsertWithWhereUniqueWithoutAssentoInput[]
    createMany?: SessaoAssentoCreateManyAssentoInputEnvelope
    set?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    disconnect?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    delete?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    connect?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    update?: SessaoAssentoUpdateWithWhereUniqueWithoutAssentoInput | SessaoAssentoUpdateWithWhereUniqueWithoutAssentoInput[]
    updateMany?: SessaoAssentoUpdateManyWithWhereWithoutAssentoInput | SessaoAssentoUpdateManyWithWhereWithoutAssentoInput[]
    deleteMany?: SessaoAssentoScalarWhereInput | SessaoAssentoScalarWhereInput[]
  }

  export type SessaoAssentoUncheckedUpdateManyWithoutAssentoNestedInput = {
    create?: XOR<SessaoAssentoCreateWithoutAssentoInput, SessaoAssentoUncheckedCreateWithoutAssentoInput> | SessaoAssentoCreateWithoutAssentoInput[] | SessaoAssentoUncheckedCreateWithoutAssentoInput[]
    connectOrCreate?: SessaoAssentoCreateOrConnectWithoutAssentoInput | SessaoAssentoCreateOrConnectWithoutAssentoInput[]
    upsert?: SessaoAssentoUpsertWithWhereUniqueWithoutAssentoInput | SessaoAssentoUpsertWithWhereUniqueWithoutAssentoInput[]
    createMany?: SessaoAssentoCreateManyAssentoInputEnvelope
    set?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    disconnect?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    delete?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    connect?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    update?: SessaoAssentoUpdateWithWhereUniqueWithoutAssentoInput | SessaoAssentoUpdateWithWhereUniqueWithoutAssentoInput[]
    updateMany?: SessaoAssentoUpdateManyWithWhereWithoutAssentoInput | SessaoAssentoUpdateManyWithWhereWithoutAssentoInput[]
    deleteMany?: SessaoAssentoScalarWhereInput | SessaoAssentoScalarWhereInput[]
  }

  export type SessaoAssentoCreateNestedManyWithoutSessaoAssentoStatusInput = {
    create?: XOR<SessaoAssentoCreateWithoutSessaoAssentoStatusInput, SessaoAssentoUncheckedCreateWithoutSessaoAssentoStatusInput> | SessaoAssentoCreateWithoutSessaoAssentoStatusInput[] | SessaoAssentoUncheckedCreateWithoutSessaoAssentoStatusInput[]
    connectOrCreate?: SessaoAssentoCreateOrConnectWithoutSessaoAssentoStatusInput | SessaoAssentoCreateOrConnectWithoutSessaoAssentoStatusInput[]
    createMany?: SessaoAssentoCreateManySessaoAssentoStatusInputEnvelope
    connect?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
  }

  export type SessaoAssentoUncheckedCreateNestedManyWithoutSessaoAssentoStatusInput = {
    create?: XOR<SessaoAssentoCreateWithoutSessaoAssentoStatusInput, SessaoAssentoUncheckedCreateWithoutSessaoAssentoStatusInput> | SessaoAssentoCreateWithoutSessaoAssentoStatusInput[] | SessaoAssentoUncheckedCreateWithoutSessaoAssentoStatusInput[]
    connectOrCreate?: SessaoAssentoCreateOrConnectWithoutSessaoAssentoStatusInput | SessaoAssentoCreateOrConnectWithoutSessaoAssentoStatusInput[]
    createMany?: SessaoAssentoCreateManySessaoAssentoStatusInputEnvelope
    connect?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
  }

  export type SessaoAssentoUpdateManyWithoutSessaoAssentoStatusNestedInput = {
    create?: XOR<SessaoAssentoCreateWithoutSessaoAssentoStatusInput, SessaoAssentoUncheckedCreateWithoutSessaoAssentoStatusInput> | SessaoAssentoCreateWithoutSessaoAssentoStatusInput[] | SessaoAssentoUncheckedCreateWithoutSessaoAssentoStatusInput[]
    connectOrCreate?: SessaoAssentoCreateOrConnectWithoutSessaoAssentoStatusInput | SessaoAssentoCreateOrConnectWithoutSessaoAssentoStatusInput[]
    upsert?: SessaoAssentoUpsertWithWhereUniqueWithoutSessaoAssentoStatusInput | SessaoAssentoUpsertWithWhereUniqueWithoutSessaoAssentoStatusInput[]
    createMany?: SessaoAssentoCreateManySessaoAssentoStatusInputEnvelope
    set?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    disconnect?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    delete?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    connect?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    update?: SessaoAssentoUpdateWithWhereUniqueWithoutSessaoAssentoStatusInput | SessaoAssentoUpdateWithWhereUniqueWithoutSessaoAssentoStatusInput[]
    updateMany?: SessaoAssentoUpdateManyWithWhereWithoutSessaoAssentoStatusInput | SessaoAssentoUpdateManyWithWhereWithoutSessaoAssentoStatusInput[]
    deleteMany?: SessaoAssentoScalarWhereInput | SessaoAssentoScalarWhereInput[]
  }

  export type SessaoAssentoUncheckedUpdateManyWithoutSessaoAssentoStatusNestedInput = {
    create?: XOR<SessaoAssentoCreateWithoutSessaoAssentoStatusInput, SessaoAssentoUncheckedCreateWithoutSessaoAssentoStatusInput> | SessaoAssentoCreateWithoutSessaoAssentoStatusInput[] | SessaoAssentoUncheckedCreateWithoutSessaoAssentoStatusInput[]
    connectOrCreate?: SessaoAssentoCreateOrConnectWithoutSessaoAssentoStatusInput | SessaoAssentoCreateOrConnectWithoutSessaoAssentoStatusInput[]
    upsert?: SessaoAssentoUpsertWithWhereUniqueWithoutSessaoAssentoStatusInput | SessaoAssentoUpsertWithWhereUniqueWithoutSessaoAssentoStatusInput[]
    createMany?: SessaoAssentoCreateManySessaoAssentoStatusInputEnvelope
    set?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    disconnect?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    delete?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    connect?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    update?: SessaoAssentoUpdateWithWhereUniqueWithoutSessaoAssentoStatusInput | SessaoAssentoUpdateWithWhereUniqueWithoutSessaoAssentoStatusInput[]
    updateMany?: SessaoAssentoUpdateManyWithWhereWithoutSessaoAssentoStatusInput | SessaoAssentoUpdateManyWithWhereWithoutSessaoAssentoStatusInput[]
    deleteMany?: SessaoAssentoScalarWhereInput | SessaoAssentoScalarWhereInput[]
  }

  export type SessaoCreateNestedOneWithoutSessoesAssentosInput = {
    create?: XOR<SessaoCreateWithoutSessoesAssentosInput, SessaoUncheckedCreateWithoutSessoesAssentosInput>
    connectOrCreate?: SessaoCreateOrConnectWithoutSessoesAssentosInput
    connect?: SessaoWhereUniqueInput
  }

  export type AssentoCreateNestedOneWithoutSessoesAssentosInput = {
    create?: XOR<AssentoCreateWithoutSessoesAssentosInput, AssentoUncheckedCreateWithoutSessoesAssentosInput>
    connectOrCreate?: AssentoCreateOrConnectWithoutSessoesAssentosInput
    connect?: AssentoWhereUniqueInput
  }

  export type IngressoCreateNestedOneWithoutSessoesAssentosInput = {
    create?: XOR<IngressoCreateWithoutSessoesAssentosInput, IngressoUncheckedCreateWithoutSessoesAssentosInput>
    connectOrCreate?: IngressoCreateOrConnectWithoutSessoesAssentosInput
    connect?: IngressoWhereUniqueInput
  }

  export type SessaoAssentoStatusCreateNestedOneWithoutSessoesAssentosInput = {
    create?: XOR<SessaoAssentoStatusCreateWithoutSessoesAssentosInput, SessaoAssentoStatusUncheckedCreateWithoutSessoesAssentosInput>
    connectOrCreate?: SessaoAssentoStatusCreateOrConnectWithoutSessoesAssentosInput
    connect?: SessaoAssentoStatusWhereUniqueInput
  }

  export type TipoEntradaCreateNestedOneWithoutSessoesAssentosInput = {
    create?: XOR<TipoEntradaCreateWithoutSessoesAssentosInput, TipoEntradaUncheckedCreateWithoutSessoesAssentosInput>
    connectOrCreate?: TipoEntradaCreateOrConnectWithoutSessoesAssentosInput
    connect?: TipoEntradaWhereUniqueInput
  }

  export type SessaoUpdateOneRequiredWithoutSessoesAssentosNestedInput = {
    create?: XOR<SessaoCreateWithoutSessoesAssentosInput, SessaoUncheckedCreateWithoutSessoesAssentosInput>
    connectOrCreate?: SessaoCreateOrConnectWithoutSessoesAssentosInput
    upsert?: SessaoUpsertWithoutSessoesAssentosInput
    connect?: SessaoWhereUniqueInput
    update?: XOR<XOR<SessaoUpdateToOneWithWhereWithoutSessoesAssentosInput, SessaoUpdateWithoutSessoesAssentosInput>, SessaoUncheckedUpdateWithoutSessoesAssentosInput>
  }

  export type AssentoUpdateOneRequiredWithoutSessoesAssentosNestedInput = {
    create?: XOR<AssentoCreateWithoutSessoesAssentosInput, AssentoUncheckedCreateWithoutSessoesAssentosInput>
    connectOrCreate?: AssentoCreateOrConnectWithoutSessoesAssentosInput
    upsert?: AssentoUpsertWithoutSessoesAssentosInput
    connect?: AssentoWhereUniqueInput
    update?: XOR<XOR<AssentoUpdateToOneWithWhereWithoutSessoesAssentosInput, AssentoUpdateWithoutSessoesAssentosInput>, AssentoUncheckedUpdateWithoutSessoesAssentosInput>
  }

  export type IngressoUpdateOneRequiredWithoutSessoesAssentosNestedInput = {
    create?: XOR<IngressoCreateWithoutSessoesAssentosInput, IngressoUncheckedCreateWithoutSessoesAssentosInput>
    connectOrCreate?: IngressoCreateOrConnectWithoutSessoesAssentosInput
    upsert?: IngressoUpsertWithoutSessoesAssentosInput
    connect?: IngressoWhereUniqueInput
    update?: XOR<XOR<IngressoUpdateToOneWithWhereWithoutSessoesAssentosInput, IngressoUpdateWithoutSessoesAssentosInput>, IngressoUncheckedUpdateWithoutSessoesAssentosInput>
  }

  export type SessaoAssentoStatusUpdateOneRequiredWithoutSessoesAssentosNestedInput = {
    create?: XOR<SessaoAssentoStatusCreateWithoutSessoesAssentosInput, SessaoAssentoStatusUncheckedCreateWithoutSessoesAssentosInput>
    connectOrCreate?: SessaoAssentoStatusCreateOrConnectWithoutSessoesAssentosInput
    upsert?: SessaoAssentoStatusUpsertWithoutSessoesAssentosInput
    connect?: SessaoAssentoStatusWhereUniqueInput
    update?: XOR<XOR<SessaoAssentoStatusUpdateToOneWithWhereWithoutSessoesAssentosInput, SessaoAssentoStatusUpdateWithoutSessoesAssentosInput>, SessaoAssentoStatusUncheckedUpdateWithoutSessoesAssentosInput>
  }

  export type TipoEntradaUpdateOneRequiredWithoutSessoesAssentosNestedInput = {
    create?: XOR<TipoEntradaCreateWithoutSessoesAssentosInput, TipoEntradaUncheckedCreateWithoutSessoesAssentosInput>
    connectOrCreate?: TipoEntradaCreateOrConnectWithoutSessoesAssentosInput
    upsert?: TipoEntradaUpsertWithoutSessoesAssentosInput
    connect?: TipoEntradaWhereUniqueInput
    update?: XOR<XOR<TipoEntradaUpdateToOneWithWhereWithoutSessoesAssentosInput, TipoEntradaUpdateWithoutSessoesAssentosInput>, TipoEntradaUncheckedUpdateWithoutSessoesAssentosInput>
  }

  export type SessaoAssentoCreateNestedManyWithoutTipoEntradaInput = {
    create?: XOR<SessaoAssentoCreateWithoutTipoEntradaInput, SessaoAssentoUncheckedCreateWithoutTipoEntradaInput> | SessaoAssentoCreateWithoutTipoEntradaInput[] | SessaoAssentoUncheckedCreateWithoutTipoEntradaInput[]
    connectOrCreate?: SessaoAssentoCreateOrConnectWithoutTipoEntradaInput | SessaoAssentoCreateOrConnectWithoutTipoEntradaInput[]
    createMany?: SessaoAssentoCreateManyTipoEntradaInputEnvelope
    connect?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
  }

  export type SessaoAssentoUncheckedCreateNestedManyWithoutTipoEntradaInput = {
    create?: XOR<SessaoAssentoCreateWithoutTipoEntradaInput, SessaoAssentoUncheckedCreateWithoutTipoEntradaInput> | SessaoAssentoCreateWithoutTipoEntradaInput[] | SessaoAssentoUncheckedCreateWithoutTipoEntradaInput[]
    connectOrCreate?: SessaoAssentoCreateOrConnectWithoutTipoEntradaInput | SessaoAssentoCreateOrConnectWithoutTipoEntradaInput[]
    createMany?: SessaoAssentoCreateManyTipoEntradaInputEnvelope
    connect?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
  }

  export type SessaoAssentoUpdateManyWithoutTipoEntradaNestedInput = {
    create?: XOR<SessaoAssentoCreateWithoutTipoEntradaInput, SessaoAssentoUncheckedCreateWithoutTipoEntradaInput> | SessaoAssentoCreateWithoutTipoEntradaInput[] | SessaoAssentoUncheckedCreateWithoutTipoEntradaInput[]
    connectOrCreate?: SessaoAssentoCreateOrConnectWithoutTipoEntradaInput | SessaoAssentoCreateOrConnectWithoutTipoEntradaInput[]
    upsert?: SessaoAssentoUpsertWithWhereUniqueWithoutTipoEntradaInput | SessaoAssentoUpsertWithWhereUniqueWithoutTipoEntradaInput[]
    createMany?: SessaoAssentoCreateManyTipoEntradaInputEnvelope
    set?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    disconnect?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    delete?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    connect?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    update?: SessaoAssentoUpdateWithWhereUniqueWithoutTipoEntradaInput | SessaoAssentoUpdateWithWhereUniqueWithoutTipoEntradaInput[]
    updateMany?: SessaoAssentoUpdateManyWithWhereWithoutTipoEntradaInput | SessaoAssentoUpdateManyWithWhereWithoutTipoEntradaInput[]
    deleteMany?: SessaoAssentoScalarWhereInput | SessaoAssentoScalarWhereInput[]
  }

  export type SessaoAssentoUncheckedUpdateManyWithoutTipoEntradaNestedInput = {
    create?: XOR<SessaoAssentoCreateWithoutTipoEntradaInput, SessaoAssentoUncheckedCreateWithoutTipoEntradaInput> | SessaoAssentoCreateWithoutTipoEntradaInput[] | SessaoAssentoUncheckedCreateWithoutTipoEntradaInput[]
    connectOrCreate?: SessaoAssentoCreateOrConnectWithoutTipoEntradaInput | SessaoAssentoCreateOrConnectWithoutTipoEntradaInput[]
    upsert?: SessaoAssentoUpsertWithWhereUniqueWithoutTipoEntradaInput | SessaoAssentoUpsertWithWhereUniqueWithoutTipoEntradaInput[]
    createMany?: SessaoAssentoCreateManyTipoEntradaInputEnvelope
    set?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    disconnect?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    delete?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    connect?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    update?: SessaoAssentoUpdateWithWhereUniqueWithoutTipoEntradaInput | SessaoAssentoUpdateWithWhereUniqueWithoutTipoEntradaInput[]
    updateMany?: SessaoAssentoUpdateManyWithWhereWithoutTipoEntradaInput | SessaoAssentoUpdateManyWithWhereWithoutTipoEntradaInput[]
    deleteMany?: SessaoAssentoScalarWhereInput | SessaoAssentoScalarWhereInput[]
  }

  export type SessaoAssentoCreateNestedManyWithoutIngressoInput = {
    create?: XOR<SessaoAssentoCreateWithoutIngressoInput, SessaoAssentoUncheckedCreateWithoutIngressoInput> | SessaoAssentoCreateWithoutIngressoInput[] | SessaoAssentoUncheckedCreateWithoutIngressoInput[]
    connectOrCreate?: SessaoAssentoCreateOrConnectWithoutIngressoInput | SessaoAssentoCreateOrConnectWithoutIngressoInput[]
    createMany?: SessaoAssentoCreateManyIngressoInputEnvelope
    connect?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
  }

  export type PagamentoCreateNestedOneWithoutIngressoInput = {
    create?: XOR<PagamentoCreateWithoutIngressoInput, PagamentoUncheckedCreateWithoutIngressoInput>
    connectOrCreate?: PagamentoCreateOrConnectWithoutIngressoInput
    connect?: PagamentoWhereUniqueInput
  }

  export type SessaoAssentoUncheckedCreateNestedManyWithoutIngressoInput = {
    create?: XOR<SessaoAssentoCreateWithoutIngressoInput, SessaoAssentoUncheckedCreateWithoutIngressoInput> | SessaoAssentoCreateWithoutIngressoInput[] | SessaoAssentoUncheckedCreateWithoutIngressoInput[]
    connectOrCreate?: SessaoAssentoCreateOrConnectWithoutIngressoInput | SessaoAssentoCreateOrConnectWithoutIngressoInput[]
    createMany?: SessaoAssentoCreateManyIngressoInputEnvelope
    connect?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
  }

  export type PagamentoUncheckedCreateNestedOneWithoutIngressoInput = {
    create?: XOR<PagamentoCreateWithoutIngressoInput, PagamentoUncheckedCreateWithoutIngressoInput>
    connectOrCreate?: PagamentoCreateOrConnectWithoutIngressoInput
    connect?: PagamentoWhereUniqueInput
  }

  export type SessaoAssentoUpdateManyWithoutIngressoNestedInput = {
    create?: XOR<SessaoAssentoCreateWithoutIngressoInput, SessaoAssentoUncheckedCreateWithoutIngressoInput> | SessaoAssentoCreateWithoutIngressoInput[] | SessaoAssentoUncheckedCreateWithoutIngressoInput[]
    connectOrCreate?: SessaoAssentoCreateOrConnectWithoutIngressoInput | SessaoAssentoCreateOrConnectWithoutIngressoInput[]
    upsert?: SessaoAssentoUpsertWithWhereUniqueWithoutIngressoInput | SessaoAssentoUpsertWithWhereUniqueWithoutIngressoInput[]
    createMany?: SessaoAssentoCreateManyIngressoInputEnvelope
    set?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    disconnect?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    delete?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    connect?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    update?: SessaoAssentoUpdateWithWhereUniqueWithoutIngressoInput | SessaoAssentoUpdateWithWhereUniqueWithoutIngressoInput[]
    updateMany?: SessaoAssentoUpdateManyWithWhereWithoutIngressoInput | SessaoAssentoUpdateManyWithWhereWithoutIngressoInput[]
    deleteMany?: SessaoAssentoScalarWhereInput | SessaoAssentoScalarWhereInput[]
  }

  export type PagamentoUpdateOneWithoutIngressoNestedInput = {
    create?: XOR<PagamentoCreateWithoutIngressoInput, PagamentoUncheckedCreateWithoutIngressoInput>
    connectOrCreate?: PagamentoCreateOrConnectWithoutIngressoInput
    upsert?: PagamentoUpsertWithoutIngressoInput
    disconnect?: PagamentoWhereInput | boolean
    delete?: PagamentoWhereInput | boolean
    connect?: PagamentoWhereUniqueInput
    update?: XOR<XOR<PagamentoUpdateToOneWithWhereWithoutIngressoInput, PagamentoUpdateWithoutIngressoInput>, PagamentoUncheckedUpdateWithoutIngressoInput>
  }

  export type SessaoAssentoUncheckedUpdateManyWithoutIngressoNestedInput = {
    create?: XOR<SessaoAssentoCreateWithoutIngressoInput, SessaoAssentoUncheckedCreateWithoutIngressoInput> | SessaoAssentoCreateWithoutIngressoInput[] | SessaoAssentoUncheckedCreateWithoutIngressoInput[]
    connectOrCreate?: SessaoAssentoCreateOrConnectWithoutIngressoInput | SessaoAssentoCreateOrConnectWithoutIngressoInput[]
    upsert?: SessaoAssentoUpsertWithWhereUniqueWithoutIngressoInput | SessaoAssentoUpsertWithWhereUniqueWithoutIngressoInput[]
    createMany?: SessaoAssentoCreateManyIngressoInputEnvelope
    set?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    disconnect?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    delete?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    connect?: SessaoAssentoWhereUniqueInput | SessaoAssentoWhereUniqueInput[]
    update?: SessaoAssentoUpdateWithWhereUniqueWithoutIngressoInput | SessaoAssentoUpdateWithWhereUniqueWithoutIngressoInput[]
    updateMany?: SessaoAssentoUpdateManyWithWhereWithoutIngressoInput | SessaoAssentoUpdateManyWithWhereWithoutIngressoInput[]
    deleteMany?: SessaoAssentoScalarWhereInput | SessaoAssentoScalarWhereInput[]
  }

  export type PagamentoUncheckedUpdateOneWithoutIngressoNestedInput = {
    create?: XOR<PagamentoCreateWithoutIngressoInput, PagamentoUncheckedCreateWithoutIngressoInput>
    connectOrCreate?: PagamentoCreateOrConnectWithoutIngressoInput
    upsert?: PagamentoUpsertWithoutIngressoInput
    disconnect?: PagamentoWhereInput | boolean
    delete?: PagamentoWhereInput | boolean
    connect?: PagamentoWhereUniqueInput
    update?: XOR<XOR<PagamentoUpdateToOneWithWhereWithoutIngressoInput, PagamentoUpdateWithoutIngressoInput>, PagamentoUncheckedUpdateWithoutIngressoInput>
  }

  export type PagamentoCreateNestedManyWithoutFormaPagamentoInput = {
    create?: XOR<PagamentoCreateWithoutFormaPagamentoInput, PagamentoUncheckedCreateWithoutFormaPagamentoInput> | PagamentoCreateWithoutFormaPagamentoInput[] | PagamentoUncheckedCreateWithoutFormaPagamentoInput[]
    connectOrCreate?: PagamentoCreateOrConnectWithoutFormaPagamentoInput | PagamentoCreateOrConnectWithoutFormaPagamentoInput[]
    createMany?: PagamentoCreateManyFormaPagamentoInputEnvelope
    connect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
  }

  export type PagamentoUncheckedCreateNestedManyWithoutFormaPagamentoInput = {
    create?: XOR<PagamentoCreateWithoutFormaPagamentoInput, PagamentoUncheckedCreateWithoutFormaPagamentoInput> | PagamentoCreateWithoutFormaPagamentoInput[] | PagamentoUncheckedCreateWithoutFormaPagamentoInput[]
    connectOrCreate?: PagamentoCreateOrConnectWithoutFormaPagamentoInput | PagamentoCreateOrConnectWithoutFormaPagamentoInput[]
    createMany?: PagamentoCreateManyFormaPagamentoInputEnvelope
    connect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
  }

  export type PagamentoUpdateManyWithoutFormaPagamentoNestedInput = {
    create?: XOR<PagamentoCreateWithoutFormaPagamentoInput, PagamentoUncheckedCreateWithoutFormaPagamentoInput> | PagamentoCreateWithoutFormaPagamentoInput[] | PagamentoUncheckedCreateWithoutFormaPagamentoInput[]
    connectOrCreate?: PagamentoCreateOrConnectWithoutFormaPagamentoInput | PagamentoCreateOrConnectWithoutFormaPagamentoInput[]
    upsert?: PagamentoUpsertWithWhereUniqueWithoutFormaPagamentoInput | PagamentoUpsertWithWhereUniqueWithoutFormaPagamentoInput[]
    createMany?: PagamentoCreateManyFormaPagamentoInputEnvelope
    set?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    disconnect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    delete?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    connect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    update?: PagamentoUpdateWithWhereUniqueWithoutFormaPagamentoInput | PagamentoUpdateWithWhereUniqueWithoutFormaPagamentoInput[]
    updateMany?: PagamentoUpdateManyWithWhereWithoutFormaPagamentoInput | PagamentoUpdateManyWithWhereWithoutFormaPagamentoInput[]
    deleteMany?: PagamentoScalarWhereInput | PagamentoScalarWhereInput[]
  }

  export type PagamentoUncheckedUpdateManyWithoutFormaPagamentoNestedInput = {
    create?: XOR<PagamentoCreateWithoutFormaPagamentoInput, PagamentoUncheckedCreateWithoutFormaPagamentoInput> | PagamentoCreateWithoutFormaPagamentoInput[] | PagamentoUncheckedCreateWithoutFormaPagamentoInput[]
    connectOrCreate?: PagamentoCreateOrConnectWithoutFormaPagamentoInput | PagamentoCreateOrConnectWithoutFormaPagamentoInput[]
    upsert?: PagamentoUpsertWithWhereUniqueWithoutFormaPagamentoInput | PagamentoUpsertWithWhereUniqueWithoutFormaPagamentoInput[]
    createMany?: PagamentoCreateManyFormaPagamentoInputEnvelope
    set?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    disconnect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    delete?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    connect?: PagamentoWhereUniqueInput | PagamentoWhereUniqueInput[]
    update?: PagamentoUpdateWithWhereUniqueWithoutFormaPagamentoInput | PagamentoUpdateWithWhereUniqueWithoutFormaPagamentoInput[]
    updateMany?: PagamentoUpdateManyWithWhereWithoutFormaPagamentoInput | PagamentoUpdateManyWithWhereWithoutFormaPagamentoInput[]
    deleteMany?: PagamentoScalarWhereInput | PagamentoScalarWhereInput[]
  }

  export type IngressoCreateNestedOneWithoutPagamentoInput = {
    create?: XOR<IngressoCreateWithoutPagamentoInput, IngressoUncheckedCreateWithoutPagamentoInput>
    connectOrCreate?: IngressoCreateOrConnectWithoutPagamentoInput
    connect?: IngressoWhereUniqueInput
  }

  export type FormaPagamentoCreateNestedOneWithoutPagamentosInput = {
    create?: XOR<FormaPagamentoCreateWithoutPagamentosInput, FormaPagamentoUncheckedCreateWithoutPagamentosInput>
    connectOrCreate?: FormaPagamentoCreateOrConnectWithoutPagamentosInput
    connect?: FormaPagamentoWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IngressoUpdateOneRequiredWithoutPagamentoNestedInput = {
    create?: XOR<IngressoCreateWithoutPagamentoInput, IngressoUncheckedCreateWithoutPagamentoInput>
    connectOrCreate?: IngressoCreateOrConnectWithoutPagamentoInput
    upsert?: IngressoUpsertWithoutPagamentoInput
    connect?: IngressoWhereUniqueInput
    update?: XOR<XOR<IngressoUpdateToOneWithWhereWithoutPagamentoInput, IngressoUpdateWithoutPagamentoInput>, IngressoUncheckedUpdateWithoutPagamentoInput>
  }

  export type FormaPagamentoUpdateOneRequiredWithoutPagamentosNestedInput = {
    create?: XOR<FormaPagamentoCreateWithoutPagamentosInput, FormaPagamentoUncheckedCreateWithoutPagamentosInput>
    connectOrCreate?: FormaPagamentoCreateOrConnectWithoutPagamentosInput
    upsert?: FormaPagamentoUpsertWithoutPagamentosInput
    connect?: FormaPagamentoWhereUniqueInput
    update?: XOR<XOR<FormaPagamentoUpdateToOneWithWhereWithoutPagamentosInput, FormaPagamentoUpdateWithoutPagamentosInput>, FormaPagamentoUncheckedUpdateWithoutPagamentosInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FilmeGeneroCreateWithoutGeneroInput = {
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    filme: FilmeCreateNestedOneWithoutGenerosInput
  }

  export type FilmeGeneroUncheckedCreateWithoutGeneroInput = {
    id?: number
    filmeId: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type FilmeGeneroCreateOrConnectWithoutGeneroInput = {
    where: FilmeGeneroWhereUniqueInput
    create: XOR<FilmeGeneroCreateWithoutGeneroInput, FilmeGeneroUncheckedCreateWithoutGeneroInput>
  }

  export type FilmeGeneroCreateManyGeneroInputEnvelope = {
    data: FilmeGeneroCreateManyGeneroInput | FilmeGeneroCreateManyGeneroInput[]
    skipDuplicates?: boolean
  }

  export type FilmeGeneroUpsertWithWhereUniqueWithoutGeneroInput = {
    where: FilmeGeneroWhereUniqueInput
    update: XOR<FilmeGeneroUpdateWithoutGeneroInput, FilmeGeneroUncheckedUpdateWithoutGeneroInput>
    create: XOR<FilmeGeneroCreateWithoutGeneroInput, FilmeGeneroUncheckedCreateWithoutGeneroInput>
  }

  export type FilmeGeneroUpdateWithWhereUniqueWithoutGeneroInput = {
    where: FilmeGeneroWhereUniqueInput
    data: XOR<FilmeGeneroUpdateWithoutGeneroInput, FilmeGeneroUncheckedUpdateWithoutGeneroInput>
  }

  export type FilmeGeneroUpdateManyWithWhereWithoutGeneroInput = {
    where: FilmeGeneroScalarWhereInput
    data: XOR<FilmeGeneroUpdateManyMutationInput, FilmeGeneroUncheckedUpdateManyWithoutGeneroInput>
  }

  export type FilmeGeneroScalarWhereInput = {
    AND?: FilmeGeneroScalarWhereInput | FilmeGeneroScalarWhereInput[]
    OR?: FilmeGeneroScalarWhereInput[]
    NOT?: FilmeGeneroScalarWhereInput | FilmeGeneroScalarWhereInput[]
    id?: IntFilter<"FilmeGenero"> | number
    filmeId?: IntFilter<"FilmeGenero"> | number
    generoId?: IntFilter<"FilmeGenero"> | number
    ativo?: BoolFilter<"FilmeGenero"> | boolean
    criadoEm?: DateTimeFilter<"FilmeGenero"> | Date | string
    atualizadoEm?: DateTimeFilter<"FilmeGenero"> | Date | string
  }

  export type FilmeCreateWithoutGenerosInput = {
    titulo: string
    descricao: string
    duracaoEmMinutos: number
    trailerUrl: string
    capaUrl: string
    dataLancamento: Date | string
    dataInicioCartaz: Date | string
    dataFimCartaz: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    classificacaoIndicativa: ClassificacaoIndicativaCreateNestedOneWithoutFilmesInput
    integrantes?: FilmeIntegranteCreateNestedManyWithoutFilmeInput
    sessoes?: SessaoCreateNestedManyWithoutFilmeInput
  }

  export type FilmeUncheckedCreateWithoutGenerosInput = {
    id?: number
    classificacaoIndicativaId: number
    titulo: string
    descricao: string
    duracaoEmMinutos: number
    trailerUrl: string
    capaUrl: string
    dataLancamento: Date | string
    dataInicioCartaz: Date | string
    dataFimCartaz: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    integrantes?: FilmeIntegranteUncheckedCreateNestedManyWithoutFilmeInput
    sessoes?: SessaoUncheckedCreateNestedManyWithoutFilmeInput
  }

  export type FilmeCreateOrConnectWithoutGenerosInput = {
    where: FilmeWhereUniqueInput
    create: XOR<FilmeCreateWithoutGenerosInput, FilmeUncheckedCreateWithoutGenerosInput>
  }

  export type GeneroCreateWithoutFilmesInput = {
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type GeneroUncheckedCreateWithoutFilmesInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type GeneroCreateOrConnectWithoutFilmesInput = {
    where: GeneroWhereUniqueInput
    create: XOR<GeneroCreateWithoutFilmesInput, GeneroUncheckedCreateWithoutFilmesInput>
  }

  export type FilmeUpsertWithoutGenerosInput = {
    update: XOR<FilmeUpdateWithoutGenerosInput, FilmeUncheckedUpdateWithoutGenerosInput>
    create: XOR<FilmeCreateWithoutGenerosInput, FilmeUncheckedCreateWithoutGenerosInput>
    where?: FilmeWhereInput
  }

  export type FilmeUpdateToOneWithWhereWithoutGenerosInput = {
    where?: FilmeWhereInput
    data: XOR<FilmeUpdateWithoutGenerosInput, FilmeUncheckedUpdateWithoutGenerosInput>
  }

  export type FilmeUpdateWithoutGenerosInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    duracaoEmMinutos?: IntFieldUpdateOperationsInput | number
    trailerUrl?: StringFieldUpdateOperationsInput | string
    capaUrl?: StringFieldUpdateOperationsInput | string
    dataLancamento?: DateTimeFieldUpdateOperationsInput | Date | string
    dataInicioCartaz?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFimCartaz?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    classificacaoIndicativa?: ClassificacaoIndicativaUpdateOneRequiredWithoutFilmesNestedInput
    integrantes?: FilmeIntegranteUpdateManyWithoutFilmeNestedInput
    sessoes?: SessaoUpdateManyWithoutFilmeNestedInput
  }

  export type FilmeUncheckedUpdateWithoutGenerosInput = {
    id?: IntFieldUpdateOperationsInput | number
    classificacaoIndicativaId?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    duracaoEmMinutos?: IntFieldUpdateOperationsInput | number
    trailerUrl?: StringFieldUpdateOperationsInput | string
    capaUrl?: StringFieldUpdateOperationsInput | string
    dataLancamento?: DateTimeFieldUpdateOperationsInput | Date | string
    dataInicioCartaz?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFimCartaz?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    integrantes?: FilmeIntegranteUncheckedUpdateManyWithoutFilmeNestedInput
    sessoes?: SessaoUncheckedUpdateManyWithoutFilmeNestedInput
  }

  export type GeneroUpsertWithoutFilmesInput = {
    update: XOR<GeneroUpdateWithoutFilmesInput, GeneroUncheckedUpdateWithoutFilmesInput>
    create: XOR<GeneroCreateWithoutFilmesInput, GeneroUncheckedCreateWithoutFilmesInput>
    where?: GeneroWhereInput
  }

  export type GeneroUpdateToOneWithWhereWithoutFilmesInput = {
    where?: GeneroWhereInput
    data: XOR<GeneroUpdateWithoutFilmesInput, GeneroUncheckedUpdateWithoutFilmesInput>
  }

  export type GeneroUpdateWithoutFilmesInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GeneroUncheckedUpdateWithoutFilmesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassificacaoIndicativaCreateWithoutFilmesInput = {
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type ClassificacaoIndicativaUncheckedCreateWithoutFilmesInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type ClassificacaoIndicativaCreateOrConnectWithoutFilmesInput = {
    where: ClassificacaoIndicativaWhereUniqueInput
    create: XOR<ClassificacaoIndicativaCreateWithoutFilmesInput, ClassificacaoIndicativaUncheckedCreateWithoutFilmesInput>
  }

  export type FilmeGeneroCreateWithoutFilmeInput = {
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    genero: GeneroCreateNestedOneWithoutFilmesInput
  }

  export type FilmeGeneroUncheckedCreateWithoutFilmeInput = {
    id?: number
    generoId: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type FilmeGeneroCreateOrConnectWithoutFilmeInput = {
    where: FilmeGeneroWhereUniqueInput
    create: XOR<FilmeGeneroCreateWithoutFilmeInput, FilmeGeneroUncheckedCreateWithoutFilmeInput>
  }

  export type FilmeGeneroCreateManyFilmeInputEnvelope = {
    data: FilmeGeneroCreateManyFilmeInput | FilmeGeneroCreateManyFilmeInput[]
    skipDuplicates?: boolean
  }

  export type FilmeIntegranteCreateWithoutFilmeInput = {
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    integrante: IntegranteCreateNestedOneWithoutFilmesInput
  }

  export type FilmeIntegranteUncheckedCreateWithoutFilmeInput = {
    id?: number
    integranteId: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type FilmeIntegranteCreateOrConnectWithoutFilmeInput = {
    where: FilmeIntegranteWhereUniqueInput
    create: XOR<FilmeIntegranteCreateWithoutFilmeInput, FilmeIntegranteUncheckedCreateWithoutFilmeInput>
  }

  export type FilmeIntegranteCreateManyFilmeInputEnvelope = {
    data: FilmeIntegranteCreateManyFilmeInput | FilmeIntegranteCreateManyFilmeInput[]
    skipDuplicates?: boolean
  }

  export type SessaoCreateWithoutFilmeInput = {
    inicio: Date | string
    fim: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sala: SalaCreateNestedOneWithoutSessoesInput
    tipoSessao: TipoSessaoCreateNestedOneWithoutSessoesInput
    tipoIdioma: TipoIdiomaCreateNestedOneWithoutSessoesInput
    sessoesAssentos?: SessaoAssentoCreateNestedManyWithoutSessaoInput
  }

  export type SessaoUncheckedCreateWithoutFilmeInput = {
    id?: number
    salaId: number
    tipoSessaoId: number
    tipoIdiomaId: number
    inicio: Date | string
    fim: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessoesAssentos?: SessaoAssentoUncheckedCreateNestedManyWithoutSessaoInput
  }

  export type SessaoCreateOrConnectWithoutFilmeInput = {
    where: SessaoWhereUniqueInput
    create: XOR<SessaoCreateWithoutFilmeInput, SessaoUncheckedCreateWithoutFilmeInput>
  }

  export type SessaoCreateManyFilmeInputEnvelope = {
    data: SessaoCreateManyFilmeInput | SessaoCreateManyFilmeInput[]
    skipDuplicates?: boolean
  }

  export type ClassificacaoIndicativaUpsertWithoutFilmesInput = {
    update: XOR<ClassificacaoIndicativaUpdateWithoutFilmesInput, ClassificacaoIndicativaUncheckedUpdateWithoutFilmesInput>
    create: XOR<ClassificacaoIndicativaCreateWithoutFilmesInput, ClassificacaoIndicativaUncheckedCreateWithoutFilmesInput>
    where?: ClassificacaoIndicativaWhereInput
  }

  export type ClassificacaoIndicativaUpdateToOneWithWhereWithoutFilmesInput = {
    where?: ClassificacaoIndicativaWhereInput
    data: XOR<ClassificacaoIndicativaUpdateWithoutFilmesInput, ClassificacaoIndicativaUncheckedUpdateWithoutFilmesInput>
  }

  export type ClassificacaoIndicativaUpdateWithoutFilmesInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassificacaoIndicativaUncheckedUpdateWithoutFilmesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilmeGeneroUpsertWithWhereUniqueWithoutFilmeInput = {
    where: FilmeGeneroWhereUniqueInput
    update: XOR<FilmeGeneroUpdateWithoutFilmeInput, FilmeGeneroUncheckedUpdateWithoutFilmeInput>
    create: XOR<FilmeGeneroCreateWithoutFilmeInput, FilmeGeneroUncheckedCreateWithoutFilmeInput>
  }

  export type FilmeGeneroUpdateWithWhereUniqueWithoutFilmeInput = {
    where: FilmeGeneroWhereUniqueInput
    data: XOR<FilmeGeneroUpdateWithoutFilmeInput, FilmeGeneroUncheckedUpdateWithoutFilmeInput>
  }

  export type FilmeGeneroUpdateManyWithWhereWithoutFilmeInput = {
    where: FilmeGeneroScalarWhereInput
    data: XOR<FilmeGeneroUpdateManyMutationInput, FilmeGeneroUncheckedUpdateManyWithoutFilmeInput>
  }

  export type FilmeIntegranteUpsertWithWhereUniqueWithoutFilmeInput = {
    where: FilmeIntegranteWhereUniqueInput
    update: XOR<FilmeIntegranteUpdateWithoutFilmeInput, FilmeIntegranteUncheckedUpdateWithoutFilmeInput>
    create: XOR<FilmeIntegranteCreateWithoutFilmeInput, FilmeIntegranteUncheckedCreateWithoutFilmeInput>
  }

  export type FilmeIntegranteUpdateWithWhereUniqueWithoutFilmeInput = {
    where: FilmeIntegranteWhereUniqueInput
    data: XOR<FilmeIntegranteUpdateWithoutFilmeInput, FilmeIntegranteUncheckedUpdateWithoutFilmeInput>
  }

  export type FilmeIntegranteUpdateManyWithWhereWithoutFilmeInput = {
    where: FilmeIntegranteScalarWhereInput
    data: XOR<FilmeIntegranteUpdateManyMutationInput, FilmeIntegranteUncheckedUpdateManyWithoutFilmeInput>
  }

  export type FilmeIntegranteScalarWhereInput = {
    AND?: FilmeIntegranteScalarWhereInput | FilmeIntegranteScalarWhereInput[]
    OR?: FilmeIntegranteScalarWhereInput[]
    NOT?: FilmeIntegranteScalarWhereInput | FilmeIntegranteScalarWhereInput[]
    id?: IntFilter<"FilmeIntegrante"> | number
    filmeId?: IntFilter<"FilmeIntegrante"> | number
    integranteId?: IntFilter<"FilmeIntegrante"> | number
    ativo?: BoolFilter<"FilmeIntegrante"> | boolean
    criadoEm?: DateTimeFilter<"FilmeIntegrante"> | Date | string
    atualizadoEm?: DateTimeFilter<"FilmeIntegrante"> | Date | string
  }

  export type SessaoUpsertWithWhereUniqueWithoutFilmeInput = {
    where: SessaoWhereUniqueInput
    update: XOR<SessaoUpdateWithoutFilmeInput, SessaoUncheckedUpdateWithoutFilmeInput>
    create: XOR<SessaoCreateWithoutFilmeInput, SessaoUncheckedCreateWithoutFilmeInput>
  }

  export type SessaoUpdateWithWhereUniqueWithoutFilmeInput = {
    where: SessaoWhereUniqueInput
    data: XOR<SessaoUpdateWithoutFilmeInput, SessaoUncheckedUpdateWithoutFilmeInput>
  }

  export type SessaoUpdateManyWithWhereWithoutFilmeInput = {
    where: SessaoScalarWhereInput
    data: XOR<SessaoUpdateManyMutationInput, SessaoUncheckedUpdateManyWithoutFilmeInput>
  }

  export type SessaoScalarWhereInput = {
    AND?: SessaoScalarWhereInput | SessaoScalarWhereInput[]
    OR?: SessaoScalarWhereInput[]
    NOT?: SessaoScalarWhereInput | SessaoScalarWhereInput[]
    id?: IntFilter<"Sessao"> | number
    filmeId?: IntFilter<"Sessao"> | number
    salaId?: IntFilter<"Sessao"> | number
    tipoSessaoId?: IntFilter<"Sessao"> | number
    tipoIdiomaId?: IntFilter<"Sessao"> | number
    inicio?: DateTimeFilter<"Sessao"> | Date | string
    fim?: DateTimeFilter<"Sessao"> | Date | string
    ativo?: BoolFilter<"Sessao"> | boolean
    criadoEm?: DateTimeFilter<"Sessao"> | Date | string
    atualizadoEm?: DateTimeFilter<"Sessao"> | Date | string
  }

  export type FilmeCreateWithoutIntegrantesInput = {
    titulo: string
    descricao: string
    duracaoEmMinutos: number
    trailerUrl: string
    capaUrl: string
    dataLancamento: Date | string
    dataInicioCartaz: Date | string
    dataFimCartaz: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    classificacaoIndicativa: ClassificacaoIndicativaCreateNestedOneWithoutFilmesInput
    generos?: FilmeGeneroCreateNestedManyWithoutFilmeInput
    sessoes?: SessaoCreateNestedManyWithoutFilmeInput
  }

  export type FilmeUncheckedCreateWithoutIntegrantesInput = {
    id?: number
    classificacaoIndicativaId: number
    titulo: string
    descricao: string
    duracaoEmMinutos: number
    trailerUrl: string
    capaUrl: string
    dataLancamento: Date | string
    dataInicioCartaz: Date | string
    dataFimCartaz: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    generos?: FilmeGeneroUncheckedCreateNestedManyWithoutFilmeInput
    sessoes?: SessaoUncheckedCreateNestedManyWithoutFilmeInput
  }

  export type FilmeCreateOrConnectWithoutIntegrantesInput = {
    where: FilmeWhereUniqueInput
    create: XOR<FilmeCreateWithoutIntegrantesInput, FilmeUncheckedCreateWithoutIntegrantesInput>
  }

  export type IntegranteCreateWithoutFilmesInput = {
    nome: string
    sobrenome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    tipoIntegrante: TipoIntegranteCreateNestedOneWithoutIntegrantesInput
  }

  export type IntegranteUncheckedCreateWithoutFilmesInput = {
    id?: number
    tipoIntegranteId: number
    nome: string
    sobrenome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type IntegranteCreateOrConnectWithoutFilmesInput = {
    where: IntegranteWhereUniqueInput
    create: XOR<IntegranteCreateWithoutFilmesInput, IntegranteUncheckedCreateWithoutFilmesInput>
  }

  export type FilmeUpsertWithoutIntegrantesInput = {
    update: XOR<FilmeUpdateWithoutIntegrantesInput, FilmeUncheckedUpdateWithoutIntegrantesInput>
    create: XOR<FilmeCreateWithoutIntegrantesInput, FilmeUncheckedCreateWithoutIntegrantesInput>
    where?: FilmeWhereInput
  }

  export type FilmeUpdateToOneWithWhereWithoutIntegrantesInput = {
    where?: FilmeWhereInput
    data: XOR<FilmeUpdateWithoutIntegrantesInput, FilmeUncheckedUpdateWithoutIntegrantesInput>
  }

  export type FilmeUpdateWithoutIntegrantesInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    duracaoEmMinutos?: IntFieldUpdateOperationsInput | number
    trailerUrl?: StringFieldUpdateOperationsInput | string
    capaUrl?: StringFieldUpdateOperationsInput | string
    dataLancamento?: DateTimeFieldUpdateOperationsInput | Date | string
    dataInicioCartaz?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFimCartaz?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    classificacaoIndicativa?: ClassificacaoIndicativaUpdateOneRequiredWithoutFilmesNestedInput
    generos?: FilmeGeneroUpdateManyWithoutFilmeNestedInput
    sessoes?: SessaoUpdateManyWithoutFilmeNestedInput
  }

  export type FilmeUncheckedUpdateWithoutIntegrantesInput = {
    id?: IntFieldUpdateOperationsInput | number
    classificacaoIndicativaId?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    duracaoEmMinutos?: IntFieldUpdateOperationsInput | number
    trailerUrl?: StringFieldUpdateOperationsInput | string
    capaUrl?: StringFieldUpdateOperationsInput | string
    dataLancamento?: DateTimeFieldUpdateOperationsInput | Date | string
    dataInicioCartaz?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFimCartaz?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    generos?: FilmeGeneroUncheckedUpdateManyWithoutFilmeNestedInput
    sessoes?: SessaoUncheckedUpdateManyWithoutFilmeNestedInput
  }

  export type IntegranteUpsertWithoutFilmesInput = {
    update: XOR<IntegranteUpdateWithoutFilmesInput, IntegranteUncheckedUpdateWithoutFilmesInput>
    create: XOR<IntegranteCreateWithoutFilmesInput, IntegranteUncheckedCreateWithoutFilmesInput>
    where?: IntegranteWhereInput
  }

  export type IntegranteUpdateToOneWithWhereWithoutFilmesInput = {
    where?: IntegranteWhereInput
    data: XOR<IntegranteUpdateWithoutFilmesInput, IntegranteUncheckedUpdateWithoutFilmesInput>
  }

  export type IntegranteUpdateWithoutFilmesInput = {
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tipoIntegrante?: TipoIntegranteUpdateOneRequiredWithoutIntegrantesNestedInput
  }

  export type IntegranteUncheckedUpdateWithoutFilmesInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoIntegranteId?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoIntegranteCreateWithoutIntegrantesInput = {
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type TipoIntegranteUncheckedCreateWithoutIntegrantesInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type TipoIntegranteCreateOrConnectWithoutIntegrantesInput = {
    where: TipoIntegranteWhereUniqueInput
    create: XOR<TipoIntegranteCreateWithoutIntegrantesInput, TipoIntegranteUncheckedCreateWithoutIntegrantesInput>
  }

  export type FilmeIntegranteCreateWithoutIntegranteInput = {
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    filme: FilmeCreateNestedOneWithoutIntegrantesInput
  }

  export type FilmeIntegranteUncheckedCreateWithoutIntegranteInput = {
    id?: number
    filmeId: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type FilmeIntegranteCreateOrConnectWithoutIntegranteInput = {
    where: FilmeIntegranteWhereUniqueInput
    create: XOR<FilmeIntegranteCreateWithoutIntegranteInput, FilmeIntegranteUncheckedCreateWithoutIntegranteInput>
  }

  export type FilmeIntegranteCreateManyIntegranteInputEnvelope = {
    data: FilmeIntegranteCreateManyIntegranteInput | FilmeIntegranteCreateManyIntegranteInput[]
    skipDuplicates?: boolean
  }

  export type TipoIntegranteUpsertWithoutIntegrantesInput = {
    update: XOR<TipoIntegranteUpdateWithoutIntegrantesInput, TipoIntegranteUncheckedUpdateWithoutIntegrantesInput>
    create: XOR<TipoIntegranteCreateWithoutIntegrantesInput, TipoIntegranteUncheckedCreateWithoutIntegrantesInput>
    where?: TipoIntegranteWhereInput
  }

  export type TipoIntegranteUpdateToOneWithWhereWithoutIntegrantesInput = {
    where?: TipoIntegranteWhereInput
    data: XOR<TipoIntegranteUpdateWithoutIntegrantesInput, TipoIntegranteUncheckedUpdateWithoutIntegrantesInput>
  }

  export type TipoIntegranteUpdateWithoutIntegrantesInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoIntegranteUncheckedUpdateWithoutIntegrantesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilmeIntegranteUpsertWithWhereUniqueWithoutIntegranteInput = {
    where: FilmeIntegranteWhereUniqueInput
    update: XOR<FilmeIntegranteUpdateWithoutIntegranteInput, FilmeIntegranteUncheckedUpdateWithoutIntegranteInput>
    create: XOR<FilmeIntegranteCreateWithoutIntegranteInput, FilmeIntegranteUncheckedCreateWithoutIntegranteInput>
  }

  export type FilmeIntegranteUpdateWithWhereUniqueWithoutIntegranteInput = {
    where: FilmeIntegranteWhereUniqueInput
    data: XOR<FilmeIntegranteUpdateWithoutIntegranteInput, FilmeIntegranteUncheckedUpdateWithoutIntegranteInput>
  }

  export type FilmeIntegranteUpdateManyWithWhereWithoutIntegranteInput = {
    where: FilmeIntegranteScalarWhereInput
    data: XOR<FilmeIntegranteUpdateManyMutationInput, FilmeIntegranteUncheckedUpdateManyWithoutIntegranteInput>
  }

  export type IntegranteCreateWithoutTipoIntegranteInput = {
    nome: string
    sobrenome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    filmes?: FilmeIntegranteCreateNestedManyWithoutIntegranteInput
  }

  export type IntegranteUncheckedCreateWithoutTipoIntegranteInput = {
    id?: number
    nome: string
    sobrenome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    filmes?: FilmeIntegranteUncheckedCreateNestedManyWithoutIntegranteInput
  }

  export type IntegranteCreateOrConnectWithoutTipoIntegranteInput = {
    where: IntegranteWhereUniqueInput
    create: XOR<IntegranteCreateWithoutTipoIntegranteInput, IntegranteUncheckedCreateWithoutTipoIntegranteInput>
  }

  export type IntegranteCreateManyTipoIntegranteInputEnvelope = {
    data: IntegranteCreateManyTipoIntegranteInput | IntegranteCreateManyTipoIntegranteInput[]
    skipDuplicates?: boolean
  }

  export type IntegranteUpsertWithWhereUniqueWithoutTipoIntegranteInput = {
    where: IntegranteWhereUniqueInput
    update: XOR<IntegranteUpdateWithoutTipoIntegranteInput, IntegranteUncheckedUpdateWithoutTipoIntegranteInput>
    create: XOR<IntegranteCreateWithoutTipoIntegranteInput, IntegranteUncheckedCreateWithoutTipoIntegranteInput>
  }

  export type IntegranteUpdateWithWhereUniqueWithoutTipoIntegranteInput = {
    where: IntegranteWhereUniqueInput
    data: XOR<IntegranteUpdateWithoutTipoIntegranteInput, IntegranteUncheckedUpdateWithoutTipoIntegranteInput>
  }

  export type IntegranteUpdateManyWithWhereWithoutTipoIntegranteInput = {
    where: IntegranteScalarWhereInput
    data: XOR<IntegranteUpdateManyMutationInput, IntegranteUncheckedUpdateManyWithoutTipoIntegranteInput>
  }

  export type IntegranteScalarWhereInput = {
    AND?: IntegranteScalarWhereInput | IntegranteScalarWhereInput[]
    OR?: IntegranteScalarWhereInput[]
    NOT?: IntegranteScalarWhereInput | IntegranteScalarWhereInput[]
    id?: IntFilter<"Integrante"> | number
    tipoIntegranteId?: IntFilter<"Integrante"> | number
    nome?: StringFilter<"Integrante"> | string
    sobrenome?: StringFilter<"Integrante"> | string
    ativo?: BoolFilter<"Integrante"> | boolean
    criadoEm?: DateTimeFilter<"Integrante"> | Date | string
    atualizadoEm?: DateTimeFilter<"Integrante"> | Date | string
  }

  export type FilmeCreateWithoutClassificacaoIndicativaInput = {
    titulo: string
    descricao: string
    duracaoEmMinutos: number
    trailerUrl: string
    capaUrl: string
    dataLancamento: Date | string
    dataInicioCartaz: Date | string
    dataFimCartaz: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    generos?: FilmeGeneroCreateNestedManyWithoutFilmeInput
    integrantes?: FilmeIntegranteCreateNestedManyWithoutFilmeInput
    sessoes?: SessaoCreateNestedManyWithoutFilmeInput
  }

  export type FilmeUncheckedCreateWithoutClassificacaoIndicativaInput = {
    id?: number
    titulo: string
    descricao: string
    duracaoEmMinutos: number
    trailerUrl: string
    capaUrl: string
    dataLancamento: Date | string
    dataInicioCartaz: Date | string
    dataFimCartaz: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    generos?: FilmeGeneroUncheckedCreateNestedManyWithoutFilmeInput
    integrantes?: FilmeIntegranteUncheckedCreateNestedManyWithoutFilmeInput
    sessoes?: SessaoUncheckedCreateNestedManyWithoutFilmeInput
  }

  export type FilmeCreateOrConnectWithoutClassificacaoIndicativaInput = {
    where: FilmeWhereUniqueInput
    create: XOR<FilmeCreateWithoutClassificacaoIndicativaInput, FilmeUncheckedCreateWithoutClassificacaoIndicativaInput>
  }

  export type FilmeCreateManyClassificacaoIndicativaInputEnvelope = {
    data: FilmeCreateManyClassificacaoIndicativaInput | FilmeCreateManyClassificacaoIndicativaInput[]
    skipDuplicates?: boolean
  }

  export type FilmeUpsertWithWhereUniqueWithoutClassificacaoIndicativaInput = {
    where: FilmeWhereUniqueInput
    update: XOR<FilmeUpdateWithoutClassificacaoIndicativaInput, FilmeUncheckedUpdateWithoutClassificacaoIndicativaInput>
    create: XOR<FilmeCreateWithoutClassificacaoIndicativaInput, FilmeUncheckedCreateWithoutClassificacaoIndicativaInput>
  }

  export type FilmeUpdateWithWhereUniqueWithoutClassificacaoIndicativaInput = {
    where: FilmeWhereUniqueInput
    data: XOR<FilmeUpdateWithoutClassificacaoIndicativaInput, FilmeUncheckedUpdateWithoutClassificacaoIndicativaInput>
  }

  export type FilmeUpdateManyWithWhereWithoutClassificacaoIndicativaInput = {
    where: FilmeScalarWhereInput
    data: XOR<FilmeUpdateManyMutationInput, FilmeUncheckedUpdateManyWithoutClassificacaoIndicativaInput>
  }

  export type FilmeScalarWhereInput = {
    AND?: FilmeScalarWhereInput | FilmeScalarWhereInput[]
    OR?: FilmeScalarWhereInput[]
    NOT?: FilmeScalarWhereInput | FilmeScalarWhereInput[]
    id?: IntFilter<"Filme"> | number
    classificacaoIndicativaId?: IntFilter<"Filme"> | number
    titulo?: StringFilter<"Filme"> | string
    descricao?: StringFilter<"Filme"> | string
    duracaoEmMinutos?: IntFilter<"Filme"> | number
    trailerUrl?: StringFilter<"Filme"> | string
    capaUrl?: StringFilter<"Filme"> | string
    dataLancamento?: DateTimeFilter<"Filme"> | Date | string
    dataInicioCartaz?: DateTimeFilter<"Filme"> | Date | string
    dataFimCartaz?: DateTimeFilter<"Filme"> | Date | string
    ativo?: BoolFilter<"Filme"> | boolean
    criadoEm?: DateTimeFilter<"Filme"> | Date | string
    atualizadoEm?: DateTimeFilter<"Filme"> | Date | string
  }

  export type SessaoCreateWithoutTipoIdiomaInput = {
    inicio: Date | string
    fim: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    filme: FilmeCreateNestedOneWithoutSessoesInput
    sala: SalaCreateNestedOneWithoutSessoesInput
    tipoSessao: TipoSessaoCreateNestedOneWithoutSessoesInput
    sessoesAssentos?: SessaoAssentoCreateNestedManyWithoutSessaoInput
  }

  export type SessaoUncheckedCreateWithoutTipoIdiomaInput = {
    id?: number
    filmeId: number
    salaId: number
    tipoSessaoId: number
    inicio: Date | string
    fim: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessoesAssentos?: SessaoAssentoUncheckedCreateNestedManyWithoutSessaoInput
  }

  export type SessaoCreateOrConnectWithoutTipoIdiomaInput = {
    where: SessaoWhereUniqueInput
    create: XOR<SessaoCreateWithoutTipoIdiomaInput, SessaoUncheckedCreateWithoutTipoIdiomaInput>
  }

  export type SessaoCreateManyTipoIdiomaInputEnvelope = {
    data: SessaoCreateManyTipoIdiomaInput | SessaoCreateManyTipoIdiomaInput[]
    skipDuplicates?: boolean
  }

  export type SessaoUpsertWithWhereUniqueWithoutTipoIdiomaInput = {
    where: SessaoWhereUniqueInput
    update: XOR<SessaoUpdateWithoutTipoIdiomaInput, SessaoUncheckedUpdateWithoutTipoIdiomaInput>
    create: XOR<SessaoCreateWithoutTipoIdiomaInput, SessaoUncheckedCreateWithoutTipoIdiomaInput>
  }

  export type SessaoUpdateWithWhereUniqueWithoutTipoIdiomaInput = {
    where: SessaoWhereUniqueInput
    data: XOR<SessaoUpdateWithoutTipoIdiomaInput, SessaoUncheckedUpdateWithoutTipoIdiomaInput>
  }

  export type SessaoUpdateManyWithWhereWithoutTipoIdiomaInput = {
    where: SessaoScalarWhereInput
    data: XOR<SessaoUpdateManyMutationInput, SessaoUncheckedUpdateManyWithoutTipoIdiomaInput>
  }

  export type SessaoCreateWithoutTipoSessaoInput = {
    inicio: Date | string
    fim: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    filme: FilmeCreateNestedOneWithoutSessoesInput
    sala: SalaCreateNestedOneWithoutSessoesInput
    tipoIdioma: TipoIdiomaCreateNestedOneWithoutSessoesInput
    sessoesAssentos?: SessaoAssentoCreateNestedManyWithoutSessaoInput
  }

  export type SessaoUncheckedCreateWithoutTipoSessaoInput = {
    id?: number
    filmeId: number
    salaId: number
    tipoIdiomaId: number
    inicio: Date | string
    fim: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessoesAssentos?: SessaoAssentoUncheckedCreateNestedManyWithoutSessaoInput
  }

  export type SessaoCreateOrConnectWithoutTipoSessaoInput = {
    where: SessaoWhereUniqueInput
    create: XOR<SessaoCreateWithoutTipoSessaoInput, SessaoUncheckedCreateWithoutTipoSessaoInput>
  }

  export type SessaoCreateManyTipoSessaoInputEnvelope = {
    data: SessaoCreateManyTipoSessaoInput | SessaoCreateManyTipoSessaoInput[]
    skipDuplicates?: boolean
  }

  export type SessaoUpsertWithWhereUniqueWithoutTipoSessaoInput = {
    where: SessaoWhereUniqueInput
    update: XOR<SessaoUpdateWithoutTipoSessaoInput, SessaoUncheckedUpdateWithoutTipoSessaoInput>
    create: XOR<SessaoCreateWithoutTipoSessaoInput, SessaoUncheckedCreateWithoutTipoSessaoInput>
  }

  export type SessaoUpdateWithWhereUniqueWithoutTipoSessaoInput = {
    where: SessaoWhereUniqueInput
    data: XOR<SessaoUpdateWithoutTipoSessaoInput, SessaoUncheckedUpdateWithoutTipoSessaoInput>
  }

  export type SessaoUpdateManyWithWhereWithoutTipoSessaoInput = {
    where: SessaoScalarWhereInput
    data: XOR<SessaoUpdateManyMutationInput, SessaoUncheckedUpdateManyWithoutTipoSessaoInput>
  }

  export type FilmeCreateWithoutSessoesInput = {
    titulo: string
    descricao: string
    duracaoEmMinutos: number
    trailerUrl: string
    capaUrl: string
    dataLancamento: Date | string
    dataInicioCartaz: Date | string
    dataFimCartaz: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    classificacaoIndicativa: ClassificacaoIndicativaCreateNestedOneWithoutFilmesInput
    generos?: FilmeGeneroCreateNestedManyWithoutFilmeInput
    integrantes?: FilmeIntegranteCreateNestedManyWithoutFilmeInput
  }

  export type FilmeUncheckedCreateWithoutSessoesInput = {
    id?: number
    classificacaoIndicativaId: number
    titulo: string
    descricao: string
    duracaoEmMinutos: number
    trailerUrl: string
    capaUrl: string
    dataLancamento: Date | string
    dataInicioCartaz: Date | string
    dataFimCartaz: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    generos?: FilmeGeneroUncheckedCreateNestedManyWithoutFilmeInput
    integrantes?: FilmeIntegranteUncheckedCreateNestedManyWithoutFilmeInput
  }

  export type FilmeCreateOrConnectWithoutSessoesInput = {
    where: FilmeWhereUniqueInput
    create: XOR<FilmeCreateWithoutSessoesInput, FilmeUncheckedCreateWithoutSessoesInput>
  }

  export type SalaCreateWithoutSessoesInput = {
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    tipoSala: TipoSalaCreateNestedOneWithoutSalasInput
    assentos?: AssentoCreateNestedManyWithoutSalaInput
  }

  export type SalaUncheckedCreateWithoutSessoesInput = {
    id?: number
    tipoSalaId: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    assentos?: AssentoUncheckedCreateNestedManyWithoutSalaInput
  }

  export type SalaCreateOrConnectWithoutSessoesInput = {
    where: SalaWhereUniqueInput
    create: XOR<SalaCreateWithoutSessoesInput, SalaUncheckedCreateWithoutSessoesInput>
  }

  export type TipoSessaoCreateWithoutSessoesInput = {
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type TipoSessaoUncheckedCreateWithoutSessoesInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type TipoSessaoCreateOrConnectWithoutSessoesInput = {
    where: TipoSessaoWhereUniqueInput
    create: XOR<TipoSessaoCreateWithoutSessoesInput, TipoSessaoUncheckedCreateWithoutSessoesInput>
  }

  export type TipoIdiomaCreateWithoutSessoesInput = {
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type TipoIdiomaUncheckedCreateWithoutSessoesInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type TipoIdiomaCreateOrConnectWithoutSessoesInput = {
    where: TipoIdiomaWhereUniqueInput
    create: XOR<TipoIdiomaCreateWithoutSessoesInput, TipoIdiomaUncheckedCreateWithoutSessoesInput>
  }

  export type SessaoAssentoCreateWithoutSessaoInput = {
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    assento: AssentoCreateNestedOneWithoutSessoesAssentosInput
    ingresso: IngressoCreateNestedOneWithoutSessoesAssentosInput
    sessaoAssentoStatus: SessaoAssentoStatusCreateNestedOneWithoutSessoesAssentosInput
    tipoEntrada: TipoEntradaCreateNestedOneWithoutSessoesAssentosInput
  }

  export type SessaoAssentoUncheckedCreateWithoutSessaoInput = {
    id?: number
    assentoId: number
    ingressoId: number
    sessaoAssentoStatusId: number
    tipoEntradaId: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type SessaoAssentoCreateOrConnectWithoutSessaoInput = {
    where: SessaoAssentoWhereUniqueInput
    create: XOR<SessaoAssentoCreateWithoutSessaoInput, SessaoAssentoUncheckedCreateWithoutSessaoInput>
  }

  export type SessaoAssentoCreateManySessaoInputEnvelope = {
    data: SessaoAssentoCreateManySessaoInput | SessaoAssentoCreateManySessaoInput[]
    skipDuplicates?: boolean
  }

  export type FilmeUpsertWithoutSessoesInput = {
    update: XOR<FilmeUpdateWithoutSessoesInput, FilmeUncheckedUpdateWithoutSessoesInput>
    create: XOR<FilmeCreateWithoutSessoesInput, FilmeUncheckedCreateWithoutSessoesInput>
    where?: FilmeWhereInput
  }

  export type FilmeUpdateToOneWithWhereWithoutSessoesInput = {
    where?: FilmeWhereInput
    data: XOR<FilmeUpdateWithoutSessoesInput, FilmeUncheckedUpdateWithoutSessoesInput>
  }

  export type FilmeUpdateWithoutSessoesInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    duracaoEmMinutos?: IntFieldUpdateOperationsInput | number
    trailerUrl?: StringFieldUpdateOperationsInput | string
    capaUrl?: StringFieldUpdateOperationsInput | string
    dataLancamento?: DateTimeFieldUpdateOperationsInput | Date | string
    dataInicioCartaz?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFimCartaz?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    classificacaoIndicativa?: ClassificacaoIndicativaUpdateOneRequiredWithoutFilmesNestedInput
    generos?: FilmeGeneroUpdateManyWithoutFilmeNestedInput
    integrantes?: FilmeIntegranteUpdateManyWithoutFilmeNestedInput
  }

  export type FilmeUncheckedUpdateWithoutSessoesInput = {
    id?: IntFieldUpdateOperationsInput | number
    classificacaoIndicativaId?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    duracaoEmMinutos?: IntFieldUpdateOperationsInput | number
    trailerUrl?: StringFieldUpdateOperationsInput | string
    capaUrl?: StringFieldUpdateOperationsInput | string
    dataLancamento?: DateTimeFieldUpdateOperationsInput | Date | string
    dataInicioCartaz?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFimCartaz?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    generos?: FilmeGeneroUncheckedUpdateManyWithoutFilmeNestedInput
    integrantes?: FilmeIntegranteUncheckedUpdateManyWithoutFilmeNestedInput
  }

  export type SalaUpsertWithoutSessoesInput = {
    update: XOR<SalaUpdateWithoutSessoesInput, SalaUncheckedUpdateWithoutSessoesInput>
    create: XOR<SalaCreateWithoutSessoesInput, SalaUncheckedCreateWithoutSessoesInput>
    where?: SalaWhereInput
  }

  export type SalaUpdateToOneWithWhereWithoutSessoesInput = {
    where?: SalaWhereInput
    data: XOR<SalaUpdateWithoutSessoesInput, SalaUncheckedUpdateWithoutSessoesInput>
  }

  export type SalaUpdateWithoutSessoesInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tipoSala?: TipoSalaUpdateOneRequiredWithoutSalasNestedInput
    assentos?: AssentoUpdateManyWithoutSalaNestedInput
  }

  export type SalaUncheckedUpdateWithoutSessoesInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoSalaId?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    assentos?: AssentoUncheckedUpdateManyWithoutSalaNestedInput
  }

  export type TipoSessaoUpsertWithoutSessoesInput = {
    update: XOR<TipoSessaoUpdateWithoutSessoesInput, TipoSessaoUncheckedUpdateWithoutSessoesInput>
    create: XOR<TipoSessaoCreateWithoutSessoesInput, TipoSessaoUncheckedCreateWithoutSessoesInput>
    where?: TipoSessaoWhereInput
  }

  export type TipoSessaoUpdateToOneWithWhereWithoutSessoesInput = {
    where?: TipoSessaoWhereInput
    data: XOR<TipoSessaoUpdateWithoutSessoesInput, TipoSessaoUncheckedUpdateWithoutSessoesInput>
  }

  export type TipoSessaoUpdateWithoutSessoesInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoSessaoUncheckedUpdateWithoutSessoesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoIdiomaUpsertWithoutSessoesInput = {
    update: XOR<TipoIdiomaUpdateWithoutSessoesInput, TipoIdiomaUncheckedUpdateWithoutSessoesInput>
    create: XOR<TipoIdiomaCreateWithoutSessoesInput, TipoIdiomaUncheckedCreateWithoutSessoesInput>
    where?: TipoIdiomaWhereInput
  }

  export type TipoIdiomaUpdateToOneWithWhereWithoutSessoesInput = {
    where?: TipoIdiomaWhereInput
    data: XOR<TipoIdiomaUpdateWithoutSessoesInput, TipoIdiomaUncheckedUpdateWithoutSessoesInput>
  }

  export type TipoIdiomaUpdateWithoutSessoesInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoIdiomaUncheckedUpdateWithoutSessoesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessaoAssentoUpsertWithWhereUniqueWithoutSessaoInput = {
    where: SessaoAssentoWhereUniqueInput
    update: XOR<SessaoAssentoUpdateWithoutSessaoInput, SessaoAssentoUncheckedUpdateWithoutSessaoInput>
    create: XOR<SessaoAssentoCreateWithoutSessaoInput, SessaoAssentoUncheckedCreateWithoutSessaoInput>
  }

  export type SessaoAssentoUpdateWithWhereUniqueWithoutSessaoInput = {
    where: SessaoAssentoWhereUniqueInput
    data: XOR<SessaoAssentoUpdateWithoutSessaoInput, SessaoAssentoUncheckedUpdateWithoutSessaoInput>
  }

  export type SessaoAssentoUpdateManyWithWhereWithoutSessaoInput = {
    where: SessaoAssentoScalarWhereInput
    data: XOR<SessaoAssentoUpdateManyMutationInput, SessaoAssentoUncheckedUpdateManyWithoutSessaoInput>
  }

  export type SessaoAssentoScalarWhereInput = {
    AND?: SessaoAssentoScalarWhereInput | SessaoAssentoScalarWhereInput[]
    OR?: SessaoAssentoScalarWhereInput[]
    NOT?: SessaoAssentoScalarWhereInput | SessaoAssentoScalarWhereInput[]
    id?: IntFilter<"SessaoAssento"> | number
    sessaoId?: IntFilter<"SessaoAssento"> | number
    assentoId?: IntFilter<"SessaoAssento"> | number
    ingressoId?: IntFilter<"SessaoAssento"> | number
    sessaoAssentoStatusId?: IntFilter<"SessaoAssento"> | number
    tipoEntradaId?: IntFilter<"SessaoAssento"> | number
    ativo?: BoolFilter<"SessaoAssento"> | boolean
    criadoEm?: DateTimeFilter<"SessaoAssento"> | Date | string
    atualizadoEm?: DateTimeFilter<"SessaoAssento"> | Date | string
  }

  export type SalaCreateWithoutTipoSalaInput = {
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessoes?: SessaoCreateNestedManyWithoutSalaInput
    assentos?: AssentoCreateNestedManyWithoutSalaInput
  }

  export type SalaUncheckedCreateWithoutTipoSalaInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessoes?: SessaoUncheckedCreateNestedManyWithoutSalaInput
    assentos?: AssentoUncheckedCreateNestedManyWithoutSalaInput
  }

  export type SalaCreateOrConnectWithoutTipoSalaInput = {
    where: SalaWhereUniqueInput
    create: XOR<SalaCreateWithoutTipoSalaInput, SalaUncheckedCreateWithoutTipoSalaInput>
  }

  export type SalaCreateManyTipoSalaInputEnvelope = {
    data: SalaCreateManyTipoSalaInput | SalaCreateManyTipoSalaInput[]
    skipDuplicates?: boolean
  }

  export type SalaUpsertWithWhereUniqueWithoutTipoSalaInput = {
    where: SalaWhereUniqueInput
    update: XOR<SalaUpdateWithoutTipoSalaInput, SalaUncheckedUpdateWithoutTipoSalaInput>
    create: XOR<SalaCreateWithoutTipoSalaInput, SalaUncheckedCreateWithoutTipoSalaInput>
  }

  export type SalaUpdateWithWhereUniqueWithoutTipoSalaInput = {
    where: SalaWhereUniqueInput
    data: XOR<SalaUpdateWithoutTipoSalaInput, SalaUncheckedUpdateWithoutTipoSalaInput>
  }

  export type SalaUpdateManyWithWhereWithoutTipoSalaInput = {
    where: SalaScalarWhereInput
    data: XOR<SalaUpdateManyMutationInput, SalaUncheckedUpdateManyWithoutTipoSalaInput>
  }

  export type SalaScalarWhereInput = {
    AND?: SalaScalarWhereInput | SalaScalarWhereInput[]
    OR?: SalaScalarWhereInput[]
    NOT?: SalaScalarWhereInput | SalaScalarWhereInput[]
    id?: IntFilter<"Sala"> | number
    tipoSalaId?: IntFilter<"Sala"> | number
    nome?: StringFilter<"Sala"> | string
    ativo?: BoolFilter<"Sala"> | boolean
    criadoEm?: DateTimeFilter<"Sala"> | Date | string
    atualizadoEm?: DateTimeFilter<"Sala"> | Date | string
  }

  export type TipoSalaCreateWithoutSalasInput = {
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type TipoSalaUncheckedCreateWithoutSalasInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type TipoSalaCreateOrConnectWithoutSalasInput = {
    where: TipoSalaWhereUniqueInput
    create: XOR<TipoSalaCreateWithoutSalasInput, TipoSalaUncheckedCreateWithoutSalasInput>
  }

  export type SessaoCreateWithoutSalaInput = {
    inicio: Date | string
    fim: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    filme: FilmeCreateNestedOneWithoutSessoesInput
    tipoSessao: TipoSessaoCreateNestedOneWithoutSessoesInput
    tipoIdioma: TipoIdiomaCreateNestedOneWithoutSessoesInput
    sessoesAssentos?: SessaoAssentoCreateNestedManyWithoutSessaoInput
  }

  export type SessaoUncheckedCreateWithoutSalaInput = {
    id?: number
    filmeId: number
    tipoSessaoId: number
    tipoIdiomaId: number
    inicio: Date | string
    fim: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessoesAssentos?: SessaoAssentoUncheckedCreateNestedManyWithoutSessaoInput
  }

  export type SessaoCreateOrConnectWithoutSalaInput = {
    where: SessaoWhereUniqueInput
    create: XOR<SessaoCreateWithoutSalaInput, SessaoUncheckedCreateWithoutSalaInput>
  }

  export type SessaoCreateManySalaInputEnvelope = {
    data: SessaoCreateManySalaInput | SessaoCreateManySalaInput[]
    skipDuplicates?: boolean
  }

  export type AssentoCreateWithoutSalaInput = {
    fileira: string
    coluna: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    tipoAssento: TipoAssentoCreateNestedOneWithoutAssentosInput
    sessoesAssentos?: SessaoAssentoCreateNestedManyWithoutAssentoInput
  }

  export type AssentoUncheckedCreateWithoutSalaInput = {
    id?: number
    tipoAssentoId: number
    fileira: string
    coluna: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessoesAssentos?: SessaoAssentoUncheckedCreateNestedManyWithoutAssentoInput
  }

  export type AssentoCreateOrConnectWithoutSalaInput = {
    where: AssentoWhereUniqueInput
    create: XOR<AssentoCreateWithoutSalaInput, AssentoUncheckedCreateWithoutSalaInput>
  }

  export type AssentoCreateManySalaInputEnvelope = {
    data: AssentoCreateManySalaInput | AssentoCreateManySalaInput[]
    skipDuplicates?: boolean
  }

  export type TipoSalaUpsertWithoutSalasInput = {
    update: XOR<TipoSalaUpdateWithoutSalasInput, TipoSalaUncheckedUpdateWithoutSalasInput>
    create: XOR<TipoSalaCreateWithoutSalasInput, TipoSalaUncheckedCreateWithoutSalasInput>
    where?: TipoSalaWhereInput
  }

  export type TipoSalaUpdateToOneWithWhereWithoutSalasInput = {
    where?: TipoSalaWhereInput
    data: XOR<TipoSalaUpdateWithoutSalasInput, TipoSalaUncheckedUpdateWithoutSalasInput>
  }

  export type TipoSalaUpdateWithoutSalasInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoSalaUncheckedUpdateWithoutSalasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessaoUpsertWithWhereUniqueWithoutSalaInput = {
    where: SessaoWhereUniqueInput
    update: XOR<SessaoUpdateWithoutSalaInput, SessaoUncheckedUpdateWithoutSalaInput>
    create: XOR<SessaoCreateWithoutSalaInput, SessaoUncheckedCreateWithoutSalaInput>
  }

  export type SessaoUpdateWithWhereUniqueWithoutSalaInput = {
    where: SessaoWhereUniqueInput
    data: XOR<SessaoUpdateWithoutSalaInput, SessaoUncheckedUpdateWithoutSalaInput>
  }

  export type SessaoUpdateManyWithWhereWithoutSalaInput = {
    where: SessaoScalarWhereInput
    data: XOR<SessaoUpdateManyMutationInput, SessaoUncheckedUpdateManyWithoutSalaInput>
  }

  export type AssentoUpsertWithWhereUniqueWithoutSalaInput = {
    where: AssentoWhereUniqueInput
    update: XOR<AssentoUpdateWithoutSalaInput, AssentoUncheckedUpdateWithoutSalaInput>
    create: XOR<AssentoCreateWithoutSalaInput, AssentoUncheckedCreateWithoutSalaInput>
  }

  export type AssentoUpdateWithWhereUniqueWithoutSalaInput = {
    where: AssentoWhereUniqueInput
    data: XOR<AssentoUpdateWithoutSalaInput, AssentoUncheckedUpdateWithoutSalaInput>
  }

  export type AssentoUpdateManyWithWhereWithoutSalaInput = {
    where: AssentoScalarWhereInput
    data: XOR<AssentoUpdateManyMutationInput, AssentoUncheckedUpdateManyWithoutSalaInput>
  }

  export type AssentoScalarWhereInput = {
    AND?: AssentoScalarWhereInput | AssentoScalarWhereInput[]
    OR?: AssentoScalarWhereInput[]
    NOT?: AssentoScalarWhereInput | AssentoScalarWhereInput[]
    id?: IntFilter<"Assento"> | number
    salaId?: IntFilter<"Assento"> | number
    tipoAssentoId?: IntFilter<"Assento"> | number
    fileira?: StringFilter<"Assento"> | string
    coluna?: IntFilter<"Assento"> | number
    ativo?: BoolFilter<"Assento"> | boolean
    criadoEm?: DateTimeFilter<"Assento"> | Date | string
    atualizadoEm?: DateTimeFilter<"Assento"> | Date | string
  }

  export type AssentoCreateWithoutTipoAssentoInput = {
    fileira: string
    coluna: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sala: SalaCreateNestedOneWithoutAssentosInput
    sessoesAssentos?: SessaoAssentoCreateNestedManyWithoutAssentoInput
  }

  export type AssentoUncheckedCreateWithoutTipoAssentoInput = {
    id?: number
    salaId: number
    fileira: string
    coluna: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessoesAssentos?: SessaoAssentoUncheckedCreateNestedManyWithoutAssentoInput
  }

  export type AssentoCreateOrConnectWithoutTipoAssentoInput = {
    where: AssentoWhereUniqueInput
    create: XOR<AssentoCreateWithoutTipoAssentoInput, AssentoUncheckedCreateWithoutTipoAssentoInput>
  }

  export type AssentoCreateManyTipoAssentoInputEnvelope = {
    data: AssentoCreateManyTipoAssentoInput | AssentoCreateManyTipoAssentoInput[]
    skipDuplicates?: boolean
  }

  export type AssentoUpsertWithWhereUniqueWithoutTipoAssentoInput = {
    where: AssentoWhereUniqueInput
    update: XOR<AssentoUpdateWithoutTipoAssentoInput, AssentoUncheckedUpdateWithoutTipoAssentoInput>
    create: XOR<AssentoCreateWithoutTipoAssentoInput, AssentoUncheckedCreateWithoutTipoAssentoInput>
  }

  export type AssentoUpdateWithWhereUniqueWithoutTipoAssentoInput = {
    where: AssentoWhereUniqueInput
    data: XOR<AssentoUpdateWithoutTipoAssentoInput, AssentoUncheckedUpdateWithoutTipoAssentoInput>
  }

  export type AssentoUpdateManyWithWhereWithoutTipoAssentoInput = {
    where: AssentoScalarWhereInput
    data: XOR<AssentoUpdateManyMutationInput, AssentoUncheckedUpdateManyWithoutTipoAssentoInput>
  }

  export type SalaCreateWithoutAssentosInput = {
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    tipoSala: TipoSalaCreateNestedOneWithoutSalasInput
    sessoes?: SessaoCreateNestedManyWithoutSalaInput
  }

  export type SalaUncheckedCreateWithoutAssentosInput = {
    id?: number
    tipoSalaId: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessoes?: SessaoUncheckedCreateNestedManyWithoutSalaInput
  }

  export type SalaCreateOrConnectWithoutAssentosInput = {
    where: SalaWhereUniqueInput
    create: XOR<SalaCreateWithoutAssentosInput, SalaUncheckedCreateWithoutAssentosInput>
  }

  export type TipoAssentoCreateWithoutAssentosInput = {
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type TipoAssentoUncheckedCreateWithoutAssentosInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type TipoAssentoCreateOrConnectWithoutAssentosInput = {
    where: TipoAssentoWhereUniqueInput
    create: XOR<TipoAssentoCreateWithoutAssentosInput, TipoAssentoUncheckedCreateWithoutAssentosInput>
  }

  export type SessaoAssentoCreateWithoutAssentoInput = {
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessao: SessaoCreateNestedOneWithoutSessoesAssentosInput
    ingresso: IngressoCreateNestedOneWithoutSessoesAssentosInput
    sessaoAssentoStatus: SessaoAssentoStatusCreateNestedOneWithoutSessoesAssentosInput
    tipoEntrada: TipoEntradaCreateNestedOneWithoutSessoesAssentosInput
  }

  export type SessaoAssentoUncheckedCreateWithoutAssentoInput = {
    id?: number
    sessaoId: number
    ingressoId: number
    sessaoAssentoStatusId: number
    tipoEntradaId: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type SessaoAssentoCreateOrConnectWithoutAssentoInput = {
    where: SessaoAssentoWhereUniqueInput
    create: XOR<SessaoAssentoCreateWithoutAssentoInput, SessaoAssentoUncheckedCreateWithoutAssentoInput>
  }

  export type SessaoAssentoCreateManyAssentoInputEnvelope = {
    data: SessaoAssentoCreateManyAssentoInput | SessaoAssentoCreateManyAssentoInput[]
    skipDuplicates?: boolean
  }

  export type SalaUpsertWithoutAssentosInput = {
    update: XOR<SalaUpdateWithoutAssentosInput, SalaUncheckedUpdateWithoutAssentosInput>
    create: XOR<SalaCreateWithoutAssentosInput, SalaUncheckedCreateWithoutAssentosInput>
    where?: SalaWhereInput
  }

  export type SalaUpdateToOneWithWhereWithoutAssentosInput = {
    where?: SalaWhereInput
    data: XOR<SalaUpdateWithoutAssentosInput, SalaUncheckedUpdateWithoutAssentosInput>
  }

  export type SalaUpdateWithoutAssentosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tipoSala?: TipoSalaUpdateOneRequiredWithoutSalasNestedInput
    sessoes?: SessaoUpdateManyWithoutSalaNestedInput
  }

  export type SalaUncheckedUpdateWithoutAssentosInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoSalaId?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessoes?: SessaoUncheckedUpdateManyWithoutSalaNestedInput
  }

  export type TipoAssentoUpsertWithoutAssentosInput = {
    update: XOR<TipoAssentoUpdateWithoutAssentosInput, TipoAssentoUncheckedUpdateWithoutAssentosInput>
    create: XOR<TipoAssentoCreateWithoutAssentosInput, TipoAssentoUncheckedCreateWithoutAssentosInput>
    where?: TipoAssentoWhereInput
  }

  export type TipoAssentoUpdateToOneWithWhereWithoutAssentosInput = {
    where?: TipoAssentoWhereInput
    data: XOR<TipoAssentoUpdateWithoutAssentosInput, TipoAssentoUncheckedUpdateWithoutAssentosInput>
  }

  export type TipoAssentoUpdateWithoutAssentosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoAssentoUncheckedUpdateWithoutAssentosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessaoAssentoUpsertWithWhereUniqueWithoutAssentoInput = {
    where: SessaoAssentoWhereUniqueInput
    update: XOR<SessaoAssentoUpdateWithoutAssentoInput, SessaoAssentoUncheckedUpdateWithoutAssentoInput>
    create: XOR<SessaoAssentoCreateWithoutAssentoInput, SessaoAssentoUncheckedCreateWithoutAssentoInput>
  }

  export type SessaoAssentoUpdateWithWhereUniqueWithoutAssentoInput = {
    where: SessaoAssentoWhereUniqueInput
    data: XOR<SessaoAssentoUpdateWithoutAssentoInput, SessaoAssentoUncheckedUpdateWithoutAssentoInput>
  }

  export type SessaoAssentoUpdateManyWithWhereWithoutAssentoInput = {
    where: SessaoAssentoScalarWhereInput
    data: XOR<SessaoAssentoUpdateManyMutationInput, SessaoAssentoUncheckedUpdateManyWithoutAssentoInput>
  }

  export type SessaoAssentoCreateWithoutSessaoAssentoStatusInput = {
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessao: SessaoCreateNestedOneWithoutSessoesAssentosInput
    assento: AssentoCreateNestedOneWithoutSessoesAssentosInput
    ingresso: IngressoCreateNestedOneWithoutSessoesAssentosInput
    tipoEntrada: TipoEntradaCreateNestedOneWithoutSessoesAssentosInput
  }

  export type SessaoAssentoUncheckedCreateWithoutSessaoAssentoStatusInput = {
    id?: number
    sessaoId: number
    assentoId: number
    ingressoId: number
    tipoEntradaId: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type SessaoAssentoCreateOrConnectWithoutSessaoAssentoStatusInput = {
    where: SessaoAssentoWhereUniqueInput
    create: XOR<SessaoAssentoCreateWithoutSessaoAssentoStatusInput, SessaoAssentoUncheckedCreateWithoutSessaoAssentoStatusInput>
  }

  export type SessaoAssentoCreateManySessaoAssentoStatusInputEnvelope = {
    data: SessaoAssentoCreateManySessaoAssentoStatusInput | SessaoAssentoCreateManySessaoAssentoStatusInput[]
    skipDuplicates?: boolean
  }

  export type SessaoAssentoUpsertWithWhereUniqueWithoutSessaoAssentoStatusInput = {
    where: SessaoAssentoWhereUniqueInput
    update: XOR<SessaoAssentoUpdateWithoutSessaoAssentoStatusInput, SessaoAssentoUncheckedUpdateWithoutSessaoAssentoStatusInput>
    create: XOR<SessaoAssentoCreateWithoutSessaoAssentoStatusInput, SessaoAssentoUncheckedCreateWithoutSessaoAssentoStatusInput>
  }

  export type SessaoAssentoUpdateWithWhereUniqueWithoutSessaoAssentoStatusInput = {
    where: SessaoAssentoWhereUniqueInput
    data: XOR<SessaoAssentoUpdateWithoutSessaoAssentoStatusInput, SessaoAssentoUncheckedUpdateWithoutSessaoAssentoStatusInput>
  }

  export type SessaoAssentoUpdateManyWithWhereWithoutSessaoAssentoStatusInput = {
    where: SessaoAssentoScalarWhereInput
    data: XOR<SessaoAssentoUpdateManyMutationInput, SessaoAssentoUncheckedUpdateManyWithoutSessaoAssentoStatusInput>
  }

  export type SessaoCreateWithoutSessoesAssentosInput = {
    inicio: Date | string
    fim: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    filme: FilmeCreateNestedOneWithoutSessoesInput
    sala: SalaCreateNestedOneWithoutSessoesInput
    tipoSessao: TipoSessaoCreateNestedOneWithoutSessoesInput
    tipoIdioma: TipoIdiomaCreateNestedOneWithoutSessoesInput
  }

  export type SessaoUncheckedCreateWithoutSessoesAssentosInput = {
    id?: number
    filmeId: number
    salaId: number
    tipoSessaoId: number
    tipoIdiomaId: number
    inicio: Date | string
    fim: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type SessaoCreateOrConnectWithoutSessoesAssentosInput = {
    where: SessaoWhereUniqueInput
    create: XOR<SessaoCreateWithoutSessoesAssentosInput, SessaoUncheckedCreateWithoutSessoesAssentosInput>
  }

  export type AssentoCreateWithoutSessoesAssentosInput = {
    fileira: string
    coluna: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sala: SalaCreateNestedOneWithoutAssentosInput
    tipoAssento: TipoAssentoCreateNestedOneWithoutAssentosInput
  }

  export type AssentoUncheckedCreateWithoutSessoesAssentosInput = {
    id?: number
    salaId: number
    tipoAssentoId: number
    fileira: string
    coluna: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type AssentoCreateOrConnectWithoutSessoesAssentosInput = {
    where: AssentoWhereUniqueInput
    create: XOR<AssentoCreateWithoutSessoesAssentosInput, AssentoUncheckedCreateWithoutSessoesAssentosInput>
  }

  export type IngressoCreateWithoutSessoesAssentosInput = {
    documentoResponsavel: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    pagamento?: PagamentoCreateNestedOneWithoutIngressoInput
  }

  export type IngressoUncheckedCreateWithoutSessoesAssentosInput = {
    id?: number
    documentoResponsavel: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    pagamento?: PagamentoUncheckedCreateNestedOneWithoutIngressoInput
  }

  export type IngressoCreateOrConnectWithoutSessoesAssentosInput = {
    where: IngressoWhereUniqueInput
    create: XOR<IngressoCreateWithoutSessoesAssentosInput, IngressoUncheckedCreateWithoutSessoesAssentosInput>
  }

  export type SessaoAssentoStatusCreateWithoutSessoesAssentosInput = {
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type SessaoAssentoStatusUncheckedCreateWithoutSessoesAssentosInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type SessaoAssentoStatusCreateOrConnectWithoutSessoesAssentosInput = {
    where: SessaoAssentoStatusWhereUniqueInput
    create: XOR<SessaoAssentoStatusCreateWithoutSessoesAssentosInput, SessaoAssentoStatusUncheckedCreateWithoutSessoesAssentosInput>
  }

  export type TipoEntradaCreateWithoutSessoesAssentosInput = {
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type TipoEntradaUncheckedCreateWithoutSessoesAssentosInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type TipoEntradaCreateOrConnectWithoutSessoesAssentosInput = {
    where: TipoEntradaWhereUniqueInput
    create: XOR<TipoEntradaCreateWithoutSessoesAssentosInput, TipoEntradaUncheckedCreateWithoutSessoesAssentosInput>
  }

  export type SessaoUpsertWithoutSessoesAssentosInput = {
    update: XOR<SessaoUpdateWithoutSessoesAssentosInput, SessaoUncheckedUpdateWithoutSessoesAssentosInput>
    create: XOR<SessaoCreateWithoutSessoesAssentosInput, SessaoUncheckedCreateWithoutSessoesAssentosInput>
    where?: SessaoWhereInput
  }

  export type SessaoUpdateToOneWithWhereWithoutSessoesAssentosInput = {
    where?: SessaoWhereInput
    data: XOR<SessaoUpdateWithoutSessoesAssentosInput, SessaoUncheckedUpdateWithoutSessoesAssentosInput>
  }

  export type SessaoUpdateWithoutSessoesAssentosInput = {
    inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fim?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    filme?: FilmeUpdateOneRequiredWithoutSessoesNestedInput
    sala?: SalaUpdateOneRequiredWithoutSessoesNestedInput
    tipoSessao?: TipoSessaoUpdateOneRequiredWithoutSessoesNestedInput
    tipoIdioma?: TipoIdiomaUpdateOneRequiredWithoutSessoesNestedInput
  }

  export type SessaoUncheckedUpdateWithoutSessoesAssentosInput = {
    id?: IntFieldUpdateOperationsInput | number
    filmeId?: IntFieldUpdateOperationsInput | number
    salaId?: IntFieldUpdateOperationsInput | number
    tipoSessaoId?: IntFieldUpdateOperationsInput | number
    tipoIdiomaId?: IntFieldUpdateOperationsInput | number
    inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fim?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssentoUpsertWithoutSessoesAssentosInput = {
    update: XOR<AssentoUpdateWithoutSessoesAssentosInput, AssentoUncheckedUpdateWithoutSessoesAssentosInput>
    create: XOR<AssentoCreateWithoutSessoesAssentosInput, AssentoUncheckedCreateWithoutSessoesAssentosInput>
    where?: AssentoWhereInput
  }

  export type AssentoUpdateToOneWithWhereWithoutSessoesAssentosInput = {
    where?: AssentoWhereInput
    data: XOR<AssentoUpdateWithoutSessoesAssentosInput, AssentoUncheckedUpdateWithoutSessoesAssentosInput>
  }

  export type AssentoUpdateWithoutSessoesAssentosInput = {
    fileira?: StringFieldUpdateOperationsInput | string
    coluna?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sala?: SalaUpdateOneRequiredWithoutAssentosNestedInput
    tipoAssento?: TipoAssentoUpdateOneRequiredWithoutAssentosNestedInput
  }

  export type AssentoUncheckedUpdateWithoutSessoesAssentosInput = {
    id?: IntFieldUpdateOperationsInput | number
    salaId?: IntFieldUpdateOperationsInput | number
    tipoAssentoId?: IntFieldUpdateOperationsInput | number
    fileira?: StringFieldUpdateOperationsInput | string
    coluna?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IngressoUpsertWithoutSessoesAssentosInput = {
    update: XOR<IngressoUpdateWithoutSessoesAssentosInput, IngressoUncheckedUpdateWithoutSessoesAssentosInput>
    create: XOR<IngressoCreateWithoutSessoesAssentosInput, IngressoUncheckedCreateWithoutSessoesAssentosInput>
    where?: IngressoWhereInput
  }

  export type IngressoUpdateToOneWithWhereWithoutSessoesAssentosInput = {
    where?: IngressoWhereInput
    data: XOR<IngressoUpdateWithoutSessoesAssentosInput, IngressoUncheckedUpdateWithoutSessoesAssentosInput>
  }

  export type IngressoUpdateWithoutSessoesAssentosInput = {
    documentoResponsavel?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    pagamento?: PagamentoUpdateOneWithoutIngressoNestedInput
  }

  export type IngressoUncheckedUpdateWithoutSessoesAssentosInput = {
    id?: IntFieldUpdateOperationsInput | number
    documentoResponsavel?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    pagamento?: PagamentoUncheckedUpdateOneWithoutIngressoNestedInput
  }

  export type SessaoAssentoStatusUpsertWithoutSessoesAssentosInput = {
    update: XOR<SessaoAssentoStatusUpdateWithoutSessoesAssentosInput, SessaoAssentoStatusUncheckedUpdateWithoutSessoesAssentosInput>
    create: XOR<SessaoAssentoStatusCreateWithoutSessoesAssentosInput, SessaoAssentoStatusUncheckedCreateWithoutSessoesAssentosInput>
    where?: SessaoAssentoStatusWhereInput
  }

  export type SessaoAssentoStatusUpdateToOneWithWhereWithoutSessoesAssentosInput = {
    where?: SessaoAssentoStatusWhereInput
    data: XOR<SessaoAssentoStatusUpdateWithoutSessoesAssentosInput, SessaoAssentoStatusUncheckedUpdateWithoutSessoesAssentosInput>
  }

  export type SessaoAssentoStatusUpdateWithoutSessoesAssentosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessaoAssentoStatusUncheckedUpdateWithoutSessoesAssentosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoEntradaUpsertWithoutSessoesAssentosInput = {
    update: XOR<TipoEntradaUpdateWithoutSessoesAssentosInput, TipoEntradaUncheckedUpdateWithoutSessoesAssentosInput>
    create: XOR<TipoEntradaCreateWithoutSessoesAssentosInput, TipoEntradaUncheckedCreateWithoutSessoesAssentosInput>
    where?: TipoEntradaWhereInput
  }

  export type TipoEntradaUpdateToOneWithWhereWithoutSessoesAssentosInput = {
    where?: TipoEntradaWhereInput
    data: XOR<TipoEntradaUpdateWithoutSessoesAssentosInput, TipoEntradaUncheckedUpdateWithoutSessoesAssentosInput>
  }

  export type TipoEntradaUpdateWithoutSessoesAssentosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TipoEntradaUncheckedUpdateWithoutSessoesAssentosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessaoAssentoCreateWithoutTipoEntradaInput = {
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessao: SessaoCreateNestedOneWithoutSessoesAssentosInput
    assento: AssentoCreateNestedOneWithoutSessoesAssentosInput
    ingresso: IngressoCreateNestedOneWithoutSessoesAssentosInput
    sessaoAssentoStatus: SessaoAssentoStatusCreateNestedOneWithoutSessoesAssentosInput
  }

  export type SessaoAssentoUncheckedCreateWithoutTipoEntradaInput = {
    id?: number
    sessaoId: number
    assentoId: number
    ingressoId: number
    sessaoAssentoStatusId: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type SessaoAssentoCreateOrConnectWithoutTipoEntradaInput = {
    where: SessaoAssentoWhereUniqueInput
    create: XOR<SessaoAssentoCreateWithoutTipoEntradaInput, SessaoAssentoUncheckedCreateWithoutTipoEntradaInput>
  }

  export type SessaoAssentoCreateManyTipoEntradaInputEnvelope = {
    data: SessaoAssentoCreateManyTipoEntradaInput | SessaoAssentoCreateManyTipoEntradaInput[]
    skipDuplicates?: boolean
  }

  export type SessaoAssentoUpsertWithWhereUniqueWithoutTipoEntradaInput = {
    where: SessaoAssentoWhereUniqueInput
    update: XOR<SessaoAssentoUpdateWithoutTipoEntradaInput, SessaoAssentoUncheckedUpdateWithoutTipoEntradaInput>
    create: XOR<SessaoAssentoCreateWithoutTipoEntradaInput, SessaoAssentoUncheckedCreateWithoutTipoEntradaInput>
  }

  export type SessaoAssentoUpdateWithWhereUniqueWithoutTipoEntradaInput = {
    where: SessaoAssentoWhereUniqueInput
    data: XOR<SessaoAssentoUpdateWithoutTipoEntradaInput, SessaoAssentoUncheckedUpdateWithoutTipoEntradaInput>
  }

  export type SessaoAssentoUpdateManyWithWhereWithoutTipoEntradaInput = {
    where: SessaoAssentoScalarWhereInput
    data: XOR<SessaoAssentoUpdateManyMutationInput, SessaoAssentoUncheckedUpdateManyWithoutTipoEntradaInput>
  }

  export type SessaoAssentoCreateWithoutIngressoInput = {
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessao: SessaoCreateNestedOneWithoutSessoesAssentosInput
    assento: AssentoCreateNestedOneWithoutSessoesAssentosInput
    sessaoAssentoStatus: SessaoAssentoStatusCreateNestedOneWithoutSessoesAssentosInput
    tipoEntrada: TipoEntradaCreateNestedOneWithoutSessoesAssentosInput
  }

  export type SessaoAssentoUncheckedCreateWithoutIngressoInput = {
    id?: number
    sessaoId: number
    assentoId: number
    sessaoAssentoStatusId: number
    tipoEntradaId: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type SessaoAssentoCreateOrConnectWithoutIngressoInput = {
    where: SessaoAssentoWhereUniqueInput
    create: XOR<SessaoAssentoCreateWithoutIngressoInput, SessaoAssentoUncheckedCreateWithoutIngressoInput>
  }

  export type SessaoAssentoCreateManyIngressoInputEnvelope = {
    data: SessaoAssentoCreateManyIngressoInput | SessaoAssentoCreateManyIngressoInput[]
    skipDuplicates?: boolean
  }

  export type PagamentoCreateWithoutIngressoInput = {
    valorTotal: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    formaPagamento: FormaPagamentoCreateNestedOneWithoutPagamentosInput
  }

  export type PagamentoUncheckedCreateWithoutIngressoInput = {
    id?: number
    formaPagamentoId: number
    valorTotal: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type PagamentoCreateOrConnectWithoutIngressoInput = {
    where: PagamentoWhereUniqueInput
    create: XOR<PagamentoCreateWithoutIngressoInput, PagamentoUncheckedCreateWithoutIngressoInput>
  }

  export type SessaoAssentoUpsertWithWhereUniqueWithoutIngressoInput = {
    where: SessaoAssentoWhereUniqueInput
    update: XOR<SessaoAssentoUpdateWithoutIngressoInput, SessaoAssentoUncheckedUpdateWithoutIngressoInput>
    create: XOR<SessaoAssentoCreateWithoutIngressoInput, SessaoAssentoUncheckedCreateWithoutIngressoInput>
  }

  export type SessaoAssentoUpdateWithWhereUniqueWithoutIngressoInput = {
    where: SessaoAssentoWhereUniqueInput
    data: XOR<SessaoAssentoUpdateWithoutIngressoInput, SessaoAssentoUncheckedUpdateWithoutIngressoInput>
  }

  export type SessaoAssentoUpdateManyWithWhereWithoutIngressoInput = {
    where: SessaoAssentoScalarWhereInput
    data: XOR<SessaoAssentoUpdateManyMutationInput, SessaoAssentoUncheckedUpdateManyWithoutIngressoInput>
  }

  export type PagamentoUpsertWithoutIngressoInput = {
    update: XOR<PagamentoUpdateWithoutIngressoInput, PagamentoUncheckedUpdateWithoutIngressoInput>
    create: XOR<PagamentoCreateWithoutIngressoInput, PagamentoUncheckedCreateWithoutIngressoInput>
    where?: PagamentoWhereInput
  }

  export type PagamentoUpdateToOneWithWhereWithoutIngressoInput = {
    where?: PagamentoWhereInput
    data: XOR<PagamentoUpdateWithoutIngressoInput, PagamentoUncheckedUpdateWithoutIngressoInput>
  }

  export type PagamentoUpdateWithoutIngressoInput = {
    valorTotal?: FloatFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    formaPagamento?: FormaPagamentoUpdateOneRequiredWithoutPagamentosNestedInput
  }

  export type PagamentoUncheckedUpdateWithoutIngressoInput = {
    id?: IntFieldUpdateOperationsInput | number
    formaPagamentoId?: IntFieldUpdateOperationsInput | number
    valorTotal?: FloatFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagamentoCreateWithoutFormaPagamentoInput = {
    valorTotal: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    ingresso: IngressoCreateNestedOneWithoutPagamentoInput
  }

  export type PagamentoUncheckedCreateWithoutFormaPagamentoInput = {
    id?: number
    ingressoId: number
    valorTotal: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type PagamentoCreateOrConnectWithoutFormaPagamentoInput = {
    where: PagamentoWhereUniqueInput
    create: XOR<PagamentoCreateWithoutFormaPagamentoInput, PagamentoUncheckedCreateWithoutFormaPagamentoInput>
  }

  export type PagamentoCreateManyFormaPagamentoInputEnvelope = {
    data: PagamentoCreateManyFormaPagamentoInput | PagamentoCreateManyFormaPagamentoInput[]
    skipDuplicates?: boolean
  }

  export type PagamentoUpsertWithWhereUniqueWithoutFormaPagamentoInput = {
    where: PagamentoWhereUniqueInput
    update: XOR<PagamentoUpdateWithoutFormaPagamentoInput, PagamentoUncheckedUpdateWithoutFormaPagamentoInput>
    create: XOR<PagamentoCreateWithoutFormaPagamentoInput, PagamentoUncheckedCreateWithoutFormaPagamentoInput>
  }

  export type PagamentoUpdateWithWhereUniqueWithoutFormaPagamentoInput = {
    where: PagamentoWhereUniqueInput
    data: XOR<PagamentoUpdateWithoutFormaPagamentoInput, PagamentoUncheckedUpdateWithoutFormaPagamentoInput>
  }

  export type PagamentoUpdateManyWithWhereWithoutFormaPagamentoInput = {
    where: PagamentoScalarWhereInput
    data: XOR<PagamentoUpdateManyMutationInput, PagamentoUncheckedUpdateManyWithoutFormaPagamentoInput>
  }

  export type PagamentoScalarWhereInput = {
    AND?: PagamentoScalarWhereInput | PagamentoScalarWhereInput[]
    OR?: PagamentoScalarWhereInput[]
    NOT?: PagamentoScalarWhereInput | PagamentoScalarWhereInput[]
    id?: IntFilter<"Pagamento"> | number
    ingressoId?: IntFilter<"Pagamento"> | number
    formaPagamentoId?: IntFilter<"Pagamento"> | number
    valorTotal?: FloatFilter<"Pagamento"> | number
    ativo?: BoolFilter<"Pagamento"> | boolean
    criadoEm?: DateTimeFilter<"Pagamento"> | Date | string
    atualizadoEm?: DateTimeFilter<"Pagamento"> | Date | string
  }

  export type IngressoCreateWithoutPagamentoInput = {
    documentoResponsavel: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessoesAssentos?: SessaoAssentoCreateNestedManyWithoutIngressoInput
  }

  export type IngressoUncheckedCreateWithoutPagamentoInput = {
    id?: number
    documentoResponsavel: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
    sessoesAssentos?: SessaoAssentoUncheckedCreateNestedManyWithoutIngressoInput
  }

  export type IngressoCreateOrConnectWithoutPagamentoInput = {
    where: IngressoWhereUniqueInput
    create: XOR<IngressoCreateWithoutPagamentoInput, IngressoUncheckedCreateWithoutPagamentoInput>
  }

  export type FormaPagamentoCreateWithoutPagamentosInput = {
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type FormaPagamentoUncheckedCreateWithoutPagamentosInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type FormaPagamentoCreateOrConnectWithoutPagamentosInput = {
    where: FormaPagamentoWhereUniqueInput
    create: XOR<FormaPagamentoCreateWithoutPagamentosInput, FormaPagamentoUncheckedCreateWithoutPagamentosInput>
  }

  export type IngressoUpsertWithoutPagamentoInput = {
    update: XOR<IngressoUpdateWithoutPagamentoInput, IngressoUncheckedUpdateWithoutPagamentoInput>
    create: XOR<IngressoCreateWithoutPagamentoInput, IngressoUncheckedCreateWithoutPagamentoInput>
    where?: IngressoWhereInput
  }

  export type IngressoUpdateToOneWithWhereWithoutPagamentoInput = {
    where?: IngressoWhereInput
    data: XOR<IngressoUpdateWithoutPagamentoInput, IngressoUncheckedUpdateWithoutPagamentoInput>
  }

  export type IngressoUpdateWithoutPagamentoInput = {
    documentoResponsavel?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessoesAssentos?: SessaoAssentoUpdateManyWithoutIngressoNestedInput
  }

  export type IngressoUncheckedUpdateWithoutPagamentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    documentoResponsavel?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessoesAssentos?: SessaoAssentoUncheckedUpdateManyWithoutIngressoNestedInput
  }

  export type FormaPagamentoUpsertWithoutPagamentosInput = {
    update: XOR<FormaPagamentoUpdateWithoutPagamentosInput, FormaPagamentoUncheckedUpdateWithoutPagamentosInput>
    create: XOR<FormaPagamentoCreateWithoutPagamentosInput, FormaPagamentoUncheckedCreateWithoutPagamentosInput>
    where?: FormaPagamentoWhereInput
  }

  export type FormaPagamentoUpdateToOneWithWhereWithoutPagamentosInput = {
    where?: FormaPagamentoWhereInput
    data: XOR<FormaPagamentoUpdateWithoutPagamentosInput, FormaPagamentoUncheckedUpdateWithoutPagamentosInput>
  }

  export type FormaPagamentoUpdateWithoutPagamentosInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FormaPagamentoUncheckedUpdateWithoutPagamentosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilmeGeneroCreateManyGeneroInput = {
    id?: number
    filmeId: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type FilmeGeneroUpdateWithoutGeneroInput = {
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    filme?: FilmeUpdateOneRequiredWithoutGenerosNestedInput
  }

  export type FilmeGeneroUncheckedUpdateWithoutGeneroInput = {
    id?: IntFieldUpdateOperationsInput | number
    filmeId?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilmeGeneroUncheckedUpdateManyWithoutGeneroInput = {
    id?: IntFieldUpdateOperationsInput | number
    filmeId?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilmeGeneroCreateManyFilmeInput = {
    id?: number
    generoId: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type FilmeIntegranteCreateManyFilmeInput = {
    id?: number
    integranteId: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type SessaoCreateManyFilmeInput = {
    id?: number
    salaId: number
    tipoSessaoId: number
    tipoIdiomaId: number
    inicio: Date | string
    fim: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type FilmeGeneroUpdateWithoutFilmeInput = {
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    genero?: GeneroUpdateOneRequiredWithoutFilmesNestedInput
  }

  export type FilmeGeneroUncheckedUpdateWithoutFilmeInput = {
    id?: IntFieldUpdateOperationsInput | number
    generoId?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilmeGeneroUncheckedUpdateManyWithoutFilmeInput = {
    id?: IntFieldUpdateOperationsInput | number
    generoId?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilmeIntegranteUpdateWithoutFilmeInput = {
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    integrante?: IntegranteUpdateOneRequiredWithoutFilmesNestedInput
  }

  export type FilmeIntegranteUncheckedUpdateWithoutFilmeInput = {
    id?: IntFieldUpdateOperationsInput | number
    integranteId?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilmeIntegranteUncheckedUpdateManyWithoutFilmeInput = {
    id?: IntFieldUpdateOperationsInput | number
    integranteId?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessaoUpdateWithoutFilmeInput = {
    inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fim?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sala?: SalaUpdateOneRequiredWithoutSessoesNestedInput
    tipoSessao?: TipoSessaoUpdateOneRequiredWithoutSessoesNestedInput
    tipoIdioma?: TipoIdiomaUpdateOneRequiredWithoutSessoesNestedInput
    sessoesAssentos?: SessaoAssentoUpdateManyWithoutSessaoNestedInput
  }

  export type SessaoUncheckedUpdateWithoutFilmeInput = {
    id?: IntFieldUpdateOperationsInput | number
    salaId?: IntFieldUpdateOperationsInput | number
    tipoSessaoId?: IntFieldUpdateOperationsInput | number
    tipoIdiomaId?: IntFieldUpdateOperationsInput | number
    inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fim?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessoesAssentos?: SessaoAssentoUncheckedUpdateManyWithoutSessaoNestedInput
  }

  export type SessaoUncheckedUpdateManyWithoutFilmeInput = {
    id?: IntFieldUpdateOperationsInput | number
    salaId?: IntFieldUpdateOperationsInput | number
    tipoSessaoId?: IntFieldUpdateOperationsInput | number
    tipoIdiomaId?: IntFieldUpdateOperationsInput | number
    inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fim?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilmeIntegranteCreateManyIntegranteInput = {
    id?: number
    filmeId: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type FilmeIntegranteUpdateWithoutIntegranteInput = {
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    filme?: FilmeUpdateOneRequiredWithoutIntegrantesNestedInput
  }

  export type FilmeIntegranteUncheckedUpdateWithoutIntegranteInput = {
    id?: IntFieldUpdateOperationsInput | number
    filmeId?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilmeIntegranteUncheckedUpdateManyWithoutIntegranteInput = {
    id?: IntFieldUpdateOperationsInput | number
    filmeId?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegranteCreateManyTipoIntegranteInput = {
    id?: number
    nome: string
    sobrenome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type IntegranteUpdateWithoutTipoIntegranteInput = {
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    filmes?: FilmeIntegranteUpdateManyWithoutIntegranteNestedInput
  }

  export type IntegranteUncheckedUpdateWithoutTipoIntegranteInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    filmes?: FilmeIntegranteUncheckedUpdateManyWithoutIntegranteNestedInput
  }

  export type IntegranteUncheckedUpdateManyWithoutTipoIntegranteInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    sobrenome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FilmeCreateManyClassificacaoIndicativaInput = {
    id?: number
    titulo: string
    descricao: string
    duracaoEmMinutos: number
    trailerUrl: string
    capaUrl: string
    dataLancamento: Date | string
    dataInicioCartaz: Date | string
    dataFimCartaz: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type FilmeUpdateWithoutClassificacaoIndicativaInput = {
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    duracaoEmMinutos?: IntFieldUpdateOperationsInput | number
    trailerUrl?: StringFieldUpdateOperationsInput | string
    capaUrl?: StringFieldUpdateOperationsInput | string
    dataLancamento?: DateTimeFieldUpdateOperationsInput | Date | string
    dataInicioCartaz?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFimCartaz?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    generos?: FilmeGeneroUpdateManyWithoutFilmeNestedInput
    integrantes?: FilmeIntegranteUpdateManyWithoutFilmeNestedInput
    sessoes?: SessaoUpdateManyWithoutFilmeNestedInput
  }

  export type FilmeUncheckedUpdateWithoutClassificacaoIndicativaInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    duracaoEmMinutos?: IntFieldUpdateOperationsInput | number
    trailerUrl?: StringFieldUpdateOperationsInput | string
    capaUrl?: StringFieldUpdateOperationsInput | string
    dataLancamento?: DateTimeFieldUpdateOperationsInput | Date | string
    dataInicioCartaz?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFimCartaz?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    generos?: FilmeGeneroUncheckedUpdateManyWithoutFilmeNestedInput
    integrantes?: FilmeIntegranteUncheckedUpdateManyWithoutFilmeNestedInput
    sessoes?: SessaoUncheckedUpdateManyWithoutFilmeNestedInput
  }

  export type FilmeUncheckedUpdateManyWithoutClassificacaoIndicativaInput = {
    id?: IntFieldUpdateOperationsInput | number
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    duracaoEmMinutos?: IntFieldUpdateOperationsInput | number
    trailerUrl?: StringFieldUpdateOperationsInput | string
    capaUrl?: StringFieldUpdateOperationsInput | string
    dataLancamento?: DateTimeFieldUpdateOperationsInput | Date | string
    dataInicioCartaz?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFimCartaz?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessaoCreateManyTipoIdiomaInput = {
    id?: number
    filmeId: number
    salaId: number
    tipoSessaoId: number
    inicio: Date | string
    fim: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type SessaoUpdateWithoutTipoIdiomaInput = {
    inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fim?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    filme?: FilmeUpdateOneRequiredWithoutSessoesNestedInput
    sala?: SalaUpdateOneRequiredWithoutSessoesNestedInput
    tipoSessao?: TipoSessaoUpdateOneRequiredWithoutSessoesNestedInput
    sessoesAssentos?: SessaoAssentoUpdateManyWithoutSessaoNestedInput
  }

  export type SessaoUncheckedUpdateWithoutTipoIdiomaInput = {
    id?: IntFieldUpdateOperationsInput | number
    filmeId?: IntFieldUpdateOperationsInput | number
    salaId?: IntFieldUpdateOperationsInput | number
    tipoSessaoId?: IntFieldUpdateOperationsInput | number
    inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fim?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessoesAssentos?: SessaoAssentoUncheckedUpdateManyWithoutSessaoNestedInput
  }

  export type SessaoUncheckedUpdateManyWithoutTipoIdiomaInput = {
    id?: IntFieldUpdateOperationsInput | number
    filmeId?: IntFieldUpdateOperationsInput | number
    salaId?: IntFieldUpdateOperationsInput | number
    tipoSessaoId?: IntFieldUpdateOperationsInput | number
    inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fim?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessaoCreateManyTipoSessaoInput = {
    id?: number
    filmeId: number
    salaId: number
    tipoIdiomaId: number
    inicio: Date | string
    fim: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type SessaoUpdateWithoutTipoSessaoInput = {
    inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fim?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    filme?: FilmeUpdateOneRequiredWithoutSessoesNestedInput
    sala?: SalaUpdateOneRequiredWithoutSessoesNestedInput
    tipoIdioma?: TipoIdiomaUpdateOneRequiredWithoutSessoesNestedInput
    sessoesAssentos?: SessaoAssentoUpdateManyWithoutSessaoNestedInput
  }

  export type SessaoUncheckedUpdateWithoutTipoSessaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    filmeId?: IntFieldUpdateOperationsInput | number
    salaId?: IntFieldUpdateOperationsInput | number
    tipoIdiomaId?: IntFieldUpdateOperationsInput | number
    inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fim?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessoesAssentos?: SessaoAssentoUncheckedUpdateManyWithoutSessaoNestedInput
  }

  export type SessaoUncheckedUpdateManyWithoutTipoSessaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    filmeId?: IntFieldUpdateOperationsInput | number
    salaId?: IntFieldUpdateOperationsInput | number
    tipoIdiomaId?: IntFieldUpdateOperationsInput | number
    inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fim?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessaoAssentoCreateManySessaoInput = {
    id?: number
    assentoId: number
    ingressoId: number
    sessaoAssentoStatusId: number
    tipoEntradaId: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type SessaoAssentoUpdateWithoutSessaoInput = {
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    assento?: AssentoUpdateOneRequiredWithoutSessoesAssentosNestedInput
    ingresso?: IngressoUpdateOneRequiredWithoutSessoesAssentosNestedInput
    sessaoAssentoStatus?: SessaoAssentoStatusUpdateOneRequiredWithoutSessoesAssentosNestedInput
    tipoEntrada?: TipoEntradaUpdateOneRequiredWithoutSessoesAssentosNestedInput
  }

  export type SessaoAssentoUncheckedUpdateWithoutSessaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    assentoId?: IntFieldUpdateOperationsInput | number
    ingressoId?: IntFieldUpdateOperationsInput | number
    sessaoAssentoStatusId?: IntFieldUpdateOperationsInput | number
    tipoEntradaId?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessaoAssentoUncheckedUpdateManyWithoutSessaoInput = {
    id?: IntFieldUpdateOperationsInput | number
    assentoId?: IntFieldUpdateOperationsInput | number
    ingressoId?: IntFieldUpdateOperationsInput | number
    sessaoAssentoStatusId?: IntFieldUpdateOperationsInput | number
    tipoEntradaId?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaCreateManyTipoSalaInput = {
    id?: number
    nome: string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type SalaUpdateWithoutTipoSalaInput = {
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessoes?: SessaoUpdateManyWithoutSalaNestedInput
    assentos?: AssentoUpdateManyWithoutSalaNestedInput
  }

  export type SalaUncheckedUpdateWithoutTipoSalaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessoes?: SessaoUncheckedUpdateManyWithoutSalaNestedInput
    assentos?: AssentoUncheckedUpdateManyWithoutSalaNestedInput
  }

  export type SalaUncheckedUpdateManyWithoutTipoSalaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessaoCreateManySalaInput = {
    id?: number
    filmeId: number
    tipoSessaoId: number
    tipoIdiomaId: number
    inicio: Date | string
    fim: Date | string
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type AssentoCreateManySalaInput = {
    id?: number
    tipoAssentoId: number
    fileira: string
    coluna: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type SessaoUpdateWithoutSalaInput = {
    inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fim?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    filme?: FilmeUpdateOneRequiredWithoutSessoesNestedInput
    tipoSessao?: TipoSessaoUpdateOneRequiredWithoutSessoesNestedInput
    tipoIdioma?: TipoIdiomaUpdateOneRequiredWithoutSessoesNestedInput
    sessoesAssentos?: SessaoAssentoUpdateManyWithoutSessaoNestedInput
  }

  export type SessaoUncheckedUpdateWithoutSalaInput = {
    id?: IntFieldUpdateOperationsInput | number
    filmeId?: IntFieldUpdateOperationsInput | number
    tipoSessaoId?: IntFieldUpdateOperationsInput | number
    tipoIdiomaId?: IntFieldUpdateOperationsInput | number
    inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fim?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessoesAssentos?: SessaoAssentoUncheckedUpdateManyWithoutSessaoNestedInput
  }

  export type SessaoUncheckedUpdateManyWithoutSalaInput = {
    id?: IntFieldUpdateOperationsInput | number
    filmeId?: IntFieldUpdateOperationsInput | number
    tipoSessaoId?: IntFieldUpdateOperationsInput | number
    tipoIdiomaId?: IntFieldUpdateOperationsInput | number
    inicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fim?: DateTimeFieldUpdateOperationsInput | Date | string
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssentoUpdateWithoutSalaInput = {
    fileira?: StringFieldUpdateOperationsInput | string
    coluna?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    tipoAssento?: TipoAssentoUpdateOneRequiredWithoutAssentosNestedInput
    sessoesAssentos?: SessaoAssentoUpdateManyWithoutAssentoNestedInput
  }

  export type AssentoUncheckedUpdateWithoutSalaInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoAssentoId?: IntFieldUpdateOperationsInput | number
    fileira?: StringFieldUpdateOperationsInput | string
    coluna?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessoesAssentos?: SessaoAssentoUncheckedUpdateManyWithoutAssentoNestedInput
  }

  export type AssentoUncheckedUpdateManyWithoutSalaInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipoAssentoId?: IntFieldUpdateOperationsInput | number
    fileira?: StringFieldUpdateOperationsInput | string
    coluna?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AssentoCreateManyTipoAssentoInput = {
    id?: number
    salaId: number
    fileira: string
    coluna: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type AssentoUpdateWithoutTipoAssentoInput = {
    fileira?: StringFieldUpdateOperationsInput | string
    coluna?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sala?: SalaUpdateOneRequiredWithoutAssentosNestedInput
    sessoesAssentos?: SessaoAssentoUpdateManyWithoutAssentoNestedInput
  }

  export type AssentoUncheckedUpdateWithoutTipoAssentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    salaId?: IntFieldUpdateOperationsInput | number
    fileira?: StringFieldUpdateOperationsInput | string
    coluna?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessoesAssentos?: SessaoAssentoUncheckedUpdateManyWithoutAssentoNestedInput
  }

  export type AssentoUncheckedUpdateManyWithoutTipoAssentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    salaId?: IntFieldUpdateOperationsInput | number
    fileira?: StringFieldUpdateOperationsInput | string
    coluna?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessaoAssentoCreateManyAssentoInput = {
    id?: number
    sessaoId: number
    ingressoId: number
    sessaoAssentoStatusId: number
    tipoEntradaId: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type SessaoAssentoUpdateWithoutAssentoInput = {
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessao?: SessaoUpdateOneRequiredWithoutSessoesAssentosNestedInput
    ingresso?: IngressoUpdateOneRequiredWithoutSessoesAssentosNestedInput
    sessaoAssentoStatus?: SessaoAssentoStatusUpdateOneRequiredWithoutSessoesAssentosNestedInput
    tipoEntrada?: TipoEntradaUpdateOneRequiredWithoutSessoesAssentosNestedInput
  }

  export type SessaoAssentoUncheckedUpdateWithoutAssentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessaoId?: IntFieldUpdateOperationsInput | number
    ingressoId?: IntFieldUpdateOperationsInput | number
    sessaoAssentoStatusId?: IntFieldUpdateOperationsInput | number
    tipoEntradaId?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessaoAssentoUncheckedUpdateManyWithoutAssentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessaoId?: IntFieldUpdateOperationsInput | number
    ingressoId?: IntFieldUpdateOperationsInput | number
    sessaoAssentoStatusId?: IntFieldUpdateOperationsInput | number
    tipoEntradaId?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessaoAssentoCreateManySessaoAssentoStatusInput = {
    id?: number
    sessaoId: number
    assentoId: number
    ingressoId: number
    tipoEntradaId: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type SessaoAssentoUpdateWithoutSessaoAssentoStatusInput = {
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessao?: SessaoUpdateOneRequiredWithoutSessoesAssentosNestedInput
    assento?: AssentoUpdateOneRequiredWithoutSessoesAssentosNestedInput
    ingresso?: IngressoUpdateOneRequiredWithoutSessoesAssentosNestedInput
    tipoEntrada?: TipoEntradaUpdateOneRequiredWithoutSessoesAssentosNestedInput
  }

  export type SessaoAssentoUncheckedUpdateWithoutSessaoAssentoStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessaoId?: IntFieldUpdateOperationsInput | number
    assentoId?: IntFieldUpdateOperationsInput | number
    ingressoId?: IntFieldUpdateOperationsInput | number
    tipoEntradaId?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessaoAssentoUncheckedUpdateManyWithoutSessaoAssentoStatusInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessaoId?: IntFieldUpdateOperationsInput | number
    assentoId?: IntFieldUpdateOperationsInput | number
    ingressoId?: IntFieldUpdateOperationsInput | number
    tipoEntradaId?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessaoAssentoCreateManyTipoEntradaInput = {
    id?: number
    sessaoId: number
    assentoId: number
    ingressoId: number
    sessaoAssentoStatusId: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type SessaoAssentoUpdateWithoutTipoEntradaInput = {
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessao?: SessaoUpdateOneRequiredWithoutSessoesAssentosNestedInput
    assento?: AssentoUpdateOneRequiredWithoutSessoesAssentosNestedInput
    ingresso?: IngressoUpdateOneRequiredWithoutSessoesAssentosNestedInput
    sessaoAssentoStatus?: SessaoAssentoStatusUpdateOneRequiredWithoutSessoesAssentosNestedInput
  }

  export type SessaoAssentoUncheckedUpdateWithoutTipoEntradaInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessaoId?: IntFieldUpdateOperationsInput | number
    assentoId?: IntFieldUpdateOperationsInput | number
    ingressoId?: IntFieldUpdateOperationsInput | number
    sessaoAssentoStatusId?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessaoAssentoUncheckedUpdateManyWithoutTipoEntradaInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessaoId?: IntFieldUpdateOperationsInput | number
    assentoId?: IntFieldUpdateOperationsInput | number
    ingressoId?: IntFieldUpdateOperationsInput | number
    sessaoAssentoStatusId?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessaoAssentoCreateManyIngressoInput = {
    id?: number
    sessaoId: number
    assentoId: number
    sessaoAssentoStatusId: number
    tipoEntradaId: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type SessaoAssentoUpdateWithoutIngressoInput = {
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    sessao?: SessaoUpdateOneRequiredWithoutSessoesAssentosNestedInput
    assento?: AssentoUpdateOneRequiredWithoutSessoesAssentosNestedInput
    sessaoAssentoStatus?: SessaoAssentoStatusUpdateOneRequiredWithoutSessoesAssentosNestedInput
    tipoEntrada?: TipoEntradaUpdateOneRequiredWithoutSessoesAssentosNestedInput
  }

  export type SessaoAssentoUncheckedUpdateWithoutIngressoInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessaoId?: IntFieldUpdateOperationsInput | number
    assentoId?: IntFieldUpdateOperationsInput | number
    sessaoAssentoStatusId?: IntFieldUpdateOperationsInput | number
    tipoEntradaId?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessaoAssentoUncheckedUpdateManyWithoutIngressoInput = {
    id?: IntFieldUpdateOperationsInput | number
    sessaoId?: IntFieldUpdateOperationsInput | number
    assentoId?: IntFieldUpdateOperationsInput | number
    sessaoAssentoStatusId?: IntFieldUpdateOperationsInput | number
    tipoEntradaId?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagamentoCreateManyFormaPagamentoInput = {
    id?: number
    ingressoId: number
    valorTotal: number
    ativo?: boolean
    criadoEm?: Date | string
    atualizadoEm?: Date | string
  }

  export type PagamentoUpdateWithoutFormaPagamentoInput = {
    valorTotal?: FloatFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    ingresso?: IngressoUpdateOneRequiredWithoutPagamentoNestedInput
  }

  export type PagamentoUncheckedUpdateWithoutFormaPagamentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    ingressoId?: IntFieldUpdateOperationsInput | number
    valorTotal?: FloatFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PagamentoUncheckedUpdateManyWithoutFormaPagamentoInput = {
    id?: IntFieldUpdateOperationsInput | number
    ingressoId?: IntFieldUpdateOperationsInput | number
    valorTotal?: FloatFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    criadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
    atualizadoEm?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}